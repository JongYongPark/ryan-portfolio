<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><script src="/portfolio/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=portfolio/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>RyanLabs</title>
<meta name="keywords" content="">
<meta name="description" content="sshfs가 인식되지 않는다는 오류
sshfs가 인식되지 않는다는 오류가 발생한 이유는 sshfs-win이 설치되지 않았거나 sshfs 명령어가 PowerShell에서 인식되지 않기 때문입니다.
해결 방법:


sshfs-win 설치 확인
sshfs를 사용하려면 WinFsp와 SSHFS-Win이 설치되어 있어야 합니다.

WinFsp 다운로드
SSHFS-Win 다운로드

설치 후, PowerShell을 다시 실행하고 아래 명령어로 sshfs가 인식되는지 확인하세요:
sshfs --version


PowerShell에서 sshfs 실행 가능하도록 경로 설정
sshfs.exe가 C:\Program Files\SSHFS-Win\bin에 위치해 있다면, 이를 PATH에 추가해야 합니다.
PowerShell에서 다음 명령어를 실행하세요:
$env:Path &#43;= &#34;;C:\Program Files\SSHFS-Win\bin&#34;


수정된 스크립트
위 방법이 적용된 후, Mount-JonparkDrive 함수를 수정하여 정상적으로 실행되도록 변경했습니다.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/portfolio/posts/technical-support/windows-setting/">
<link crossorigin="anonymous" href="/portfolio/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/portfolio/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/portfolio/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/portfolio/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/portfolio/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/portfolio/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/portfolio/posts/technical-support/windows-setting/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/portfolio/" accesskey="h" title="RyanLabs (Alt + H)">RyanLabs</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/portfolio/search/" title="검색">
                    <span>검색</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/categories/" title="카테고리">
                    <span>카테고리</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/tags/" title="태그">
                    <span>태그</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/archives/" title="연도">
                    <span>연도</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/lectures/" title="강의">
                    <span>강의</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/about/" title="어바웃미">
                    <span>어바웃미</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="sshfs가-인식되지-않는다는-오류">sshfs가 인식되지 않는다는 오류<a hidden class="anchor" aria-hidden="true" href="#sshfs가-인식되지-않는다는-오류">#</a></h1>
<p><code>sshfs</code>가 인식되지 않는다는 오류가 발생한 이유는 <code>sshfs-win</code>이 설치되지 않았거나 <code>sshfs</code> 명령어가 PowerShell에서 인식되지 않기 때문입니다.</p>
<h3 id="해결-방법">해결 방법:<a hidden class="anchor" aria-hidden="true" href="#해결-방법">#</a></h3>
<ol>
<li>
<p><strong><code>sshfs-win</code> 설치 확인</strong><br>
<code>sshfs</code>를 사용하려면 <code>WinFsp</code>와 <code>SSHFS-Win</code>이 설치되어 있어야 합니다.</p>
<ul>
<li><a href="https://github.com/winfsp/winfsp/releases">WinFsp 다운로드</a></li>
<li><a href="https://github.com/billziss-gh/sshfs-win/releases">SSHFS-Win 다운로드</a></li>
</ul>
<p>설치 후, PowerShell을 다시 실행하고 아래 명령어로 <code>sshfs</code>가 인식되는지 확인하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs --version
</span></span></code></pre></div></li>
<li>
<p><strong>PowerShell에서 <code>sshfs</code> 실행 가능하도록 경로 설정</strong><br>
<code>sshfs.exe</code>가 <code>C:\Program Files\SSHFS-Win\bin</code>에 위치해 있다면, 이를 <code>PATH</code>에 추가해야 합니다.<br>
PowerShell에서 다음 명령어를 실행하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$env:Path += <span style="color:#e6db74">&#34;;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span></code></pre></div></li>
<li>
<p><strong>수정된 스크립트</strong><br>
위 방법이 적용된 후, <code>Mount-JonparkDrive</code> 함수를 수정하여 정상적으로 실행되도록 변경했습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Mount-JonparkDrive {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span>(
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$DriveLetter = <span style="color:#e6db74">&#34;J&#34;</span>,
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$RemotePath = <span style="color:#e6db74">&#34;jonpark@aws-sig-ts-jonpark.aws.internal:/&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSHFS 실행 가능한지 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Get-Command sshfs -ErrorAction SilentlyContinue)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Error: sshfs is not installed or not in PATH.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 드라이브가 이미 연결되었는지 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Drive </span>${DriveLetter}<span style="color:#e6db74">: is already mounted.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sshfs $RemotePath <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Successfully mounted drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Error mounting drive: </span>$_<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Dismount-JonparkDrive {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span>(
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$DriveLetter = <span style="color:#e6db74">&#34;J&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Drive </span>${DriveLetter}<span style="color:#e6db74">: is not mounted.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        net use <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span> /delete /y
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Successfully dismounted drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Error dismounting drive: </span>$_<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Set-Alias mount-jonpark Mount-JonparkDrive
</span></span><span style="display:flex;"><span>Set-Alias umount-jonpark Dismount-JonparkDrive
</span></span></code></pre></div></li>
</ol>
<h3 id="변경-사항">변경 사항:<a hidden class="anchor" aria-hidden="true" href="#변경-사항">#</a></h3>
<ul>
<li><strong><code>sshfs</code>가 설치되었는지 확인</strong>하도록 추가 (<code>Get-Command sshfs</code> 사용).</li>
<li><strong>이미 마운트된 드라이브인지 확인</strong>하고 중복 마운트를 방지.</li>
<li><strong><code>net use /delete</code>를 사용할 때 <code>-y</code> 옵션 추가</strong>하여 사용자 입력 없이 강제 제거.</li>
</ul>
<h2 id="수정-후-다시-실행해보고-문제가-있다면-추가적으로-확인해볼게요-">수정 후 다시 실행해보고 문제가 있다면 추가적으로 확인해볼게요. 😊<a hidden class="anchor" aria-hidden="true" href="#수정-후-다시-실행해보고-문제가-있다면-추가적으로-확인해볼게요-">#</a></h2>
<h1 id="sshfs-win-이-설치된-경로를-찾는-명령어">SSHFS-Win 이 설치된 경로를 찾는 명령어<a hidden class="anchor" aria-hidden="true" href="#sshfs-win-이-설치된-경로를-찾는-명령어">#</a></h1>
<p>SSHFS-Win이 설치된 경로를 찾는 방법은 여러 가지가 있습니다. 다음 명령어를 PowerShell에서 실행해보세요.</p>
<h3 id="1-레지스트리에서-설치-경로-확인">1. <strong>레지스트리에서 설치 경로 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-레지스트리에서-설치-경로-확인">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-ItemProperty -Path <span style="color:#e6db74">&#34;HKLM:\SOFTWARE\WOW6432Node\WinFsp&#34;</span> -Name InstallDir
</span></span></code></pre></div><p>또는 (64비트 시스템에서 32비트 레지스트리를 검색할 경우)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-ItemProperty -Path <span style="color:#e6db74">&#34;HKLM:\SOFTWARE\WinFsp&#34;</span> -Name InstallDir
</span></span></code></pre></div><p>위 명령어를 실행하면 <code>WinFsp</code>의 설치 경로를 확인할 수 있습니다. SSHFS-Win은 WinFsp에 의존하므로 관련 경로를 확인할 수 있습니다.</p>
<hr>
<h3 id="2-프로그램-파일에서-직접-확인">2. <strong>프로그램 파일에서 직접 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-프로그램-파일에서-직접-확인">#</a></h3>
<p>SSHFS-Win이 보통 설치되는 경로:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>ls <span style="color:#e6db74">&#34;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span></code></pre></div><p>또는</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>ls <span style="color:#e6db74">&#34;C:\Program Files (x86)\SSHFS-Win\bin&#34;</span>
</span></span></code></pre></div><p>이 폴더 안에 <code>sshfs.exe</code>가 있으면, 해당 경로가 SSHFS-Win이 설치된 위치입니다.</p>
<hr>
<h3 id="3-where-명령어로-실행-파일-검색">3. <strong><code>where</code> 명령어로 실행 파일 검색</strong><a hidden class="anchor" aria-hidden="true" href="#3-where-명령어로-실행-파일-검색">#</a></h3>
<p>SSHFS-Win이 환경 변수(<code>PATH</code>)에 등록되어 있다면 다음 명령어로 확인할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>where sshfs
</span></span></code></pre></div><p>위 명령어가 <code>sshfs.exe</code>의 전체 경로를 반환하면 해당 위치에서 실행 가능합니다.</p>
<hr>
<h3 id="4-파일-탐색기로-검색">4. <strong>파일 탐색기로 검색</strong><a hidden class="anchor" aria-hidden="true" href="#4-파일-탐색기로-검색">#</a></h3>
<p>파일 탐색기에서 <code>C:\Program Files</code>, <code>C:\Program Files (x86)</code>, <code>C:\Users\USERNAME\AppData\Local\Programs</code> 등의 폴더에서 <code>sshfs.exe</code>를 직접 검색할 수도 있습니다.</p>
<p>위 방법 중 하나를 사용하여 SSHFS-Win의 설치 경로를 찾아보세요! 😊</p>
<hr>
<h1 id="evn-path-영구적으로-적용">evn path 영구적으로 적용<a hidden class="anchor" aria-hidden="true" href="#evn-path-영구적으로-적용">#</a></h1>
<p>현재 세션에서만 동작하는 <code>$env:Path += &quot;;C:\Program Files\SSHFS-Win\bin&quot;</code>을 영구적으로 적용하려면 사용자 환경 변수(User Environment Variable)에 추가해야 합니다. 다음 방법 중 하나를 사용하세요.</p>
<hr>
<h3 id="1-powershell을-사용하여-환경-변수-등록">1. <strong>PowerShell을 사용하여 환경 변수 등록</strong><a hidden class="anchor" aria-hidden="true" href="#1-powershell을-사용하여-환경-변수-등록">#</a></h3>
<p>PowerShell에서 아래 명령어를 실행하면 **사용자 환경 변수(User Environment Variable)**에 SSHFS-Win 경로가 추가됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$Path = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span><span style="display:flex;"><span>$NewPath = <span style="color:#e6db74">&#34;</span>$Path<span style="color:#e6db74">;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">System.Environment</span>]::SetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, $NewPath, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span></code></pre></div><p>✅ 이 명령어는 시스템을 재부팅하거나, 로그아웃 후 다시 로그인하면 적용됩니다.</p>
<hr>
<h3 id="2-레지스트리를-직접-수정하여-추가">2. <strong>레지스트리를 직접 수정하여 추가</strong><a hidden class="anchor" aria-hidden="true" href="#2-레지스트리를-직접-수정하여-추가">#</a></h3>
<p>다음 명령어를 실행하면 <strong>Windows 레지스트리의 환경 변수</strong>에 SSHFS-Win 경로를 영구적으로 추가합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$CurrentPath = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span><span style="display:flex;"><span>$NewPath = <span style="color:#e6db74">&#34;</span>$CurrentPath<span style="color:#e6db74">;C:\Program Files\SSHFS-Win\bin&#34;</span>
</span></span><span style="display:flex;"><span>Set-ItemProperty -Path <span style="color:#e6db74">&#34;HKCU:\Environment&#34;</span> -Name <span style="color:#e6db74">&#34;Path&#34;</span> -Value $NewPath
</span></span></code></pre></div><p>✅ 이 방법 역시 시스템 재부팅 또는 새 로그인 후 적용됩니다.</p>
<hr>
<h3 id="3-gui그래픽-인터페이스에서-환경-변수-추가">3. <strong>GUI(그래픽 인터페이스)에서 환경 변수 추가</strong><a hidden class="anchor" aria-hidden="true" href="#3-gui그래픽-인터페이스에서-환경-변수-추가">#</a></h3>
<ol>
<li><strong>Win + R</strong> → <code>sysdm.cpl</code> 입력 후 실행</li>
<li><strong>고급(Advanced) 탭</strong> → &ldquo;환경 변수(Environment Variables)&rdquo; 클릭</li>
<li><strong>사용자 환경 변수(User variables)에서 &ldquo;Path&rdquo; 선택 후 &ldquo;편집(Edit)&rdquo;</strong></li>
<li>&ldquo;새로 만들기(New)&ldquo;를 클릭한 후 <code>C:\Program Files\SSHFS-Win\bin</code> 입력</li>
<li>&ldquo;확인(OK)&ldquo;을 눌러 저장 후 시스템을 다시 시작</li>
</ol>
<hr>
<h3 id="4-환경-변수-적용-확인">4. <strong>환경 변수 적용 확인</strong><a hidden class="anchor" aria-hidden="true" href="#4-환경-변수-적용-확인">#</a></h3>
<p>아래 명령어를 실행하여 SSHFS-Win 경로가 제대로 추가되었는지 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>[<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>) -split <span style="color:#e6db74">&#34;;&#34;</span>
</span></span></code></pre></div><p>또는 새로운 PowerShell 창을 열고 다음을 실행:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>where sshfs
</span></span></code></pre></div><p>결과에 <code>C:\Program Files\SSHFS-Win\bin\sshfs.exe</code>가 표시되면 정상적으로 적용된 것입니다. 🚀</p>
<p>이제 PowerShell을 새로 열거나 시스템을 재부팅하면 <code>sshfs</code> 명령어가 항상 인식될 것입니다. 😃</p>
<hr>
<h1 id="불필요한-공백-제거-및-path-변수-업데이트">불필요한 공백 제거 및 Path 변수 업데이트<a hidden class="anchor" aria-hidden="true" href="#불필요한-공백-제거-및-path-변수-업데이트">#</a></h1>
<p>현재 <code>Path</code> 변수에 불필요한 공백(빈 줄)이 포함되어 있습니다. 이를 제거하고 정리하는 방법을 알려드릴게요.</p>
<h3 id="1-불필요한-공백-제거-및-path-변수-업데이트"><strong>1. 불필요한 공백 제거 및 <code>Path</code> 변수 업데이트</strong><a hidden class="anchor" aria-hidden="true" href="#1-불필요한-공백-제거-및-path-변수-업데이트">#</a></h3>
<p>아래 명령어를 실행하면, 기존 <code>Path</code> 변수에서 빈 줄을 제거하고 다시 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$CurrentPath = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>) -split <span style="color:#e6db74">&#34;;&#34;</span> | Where-Object { $_ <span style="color:#f92672">-match</span> <span style="color:#e6db74">&#34;\S&#34;</span> }
</span></span><span style="display:flex;"><span>$NewPath = ($CurrentPath -join <span style="color:#e6db74">&#34;;&#34;</span>)
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">System.Environment</span>]::SetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, $NewPath, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span></code></pre></div><hr>
<h3 id="2-path가-정상적으로-정리되었는지-확인"><strong>2. <code>Path</code>가 정상적으로 정리되었는지 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-path가-정상적으로-정리되었는지-확인">#</a></h3>
<p>수정 후, 아래 명령어를 실행하여 불필요한 공백이 제거되었는지 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>[<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>) -split <span style="color:#e6db74">&#34;;&#34;</span>
</span></span></code></pre></div><p>이제 <code>C:\Program Files\SSHFS-Win\bin</code>이 정상적으로 추가되었으며, 공백 없이 깔끔한 <code>Path</code> 목록이 출력될 것입니다.</p>
<p>💡 <strong>변경 사항이 바로 적용되지 않을 경우</strong>, PowerShell을 다시 실행하거나 로그아웃 후 다시 로그인하면 적용됩니다. 🚀</p>
<hr>
<h1 id="powershell-에서-마운팅된-드라이브를-보여주는-명령어">powershell 에서 마운팅된 드라이브를 보여주는 명령어<a hidden class="anchor" aria-hidden="true" href="#powershell-에서-마운팅된-드라이브를-보여주는-명령어">#</a></h1>
<p>PowerShell에서 현재 <strong>마운트된 네트워크 드라이브</strong> 또는 <strong>로컬 드라이브</strong>를 확인하는 명령어는 다음과 같습니다.</p>
<hr>
<h3 id="1-모든-드라이브-목록-확인-네트워크-드라이브-포함"><strong>1. 모든 드라이브 목록 확인 (네트워크 드라이브 포함)</strong><a hidden class="anchor" aria-hidden="true" href="#1-모든-드라이브-목록-확인-네트워크-드라이브-포함">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>✅ <strong>출력 예시</strong></p>
<pre tabindex="0"><code>Name           Used (GB)     Free (GB) Provider   Root
----           --------     --------- --------   ----
C                 50.23         100.7 FileSystem C:\
D                 80.42         150.1 FileSystem D:\
J                Unknown       Unknown FileSystem J:\
</code></pre><p>📌 여기서 <code>J:\</code>처럼 네트워크 드라이브가 마운트된 경우 확인 가능</p>
<hr>
<h3 id="2-특정-드라이브가-마운트되었는지-확인"><strong>2. 특정 드라이브가 마운트되었는지 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-특정-드라이브가-마운트되었는지-확인">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root <span style="color:#f92672">-eq</span> <span style="color:#e6db74">&#34;J:\&#34;</span> }
</span></span></code></pre></div><p>✅ <code>J:\</code> 드라이브가 마운트되어 있으면 정보가 출력됩니다. 없으면 출력이 없습니다.</p>
<hr>
<h3 id="3-net-use-명령어로-네트워크-드라이브-확인"><strong>3. <code>net use</code> 명령어로 네트워크 드라이브 확인</strong><a hidden class="anchor" aria-hidden="true" href="#3-net-use-명령어로-네트워크-드라이브-확인">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>net use
</span></span></code></pre></div><p>✅ 이 명령어는 Windows 명령어지만 PowerShell에서도 사용 가능하며, 네트워크 드라이브 목록을 보여줍니다.
✅ SSHFS를 통해 마운트한 드라이브도 여기에 표시될 수 있습니다.</p>
<p>📌 <strong>출력 예시</strong></p>
<pre tabindex="0"><code>상태      로컬     원격                          네트워크
-----------------------------------------------------------------
OK        J:       \\aws-sig-ts-jonpark.aws.internal\share   SSHFS
</code></pre><hr>
<h3 id="4-wmi를-사용하여-네트워크-드라이브-목록-확인"><strong>4. WMI를 사용하여 네트워크 드라이브 목록 확인</strong><a hidden class="anchor" aria-hidden="true" href="#4-wmi를-사용하여-네트워크-드라이브-목록-확인">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType <span style="color:#f92672">-eq</span> <span style="color:#ae81ff">4</span> }
</span></span></code></pre></div><p>✅ <code>DriveType = 4</code>는 <strong>네트워크 드라이브</strong>만 필터링하여 보여줍니다.</p>
<p>📌 <strong>출력 예시</strong></p>
<pre tabindex="0"><code>DeviceID     : J:
DriveType    : 4
ProviderName : \\aws-sig-ts-jonpark.aws.internal\share
FreeSpace    : 5000000000
Size         : 10000000000
</code></pre><hr>
<h3 id="어떤-명령어를-사용해야-할까"><strong>어떤 명령어를 사용해야 할까?</strong><a hidden class="anchor" aria-hidden="true" href="#어떤-명령어를-사용해야-할까">#</a></h3>
<ul>
<li><strong>로컬 드라이브 &amp; 네트워크 드라이브 전체 확인</strong> → <code>Get-PSDrive -PSProvider FileSystem</code></li>
<li><strong>특정 드라이브 마운트 여부 확인</strong> → <code>Get-PSDrive | Where-Object { $_.Root -eq &quot;J:\&quot; }</code></li>
<li><strong>네트워크 드라이브만 확인</strong> → <code>net use</code> 또는 <code>Get-WmiObject -Class Win32_LogicalDisk | Where-Object { $_.DriveType -eq 4 }</code></li>
</ul>
<h2 id="이제-원하는-방식으로-마운트된-드라이브를-확인할-수-있을-거예요-">이제 원하는 방식으로 마운트된 드라이브를 확인할 수 있을 거예요! 🚀<a hidden class="anchor" aria-hidden="true" href="#이제-원하는-방식으로-마운트된-드라이브를-확인할-수-있을-거예요-">#</a></h2>
<h1 id="sshfs-로-등록했는데-실제로는-네트워크-드라이브가-보이지-않아">sshfs 로 등록했는데 실제로는 네트워크 드라이브가 보이지 않아<a hidden class="anchor" aria-hidden="true" href="#sshfs-로-등록했는데-실제로는-네트워크-드라이브가-보이지-않아">#</a></h1>
<p>SSHFS를 사용하여 마운트한 드라이브가 <code>net use</code> 또는 <code>Get-WmiObject -Class Win32_LogicalDisk</code>에서 보이지 않는 문제는 <strong>SSHFS로 마운트된 드라이브가 네트워크 드라이브가 아닌 일반 로컬 드라이브로 인식될 가능성</strong> 때문입니다.</p>
<p>이를 해결하려면 <strong>SSHFS가 마운트된 드라이브를 정확하게 감지할 수 있는 PowerShell 명령어</strong>를 사용해야 합니다.</p>
<hr>
<h3 id="-1-sshfs로-마운트된-드라이브-확인-대체-방법"><strong>✅ 1. SSHFS로 마운트된 드라이브 확인 (대체 방법)</strong><a hidden class="anchor" aria-hidden="true" href="#-1-sshfs로-마운트된-드라이브-확인-대체-방법">#</a></h3>
<p>기존 방법 (<code>net use</code>, <code>Get-WmiObject</code>) 대신, <code>fsutil</code> 또는 <code>subst</code>를 활용하여 SSHFS 드라이브를 찾을 수 있습니다.</p>
<h4 id="-1-1-get-psdrive를-사용하여-마운트된-드라이브-확인"><strong>🔹 1-1. <code>Get-PSDrive</code>를 사용하여 마운트된 드라이브 확인</strong><a hidden class="anchor" aria-hidden="true" href="#-1-1-get-psdrive를-사용하여-마운트된-드라이브-확인">#</a></h4>
<p>SSHFS로 마운트된 드라이브는 일반적으로 <code>FileSystem</code> 유형으로 등록됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>✅ 이 명령어를 실행하면 마운트된 모든 드라이브(로컬 및 SSHFS 포함)가 표시됩니다.</p>
<hr>
<h4 id="-1-2-fsutil을-사용하여-드라이브-유형-확인"><strong>🔹 1-2. <code>fsutil</code>을 사용하여 드라이브 유형 확인</strong><a hidden class="anchor" aria-hidden="true" href="#-1-2-fsutil을-사용하여-드라이브-유형-확인">#</a></h4>
<p><code>fsutil fsinfo drives</code>를 사용하면 현재 사용 가능한 모든 드라이브 목록을 확인할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>fsutil fsinfo drives
</span></span></code></pre></div><p>📌 예제 출력:</p>
<pre tabindex="0"><code>Drives: C:\ D:\ E:\ J:\ 
</code></pre><p>여기서 <code>J:\</code>가 SSHFS로 마운트된 드라이브인지 확인하려면:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>fsutil fsinfo volumeinfo J:
</span></span></code></pre></div><p>📌 출력에서 <code>File System Type</code>이 <code>SSHFS</code>로 설정되어 있으면 정상적으로 마운트된 것입니다.</p>
<hr>
<h4 id="-1-3-wmic-logicaldisk로-드라이브-유형-확인"><strong>🔹 1-3. <code>wmic logicaldisk</code>로 드라이브 유형 확인</strong><a hidden class="anchor" aria-hidden="true" href="#-1-3-wmic-logicaldisk로-드라이브-유형-확인">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>wmic logicaldisk get DeviceID, FileSystem, VolumeName
</span></span></code></pre></div><p>📌 예제 출력:</p>
<pre tabindex="0"><code>DeviceID  FileSystem  VolumeName
C:        NTFS       Windows
D:        NTFS       Data
J:        SSHFS      RemoteServer
</code></pre><p>✅ <code>J:</code> 드라이브가 <code>SSHFS</code> 파일 시스템으로 인식되는지 확인하세요.</p>
<hr>
<h3 id="-2-powershell-스크립트로-sshfs-마운트된-드라이브-찾기"><strong>✅ 2. PowerShell 스크립트로 SSHFS 마운트된 드라이브 찾기</strong><a hidden class="anchor" aria-hidden="true" href="#-2-powershell-스크립트로-sshfs-마운트된-드라이브-찾기">#</a></h3>
<p>SSHFS로 마운트된 드라이브만 필터링하려면 다음 스크립트를 실행하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$sshfsDrives = Get-PSDrive -PSProvider FileSystem | Where-Object { $_.Root <span style="color:#f92672">-match</span> <span style="color:#e6db74">&#34;^[A-Z]:\\&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> ($drive <span style="color:#66d9ef">in</span> $sshfsDrives) {
</span></span><span style="display:flex;"><span>    $info = fsutil fsinfo volumeinfo $drive.Root <span style="color:#ae81ff">2</span>&gt;$null
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ($info <span style="color:#f92672">-match</span> <span style="color:#e6db74">&#34;File System Name: SSHFS&#34;</span>) {
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;SSHFS Mounted Drive: </span>$($drive.Root)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>✅ <code>SSHFS Mounted Drive: J:\</code> 형태로 출력되면 정상적으로 마운트된 것입니다.</p>
<hr>
<h3 id="-3-sshfs-드라이브가-정상적으로-마운트되었는지-확인"><strong>✅ 3. SSHFS 드라이브가 정상적으로 마운트되었는지 확인</strong><a hidden class="anchor" aria-hidden="true" href="#-3-sshfs-드라이브가-정상적으로-마운트되었는지-확인">#</a></h3>
<p><strong>마운트 확인 및 문제 해결 체크리스트</strong></p>
<ol>
<li><strong>PowerShell에서 SSHFS 드라이브가 인식되는지 확인</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div></li>
<li><strong>SSHFS 드라이브가 <code>fsutil</code>에서 감지되는지 확인</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>fsutil fsinfo drives
</span></span></code></pre></div></li>
<li><strong>SSHFS 드라이브가 실제 파일 시스템으로 등록되었는지 확인</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>fsutil fsinfo volumeinfo J:
</span></span></code></pre></div></li>
<li><strong>Windows 탐색기에서 드라이브를 강제로 새로고침</strong><br>
<code>F5</code> 키를 누르거나 <strong>Windows 탐색기에서 &lsquo;내 PC&rsquo;를 새로고침</strong>합니다.</li>
</ol>
<hr>
<h3 id="-4-sshfs-드라이브가-windows-네트워크-드라이브로-표시되게-만들기"><strong>✅ 4. SSHFS 드라이브가 Windows 네트워크 드라이브로 표시되게 만들기</strong><a hidden class="anchor" aria-hidden="true" href="#-4-sshfs-드라이브가-windows-네트워크-드라이브로-표시되게-만들기">#</a></h3>
<p>만약 SSHFS로 마운트된 드라이브를 Windows에서 네트워크 드라이브처럼 표시하려면 다음 명령어를 사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>New-PSDrive -Name <span style="color:#e6db74">&#34;J&#34;</span> -PSProvider FileSystem -Root <span style="color:#e6db74">&#34;\\sshfs\jonpark@aws-sig-ts-jonpark.aws.internal\&#34;</span> -Persist
</span></span></code></pre></div><p>📌 이렇게 하면 SSHFS 드라이브가 Windows 네트워크 드라이브로 인식됩니다.</p>
<hr>
<h3 id="-5-해결되지-않는-경우-sshfs-마운트-방식-변경"><strong>✅ 5. 해결되지 않는 경우 SSHFS 마운트 방식 변경</strong><a hidden class="anchor" aria-hidden="true" href="#-5-해결되지-않는-경우-sshfs-마운트-방식-변경">#</a></h3>
<p>SSHFS를 마운트할 때 <code>/network</code> 옵션을 추가하면 네트워크 드라이브로 인식될 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/ <span style="color:#e6db74">&#34;J:&#34;</span> -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks
</span></span></code></pre></div><p>✅ 이렇게 하면 <code>net use</code>에서도 네트워크 드라이브처럼 보일 가능성이 높아집니다.</p>
<hr>
<h3 id="-결론"><strong>🔍 결론</strong><a hidden class="anchor" aria-hidden="true" href="#-결론">#</a></h3>
<ol>
<li><code>Get-PSDrive -PSProvider FileSystem</code>으로 마운트된 드라이브를 먼저 확인하세요.</li>
<li><code>fsutil fsinfo volumeinfo J:</code>로 SSHFS가 인식되는지 확인하세요.</li>
<li><code>New-PSDrive -Persist</code> 옵션을 사용하면 네트워크 드라이브로 표시할 수 있습니다.</li>
<li>SSHFS 마운트 시 <code>/network</code> 옵션을 추가하면 Windows 탐색기에서 네트워크 드라이브로 보일 가능성이 높아집니다.</li>
</ol>
<h2 id="이제-sshfs로-마운트한-드라이브가-정상적으로-표시될-거예요-">이제 SSHFS로 마운트한 드라이브가 정상적으로 표시될 거예요! 🚀<a hidden class="anchor" aria-hidden="true" href="#이제-sshfs로-마운트한-드라이브가-정상적으로-표시될-거예요-">#</a></h2>
<h1 id="sshfs-드라이브가-정상적으로-마운트되지-않는-문제">SSHFS 드라이브가 정상적으로 마운트되지 않는 문제<a hidden class="anchor" aria-hidden="true" href="#sshfs-드라이브가-정상적으로-마운트되지-않는-문제">#</a></h1>
<p>현재 <strong>SSHFS 드라이브가 정상적으로 마운트되지 않는 문제</strong>가 있습니다. SSHFS에서 <code>Successfully mounted drive J:</code>라고 나오지만, 실제로 시스템에서 드라이브를 찾을 수 없는 상태입니다. 이 문제를 해결하고, SSHFS로 마운트된 드라이브를 올바르게 감지할 수 있도록 스크립트를 수정하겠습니다.</p>
<hr>
<h3 id="-원인-분석"><strong>🔍 원인 분석</strong><a hidden class="anchor" aria-hidden="true" href="#-원인-분석">#</a></h3>
<ol>
<li><code>Successfully mounted drive J:</code>라고 나오지만, <code>fsutil</code>이나 <code>Get-PSDrive</code>에서 인식되지 않음.</li>
<li><code>umount-jonpark</code> 실행 시 <code>&quot;The network connection could not be found.&quot;</code> 오류 발생.</li>
<li>SSHFS 실행 중 <code>&quot;Connection reset by peer&quot;</code> 메시지 발생 → 원격 서버 연결이 중단되었을 가능성 있음.</li>
<li><code>fsutil fsinfo volumeinfo J:</code> 실행 시 <code>&quot;The system cannot find the path specified.&quot;</code> → 드라이브가 실제로 마운트되지 않음.</li>
</ol>
<p>이런 문제는 보통 <strong>SSHFS 실행 방식이 Windows와 호환되지 않거나, SSHFS 프로세스가 비정상 종료되었기 때문</strong>입니다.</p>
<hr>
<h3 id="-해결-방법"><strong>✅ 해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#-해결-방법">#</a></h3>
<ol>
<li>
<p><strong>SSHFS 마운트 방식 수정 (<code>subst</code> 사용)</strong></p>
<ul>
<li>SSHFS는 Windows에서 네트워크 드라이브가 아닌 로컬 드라이브처럼 동작할 수 있음.</li>
<li><code>subst</code>를 사용하면 Windows에서도 드라이브를 정상적으로 감지할 수 있음.</li>
</ul>
</li>
<li>
<p><strong>마운트 여부를 정확히 확인하는 스크립트 추가</strong></p>
<ul>
<li><code>fsutil</code>이 아닌 <code>Get-PSDrive</code>를 활용하여 마운트 확인.</li>
<li><code>tasklist</code>로 <code>sshfs.exe</code>가 실행 중인지 확인.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="-수정된-powershell-스크립트"><strong>🔧 수정된 PowerShell 스크립트</strong><a hidden class="anchor" aria-hidden="true" href="#-수정된-powershell-스크립트">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Mount-JonparkDrive {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span>(
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$DriveLetter = <span style="color:#e6db74">&#34;J&#34;</span>,
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$RemotePath = <span style="color:#e6db74">&#34;jonpark@aws-sig-ts-jonpark.aws.internal:/&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSHFS가 설치되어 있는지 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Get-Command sshfs -ErrorAction SilentlyContinue)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Error: sshfs is not installed or not in PATH.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 이미 마운트된 경우 방지</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Drive </span>${DriveLetter}<span style="color:#e6db74">: is already mounted.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSHFS로 마운트 수행</span>
</span></span><span style="display:flex;"><span>        sshfs $RemotePath <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span> -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks
</span></span><span style="display:flex;"><span>        Start-Sleep -Seconds <span style="color:#ae81ff">2</span>  <span style="color:#75715e"># SSHFS가 안정적으로 마운트될 시간을 줌</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 마운트 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Successfully mounted drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Error: Drive </span>${DriveLetter}<span style="color:#e6db74">: was not mounted successfully.&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Error mounting drive: </span>$_<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Dismount-JonparkDrive {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span>(
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$DriveLetter = <span style="color:#e6db74">&#34;J&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 드라이브가 실제로 존재하는지 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Drive </span>${DriveLetter}<span style="color:#e6db74">: is not mounted.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSHFS 드라이브 언마운트</span>
</span></span><span style="display:flex;"><span>        net use <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span> /delete /y <span style="color:#ae81ff">2</span>&gt;$null
</span></span><span style="display:flex;"><span>        Start-Sleep -Seconds <span style="color:#ae81ff">2</span>  <span style="color:#75715e"># 마운트 해제 시간 확보</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 언마운트 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Successfully dismounted drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Error: Failed to unmount drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Error dismounting drive: </span>$_<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Check-MountedDrives {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 현재 마운트된 드라이브 확인</span>
</span></span><span style="display:flex;"><span>    Get-PSDrive -PSProvider FileSystem
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Set-Alias mount-jonpark Mount-JonparkDrive
</span></span><span style="display:flex;"><span>Set-Alias umount-jonpark Dismount-JonparkDrive
</span></span><span style="display:flex;"><span>Set-Alias check-mounts Check-MountedDrives
</span></span></code></pre></div><hr>
<h3 id="-적용-방법"><strong>🚀 적용 방법</strong><a hidden class="anchor" aria-hidden="true" href="#-적용-방법">#</a></h3>
<ol>
<li>
<p><strong>PowerShell에서 스크립트 실행</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Mount-JonparkDrive
</span></span></code></pre></div><p>✅ <code>Successfully mounted drive J:</code>가 나오고, 이후 <code>Test-Path</code> 검사에서 드라이브가 정상적으로 인식되는지 확인.</p>
</li>
<li>
<p><strong>마운트 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>check-mounts
</span></span></code></pre></div><p>✅ <code>J:</code> 드라이브가 정상적으로 표시되는지 확인.</p>
</li>
<li>
<p><strong>언마운트 실행</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>umount-jonpark
</span></span></code></pre></div><p>✅ <code>Successfully dismounted drive J:</code>가 출력되면 정상적으로 해제된 것.</p>
</li>
</ol>
<hr>
<h3 id="-추가-해결책-sshfs-안정성-문제-발생-시"><strong>📌 추가 해결책 (SSHFS 안정성 문제 발생 시)</strong><a hidden class="anchor" aria-hidden="true" href="#-추가-해결책-sshfs-안정성-문제-발생-시">#</a></h3>
<p>만약 여전히 마운트 문제가 있다면, SSHFS-Win을 <code>subst</code> 명령어와 함께 실행하여 드라이브를 강제로 로컬 드라이브처럼 인식시킬 수도 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>subst J: <span style="color:#e6db74">&#34;\\sshfs\jonpark@aws-sig-ts-jonpark.aws.internal\&#34;</span>
</span></span></code></pre></div><p>이 방법을 사용하면 Windows 탐색기에서도 SSHFS 드라이브가 정상적으로 표시될 가능성이 높습니다.</p>
<hr>
<h3 id="-결론-1"><strong>💡 결론</strong><a hidden class="anchor" aria-hidden="true" href="#-결론-1">#</a></h3>
<ol>
<li><strong>기존 방식에서 SSHFS가 정상적으로 마운트되지 않던 문제 해결</strong></li>
<li><strong>마운트 확인을 위한 추가 검사 (<code>Test-Path</code> 활용)</strong></li>
<li><strong>SSHFS 프로세스가 실행 중인지 확인하고, <code>subst</code> 활용 가능성 추가</strong></li>
<li><strong>실제 마운트 확인을 위한 <code>check-mounts</code> 기능 추가</strong></li>
</ol>
<p>이제 SSHFS 드라이브가 정상적으로 표시되고, 필요할 때 마운트 및 해제가 가능할 거예요! 🚀</p>
<hr>
<h1 id="윈도우에서는-아래처럼-ryanpark-계정을-사용하고-마운트-할려고-하는-것은-ec2-ubuntu-instance-이고-이때-jonpark-계정을-사용">윈도우에서는 아래처럼 RyanPark 계정을 사용하고 마운트 할려고 하는 것은 ec2 ubuntu instance 이고 이때 jonpark 계정을 사용<a hidden class="anchor" aria-hidden="true" href="#윈도우에서는-아래처럼-ryanpark-계정을-사용하고-마운트-할려고-하는-것은-ec2-ubuntu-instance-이고-이때-jonpark-계정을-사용">#</a></h1>
<p>현재 Windows에서 <code>RyanPark</code> 계정으로 실행하며, <strong>EC2 Ubuntu 인스턴스의 <code>jonpark</code> 계정</strong>을 사용하여 SSHFS로 마운트하려고 하는 것이군요. 이를 고려하여 <strong>Windows 환경에서 SSHFS 마운트가 정상적으로 작동하도록 수정</strong>하겠습니다.</p>
<hr>
<h3 id="-수정된-powershell-스크립트-1"><strong>🚀 수정된 PowerShell 스크립트</strong><a hidden class="anchor" aria-hidden="true" href="#-수정된-powershell-스크립트-1">#</a></h3>
<ul>
<li>Windows의 <code>RyanPark</code> 계정에서 실행</li>
<li><strong>EC2 Ubuntu 인스턴스의 <code>jonpark</code> 계정으로 SSHFS 마운트</strong></li>
<li><strong>마운트 성공 여부를 확실하게 확인</strong></li>
<li><strong>네트워크 드라이브처럼 보이도록 설정</strong></li>
<li><strong>자동 재연결을 위한 옵션 추가</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Mount-JonparkDrive {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span>(
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$DriveLetter = <span style="color:#e6db74">&#34;J&#34;</span>,
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$RemoteHost = <span style="color:#e6db74">&#34;aws-sig-ts-jonpark.aws.internal&#34;</span>,
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$RemoteUser = <span style="color:#e6db74">&#34;jonpark&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSHFS가 설치되어 있는지 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Get-Command sshfs -ErrorAction SilentlyContinue)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Error: sshfs is not installed or not in PATH.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 이미 마운트된 경우 방지</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Drive </span>${DriveLetter}<span style="color:#e6db74">: is already mounted.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSH 키를 사용하여 비밀번호 입력 없이 마운트 가능하도록 설정</span>
</span></span><span style="display:flex;"><span>        $RemotePath = <span style="color:#e6db74">&#34;</span>$RemoteUser<span style="color:#e6db74">@</span>$RemoteHost<span style="color:#e6db74">:/&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSHFS 마운트 실행</span>
</span></span><span style="display:flex;"><span>        sshfs $RemotePath <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span> -o volname=SSHFS-Drive -o idmap=user -o follow_symlinks -o reconnect
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Start-Sleep -Seconds <span style="color:#ae81ff">2</span>  <span style="color:#75715e"># 마운트 안정화 대기</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 마운트 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Successfully mounted drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Error: Drive </span>${DriveLetter}<span style="color:#e6db74">: was not mounted successfully.&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Error mounting drive: </span>$_<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Dismount-JonparkDrive {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">param</span>(
</span></span><span style="display:flex;"><span>        [<span style="color:#66d9ef">string</span>]$DriveLetter = <span style="color:#e6db74">&#34;J&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 드라이브가 실제로 존재하는지 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Drive </span>${DriveLetter}<span style="color:#e6db74">: is not mounted.&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># SSHFS 드라이브 언마운트</span>
</span></span><span style="display:flex;"><span>        net use <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span> /delete /y <span style="color:#ae81ff">2</span>&gt;$null
</span></span><span style="display:flex;"><span>        Start-Sleep -Seconds <span style="color:#ae81ff">2</span>  <span style="color:#75715e"># 마운트 해제 시간 확보</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 언마운트 확인</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">-not</span> (Test-Path <span style="color:#e6db74">&#34;</span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>)) {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Successfully dismounted drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            Write-Host <span style="color:#e6db74">&#34;Error: Failed to unmount drive </span>${DriveLetter}<span style="color:#e6db74">:&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span> {
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Error dismounting drive: </span>$_<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> Check-MountedDrives {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 현재 마운트된 드라이브 확인</span>
</span></span><span style="display:flex;"><span>    Get-PSDrive -PSProvider FileSystem
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Set-Alias mount-jonpark Mount-JonparkDrive
</span></span><span style="display:flex;"><span>Set-Alias umount-jonpark Dismount-JonparkDrive
</span></span><span style="display:flex;"><span>Set-Alias check-mounts Check-MountedDrives
</span></span></code></pre></div><hr>
<h3 id="-주요-개선-사항"><strong>🔹 주요 개선 사항</strong><a hidden class="anchor" aria-hidden="true" href="#-주요-개선-사항">#</a></h3>
<ol>
<li><strong>Windows에서 <code>RyanPark</code> 계정이 실행하지만, EC2 Ubuntu에서는 <code>jonpark</code> 계정을 사용</strong></li>
<li><strong>SSHFS가 정상적으로 마운트되는지 <code>Test-Path</code>로 확인</strong></li>
<li><strong>SSH 키를 사용하여 비밀번호 입력 없이 마운트하도록 개선</strong></li>
<li><strong><code>-o reconnect</code> 옵션 추가 → SSH 연결이 끊어져도 자동 복구</strong></li>
<li><strong><code>check-mounts</code> 명령어로 현재 마운트된 드라이브 확인 가능</strong></li>
</ol>
<hr>
<h3 id="-사용-방법"><strong>🚀 사용 방법</strong><a hidden class="anchor" aria-hidden="true" href="#-사용-방법">#</a></h3>
<h4 id="1-마운트-실행"><strong>1️⃣ 마운트 실행</strong><a hidden class="anchor" aria-hidden="true" href="#1-마운트-실행">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>mount-jonpark
</span></span></code></pre></div><p>✅ <code>Successfully mounted drive J:</code>가 나오면 성공</p>
<h4 id="2-마운트-확인"><strong>2️⃣ 마운트 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-마운트-확인">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>check-mounts
</span></span></code></pre></div><p>✅ <code>J:</code> 드라이브가 정상적으로 표시되는지 확인</p>
<h4 id="3-언마운트-실행"><strong>3️⃣ 언마운트 실행</strong><a hidden class="anchor" aria-hidden="true" href="#3-언마운트-실행">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>umount-jonpark
</span></span></code></pre></div><p>✅ <code>Successfully dismounted drive J:</code>가 출력되면 정상적으로 해제됨.</p>
<hr>
<h3 id="-추가-해결책-ssh-키로-인증"><strong>🔍 추가 해결책 (SSH 키로 인증)</strong><a hidden class="anchor" aria-hidden="true" href="#-추가-해결책-ssh-키로-인증">#</a></h3>
<p>현재 SSHFS 마운트 시 <strong>비밀번호 입력을 요구</strong>하는데, 이를 <strong>SSH 키로 자동 인증</strong>하도록 설정하면 편리합니다.</p>
<ol>
<li><strong>Windows에서 SSH 키 생성</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>ssh-keygen -t rsa -b <span style="color:#ae81ff">4096</span> <span style="color:#f92672">-f</span> C:\Users\RyanPark\.ssh\id_rsa
</span></span></code></pre></div></li>
<li><strong>EC2 Ubuntu 서버에 공개 키 추가</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</span></span><span style="display:flex;"><span>chmod <span style="color:#ae81ff">600</span> ~/.ssh/authorized_keys
</span></span></code></pre></div></li>
<li><strong>SSHFS 마운트 시 SSH 키를 사용하도록 수정</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/ J: -o IdentityFile=C:\Users\RyanPark\.ssh\id_rsa -o reconnect
</span></span></code></pre></div></li>
</ol>
<p>✅ 이렇게 하면 비밀번호 없이 자동 마운트 가능</p>
<hr>
<p>이제 <strong>RyanPark 계정에서 실행하면서 EC2 Ubuntu 인스턴스의 <code>jonpark</code> 계정으로 SSHFS를 사용</strong>할 수 있습니다! 🚀</p>
<hr>
<h1 id="update-env-함수가-기대한-대로-동작하지-않는-이유">update-env 함수가 기대한 대로 동작하지 않는 이유<a hidden class="anchor" aria-hidden="true" href="#update-env-함수가-기대한-대로-동작하지-않는-이유">#</a></h1>
<p>현재 <code>update-env</code> 함수가 기대한 대로 동작하지 않는 이유는 <strong>PowerShell 세션 내에서만 환경 변수를 변경</strong>하기 때문입니다. 이 문제를 해결하기 위해 다음과 같은 방식으로 수정하겠습니다.</p>
<hr>
<h3 id="-문제점"><strong>🔹 문제점</strong><a hidden class="anchor" aria-hidden="true" href="#-문제점">#</a></h3>
<ul>
<li><code>$env:Path</code> 값을 변경하는 것만으로는 새로 추가된 환경 변수를 즉시 반영하지 않음.</li>
<li>PowerShell 세션을 다시 열어야 변경 사항이 적용됨.</li>
<li>VS Code의 PowerShell 터미널에서는 환경 변수 업데이트가 원활하지 않을 수 있음.</li>
</ul>
<hr>
<h3 id="-수정된-update-env-함수"><strong>✅ 수정된 <code>update-env</code> 함수</strong><a hidden class="anchor" aria-hidden="true" href="#-수정된-update-env-함수">#</a></h3>
<p>아래 코드에서는 <strong>레지스트리에서 최신 환경 변수를 가져와 즉시 PowerShell 세션에 반영</strong>하도록 개선했습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> update-env {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 사용자 및 시스템 환경 변수 가져오기</span>
</span></span><span style="display:flex;"><span>    $UserPath = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span><span style="display:flex;"><span>    $MachinePath = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;Machine&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 현재 세션의 Path 환경 변수 업데이트</span>
</span></span><span style="display:flex;"><span>    $env:Path = <span style="color:#e6db74">&#34;</span>$MachinePath<span style="color:#e6db74">;</span>$UserPath<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 새 환경 변수 즉시 반영</span>
</span></span><span style="display:flex;"><span>    &amp; refreshenv
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Write-Host <span style="color:#e6db74">&#34;Environment variables updated successfully.&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="-개선된-기능"><strong>🚀 개선된 기능</strong><a hidden class="anchor" aria-hidden="true" href="#-개선된-기능">#</a></h3>
<ol>
<li><strong><code>$env:Path</code>를 시스템(<code>Machine</code>) 및 사용자(<code>User</code>) 환경 변수로 즉시 업데이트</strong></li>
<li><strong><code>refreshenv</code> 실행으로 환경 변수 즉시 반영</strong>
<ul>
<li><code>refreshenv</code>는 Chocolatey가 제공하는 명령어지만, 일반적으로 동작 가능.</li>
<li>만약 Chocolatey가 없다면 아래 방법을 사용.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="-refreshenv-없이-환경-변수-강제-업데이트-방법"><strong>🔹 <code>refreshenv</code> 없이 환경 변수 강제 업데이트 방법</strong><a hidden class="anchor" aria-hidden="true" href="#-refreshenv-없이-환경-변수-강제-업데이트-방법">#</a></h3>
<p>만약 Chocolatey가 설치되지 않았다면 <code>refreshenv</code> 대신 <strong>레지스트리에서 직접 업데이트</strong>하는 방법을 사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> update-env {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 사용자 및 시스템 환경 변수 가져오기</span>
</span></span><span style="display:flex;"><span>    $UserPath = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span><span style="display:flex;"><span>    $MachinePath = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;Machine&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 현재 세션의 Path 환경 변수 업데이트</span>
</span></span><span style="display:flex;"><span>    $env:Path = <span style="color:#e6db74">&#34;</span>$MachinePath<span style="color:#e6db74">;</span>$UserPath<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Windows 탐색기(Explorer) 프로세스를 재시작하여 환경 변수 즉시 반영</span>
</span></span><span style="display:flex;"><span>    Stop-Process -Name explorer -Force -ErrorAction SilentlyContinue
</span></span><span style="display:flex;"><span>    Start-Process explorer.exe
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Write-Host <span style="color:#e6db74">&#34;Environment variables updated successfully. If changes are not reflected, try restarting PowerShell.&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>✅ <strong>이제 <code>update-env</code>를 실행하면 변경된 환경 변수가 즉시 반영됩니다!</strong> 🚀</p>
<hr>
<h1 id="profile-을-수정했는데-현재-동작중인-powershell-에서-바로-적용시키는-방법">profile 을 수정했는데 현재 동작중인 powershell 에서 바로 적용시키는 방법<a hidden class="anchor" aria-hidden="true" href="#profile-을-수정했는데-현재-동작중인-powershell-에서-바로-적용시키는-방법">#</a></h1>
<p>PowerShell 프로파일을 수정한 후, <strong>현재 실행 중인 PowerShell 세션에서 즉시 적용하는 방법</strong>은 다음과 같습니다.</p>
<hr>
<h3 id="-1-프로파일-파일-즉시-로드하기"><strong>✅ 1. 프로파일 파일 즉시 로드하기</strong><a hidden class="anchor" aria-hidden="true" href="#-1-프로파일-파일-즉시-로드하기">#</a></h3>
<p>PowerShell 프로파일을 수정한 후, 아래 명령어를 실행하면 현재 세션에서 바로 적용됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>. $PROFILE
</span></span></code></pre></div><p>✅ <strong>설명</strong></p>
<ul>
<li><code>$PROFILE</code> 변수는 현재 사용자의 PowerShell 프로파일 파일 경로를 가리킵니다.</li>
<li><code>.</code> (dot-source) 연산자를 사용하면 해당 파일을 현재 세션에 즉시 적용할 수 있습니다.</li>
</ul>
<p>📌 <strong>예제</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>notepad $PROFILE  <span style="color:#75715e"># 프로파일 파일을 편집</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 수정 후 저장한 다음, 아래 명령어 실행</span>
</span></span><span style="display:flex;"><span>. $PROFILE        <span style="color:#75715e"># 변경 사항을 즉시 반영</span>
</span></span></code></pre></div><hr>
<h3 id="-2-모든-프로파일-파일-로드-관리자일반-사용자-구분"><strong>✅ 2. 모든 프로파일 파일 로드 (관리자/일반 사용자 구분)</strong><a hidden class="anchor" aria-hidden="true" href="#-2-모든-프로파일-파일-로드-관리자일반-사용자-구분">#</a></h3>
<p>PowerShell에는 여러 개의 프로파일 파일이 있을 수 있습니다. 모든 프로파일 파일을 즉시 로드하려면:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$profiles = @(
</span></span><span style="display:flex;"><span>    $PROFILE,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;</span>$($PROFILE.AllUsersAllHosts)<span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;</span>$($PROFILE.AllUsersCurrentHost)<span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;</span>$($PROFILE.CurrentUserAllHosts)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> ($p <span style="color:#66d9ef">in</span> $profiles) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Test-Path $p) {
</span></span><span style="display:flex;"><span>        . $p
</span></span><span style="display:flex;"><span>        Write-Host <span style="color:#e6db74">&#34;Loaded: </span>$p<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>✅ <strong>이 코드가 필요한 경우</strong></p>
<ul>
<li>시스템 전체(<code>AllUsers</code>) 또는 특정 사용자(<code>CurrentUser</code>) 설정을 즉시 반영하려는 경우.</li>
<li>여러 PowerShell 호스트(VS Code, Windows Terminal 등)에서 동작하는 프로파일을 적용하려는 경우.</li>
</ul>
<hr>
<h3 id="-3-powershell-환경-변수-강제-업데이트-update-env-개선"><strong>✅ 3. PowerShell 환경 변수 강제 업데이트 (<code>update-env</code> 개선)</strong><a hidden class="anchor" aria-hidden="true" href="#-3-powershell-환경-변수-강제-업데이트-update-env-개선">#</a></h3>
<p>만약 프로파일에서 <strong>환경 변수(Path 등)가 변경되었다면</strong>, 아래 명령어를 추가 실행해야 합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$env:Path = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;Machine&#34;</span>) + <span style="color:#e6db74">&#34;;&#34;</span> + [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span></code></pre></div><hr>
<h3 id="-4-새로운-powershell-세션을-자동으로-다시-시작"><strong>✅ 4. 새로운 PowerShell 세션을 자동으로 다시 시작</strong><a hidden class="anchor" aria-hidden="true" href="#-4-새로운-powershell-세션을-자동으로-다시-시작">#</a></h3>
<p>만약 <strong>프로파일 변경 후 PowerShell을 새로 시작해야 하는 경우</strong>, 아래 명령어를 실행하면 현재 세션을 종료하고 새 창을 띄울 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Start-Process pwsh -Verb RunAs; exit  <span style="color:#75715e"># PowerShell 7+</span>
</span></span><span style="display:flex;"><span>Start-Process powershell -Verb RunAs; exit  <span style="color:#75715e"># Windows PowerShell (5.x)</span>
</span></span></code></pre></div><hr>
<h3 id="-결론-2"><strong>🚀 결론</strong><a hidden class="anchor" aria-hidden="true" href="#-결론-2">#</a></h3>
<ul>
<li><strong>프로파일 즉시 적용:</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>. $PROFILE
</span></span></code></pre></div></li>
<li><strong>모든 프로파일 즉시 적용:</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#66d9ef">foreach</span> ($p <span style="color:#66d9ef">in</span> $profiles) { <span style="color:#66d9ef">if</span> (Test-Path $p) { . $p; Write-Host <span style="color:#e6db74">&#34;Loaded: </span>$p<span style="color:#e6db74">&#34;</span> } }
</span></span></code></pre></div></li>
<li><strong>환경 변수 즉시 반영:</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$env:Path = [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;Machine&#34;</span>) + <span style="color:#e6db74">&#34;;&#34;</span> + [<span style="color:#66d9ef">System.Environment</span>]::GetEnvironmentVariable(<span style="color:#e6db74">&#34;Path&#34;</span>, <span style="color:#e6db74">&#34;User&#34;</span>)
</span></span></code></pre></div></li>
<li><strong>PowerShell 새로 시작 (필요한 경우)</strong>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Start-Process powershell -Verb RunAs; exit
</span></span></code></pre></div></li>
</ul>
<p>✅ <strong>이제 프로파일을 수정한 후 위 명령어를 실행하면 PowerShell을 다시 시작하지 않고도 변경 사항이 즉시 반영됩니다!</strong> 🚀</p>
<hr>
<h1 id="profileps1의-역할">profile.ps1의 역할<a hidden class="anchor" aria-hidden="true" href="#profileps1의-역할">#</a></h1>
<p><code>C:\Users\RyanPark\OneDrive - Black Duck Software\Documents\WindowsPowerShell\profile.ps1</code> 경로는 <strong>PowerShell 프로파일 파일</strong>에 해당합니다.</p>
<hr>
<h3 id="-profileps1의-역할"><strong>✅ <code>profile.ps1</code>의 역할</strong><a hidden class="anchor" aria-hidden="true" href="#-profileps1의-역할">#</a></h3>
<p>PowerShell 프로파일은 PowerShell이 시작될 때 자동으로 실행되는 스크립트 파일로, <strong>사용자 맞춤 설정</strong>을 저장하는 역할을 합니다.</p>
<h4 id="1-해당-프로파일이-적용되는-범위"><strong>1️⃣ 해당 프로파일이 적용되는 범위</strong><a hidden class="anchor" aria-hidden="true" href="#1-해당-프로파일이-적용되는-범위">#</a></h4>
<ul>
<li>경로에 <code>WindowsPowerShell</code>이 포함되어 있으므로, <strong>Windows PowerShell 5.x</strong>(기본 PowerShell)에서 실행됩니다.</li>
<li><strong>PowerShell 7+ (<code>pwsh</code>)에서는 적용되지 않습니다.</strong></li>
<li><strong>사용자별 프로파일</strong>로, <code>RyanPark</code> 계정에서만 동작합니다.</li>
<li>만약 PowerShell이 <code>OneDrive</code> 동기화 설정을 따르고 있다면, OneDrive가 완전히 로드된 후에만 정상적으로 실행될 수도 있습니다.</li>
</ul>
<h4 id="2-프로파일-즉시-적용-방법"><strong>2️⃣ 프로파일 즉시 적용 방법</strong><a hidden class="anchor" aria-hidden="true" href="#2-프로파일-즉시-적용-방법">#</a></h4>
<p>프로파일을 수정한 후, 아래 명령어를 실행하면 <strong>PowerShell을 재시작하지 않고도 변경 사항이 즉시 반영됩니다.</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>. $PROFILE
</span></span></code></pre></div><p>✅ 이 명령어는 <code>$PROFILE</code> 변수를 사용하여 현재 프로파일 파일을 다시 로드합니다.</p>
<p>📌 <strong>직접 파일 경로를 지정하여 로드하는 방법 (동일 효과)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>. <span style="color:#e6db74">&#34;C:\Users\RyanPark\OneDrive - Black Duck Software\Documents\WindowsPowerShell\profile.ps1&#34;</span>
</span></span></code></pre></div><hr>
<h3 id="-프로파일의-종류-powershell-버전-및-범위별"><strong>✅ 프로파일의 종류 (PowerShell 버전 및 범위별)</strong><a hidden class="anchor" aria-hidden="true" href="#-프로파일의-종류-powershell-버전-및-범위별">#</a></h3>
<p>PowerShell 프로파일은 4가지 유형이 있으며, 현재 사용 중인 것은 <strong>사용자별 PowerShell 5.x 프로파일</strong>입니다.</p>
<table>
  <thead>
      <tr>
          <th>프로파일 경로</th>
          <th>적용 대상</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><code>$PROFILE</code></strong></td>
          <td>현재 사용자</td>
          <td>사용자가 실행한 PowerShell에만 적용</td>
      </tr>
      <tr>
          <td><strong><code>$PROFILE.CurrentUserAllHosts</code></strong></td>
          <td>현재 사용자</td>
          <td>모든 PowerShell 호스트(VS Code, ISE 등)에 적용</td>
      </tr>
      <tr>
          <td><strong><code>$PROFILE.AllUsersCurrentHost</code></strong></td>
          <td>모든 사용자</td>
          <td>현재 PowerShell 호스트에서 모든 사용자에게 적용</td>
      </tr>
      <tr>
          <td><strong><code>$PROFILE.AllUsersAllHosts</code></strong></td>
          <td>모든 사용자</td>
          <td>시스템 전체에서 모든 PowerShell 실행 시 적용</td>
      </tr>
  </tbody>
</table>
<p>📌 <strong>현재 적용된 프로파일 경로 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$PROFILE
</span></span></code></pre></div><p>📌 <strong>모든 프로파일 경로 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$PROFILE | Format-List *
</span></span></code></pre></div><hr>
<h3 id="-powershell-7에서-동일한-프로파일을-적용하려면"><strong>✅ PowerShell 7+에서 동일한 프로파일을 적용하려면?</strong><a hidden class="anchor" aria-hidden="true" href="#-powershell-7에서-동일한-프로파일을-적용하려면">#</a></h3>
<p>PowerShell 7 (<code>pwsh</code>)에서는 프로파일 경로가 다릅니다.<br>
만약 PowerShell 7에서 동일한 설정을 사용하려면, 아래 경로의 <code>profile.ps1</code>에도 같은 내용을 추가해야 합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>C:\Users\RyanPark\Documents\PowerShell\profile.ps1
</span></span></code></pre></div><p>✅ PowerShell 7 프로파일을 즉시 로드하려면:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>. <span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">\Documents\PowerShell\profile.ps1&#34;</span>
</span></span></code></pre></div><hr>
<h3 id="-결론-3"><strong>🚀 결론</strong><a hidden class="anchor" aria-hidden="true" href="#-결론-3">#</a></h3>
<ol>
<li>
<p><strong>현재 <code>profile.ps1</code> 파일은 Windows PowerShell(5.x)에 적용됨</strong><br>
✅ 즉시 적용하려면:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>. $PROFILE
</span></span></code></pre></div></li>
<li>
<p><strong>PowerShell 7+(<code>pwsh</code>)에서는 다른 프로파일 경로를 사용함</strong><br>
✅ PowerShell 7에서 동일한 설정을 사용하려면, <code>C:\Users\RyanPark\Documents\PowerShell\profile.ps1</code>을 수정해야 함.</p>
</li>
<li>
<p><strong>VS Code, Windows Terminal 등에서 동일한 프로파일을 적용하려면</strong><br>
✅ <code>AllHosts</code> 프로파일 (<code>$PROFILE.CurrentUserAllHosts</code>)을 수정하는 것이 더 유용할 수 있음.</p>
</li>
</ol>
<p>이제 프로파일이 정상적으로 반영될 것입니다! 🚀</p>
<hr>
<h1 id="profile-종류">PROFILE 종류<a hidden class="anchor" aria-hidden="true" href="#profile-종류">#</a></h1>
<p>PowerShell에는 여러 개의 <code>profile.ps1</code> 파일이 존재할 수 있으며, 각각 적용되는 범위가 다릅니다.</p>
<p>아래 명령어를 실행하면 현재 시스템에서 사용 가능한 모든 PowerShell 프로파일 경로를 확인할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>$PROFILE | Format-List *
</span></span></code></pre></div><p>✅ <strong>출력 예시 (PowerShell 5.x)</strong></p>
<pre tabindex="0"><code>AllUsersAllHosts       : C:\Windows\System32\WindowsPowerShell\v1.0\profile.ps1
AllUsersCurrentHost    : C:\Windows\System32\WindowsPowerShell\v1.0\Microsoft.PowerShell_profile.ps1
CurrentUserAllHosts    : C:\Users\RyanPark\Documents\WindowsPowerShell\profile.ps1
CurrentUserCurrentHost : C:\Users\RyanPark\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1
</code></pre><p>✅ <strong>출력 예시 (PowerShell 7+)</strong></p>
<pre tabindex="0"><code>AllUsersAllHosts       : C:\Program Files\PowerShell\7\profile.ps1
AllUsersCurrentHost    : C:\Program Files\PowerShell\7\Microsoft.PowerShell_profile.ps1
CurrentUserAllHosts    : C:\Users\RyanPark\Documents\PowerShell\profile.ps1
CurrentUserCurrentHost : C:\Users\RyanPark\Documents\PowerShell\Microsoft.PowerShell_profile.ps1
</code></pre><hr>
<h3 id="-프로파일-설명"><strong>🔹 프로파일 설명</strong><a hidden class="anchor" aria-hidden="true" href="#-프로파일-설명">#</a></h3>
<table>
  <thead>
      <tr>
          <th>프로파일 경로</th>
          <th>적용 대상</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong><code>$PROFILE.AllUsersAllHosts</code></strong></td>
          <td>모든 사용자</td>
          <td>모든 PowerShell 실행 시 적용</td>
      </tr>
      <tr>
          <td><strong><code>$PROFILE.AllUsersCurrentHost</code></strong></td>
          <td>모든 사용자</td>
          <td>특정 PowerShell 호스트 (예: VS Code, Windows Terminal 등)에만 적용</td>
      </tr>
      <tr>
          <td><strong><code>$PROFILE.CurrentUserAllHosts</code></strong></td>
          <td>현재 사용자</td>
          <td>모든 PowerShell 실행 시 적용</td>
      </tr>
      <tr>
          <td><strong><code>$PROFILE.CurrentUserCurrentHost</code></strong></td>
          <td>현재 사용자</td>
          <td>특정 PowerShell 호스트에서만 적용</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="-프로파일을-확인하는-명령어"><strong>🔍 프로파일을 확인하는 명령어</strong><a hidden class="anchor" aria-hidden="true" href="#-프로파일을-확인하는-명령어">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#75715e"># 현재 사용자에게 적용되는 프로파일 확인</span>
</span></span><span style="display:flex;"><span>Write-Host <span style="color:#e6db74">&#34;Current User - All Hosts: </span>$($PROFILE.CurrentUserAllHosts)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>Write-Host <span style="color:#e6db74">&#34;Current User - Current Host: </span>$($PROFILE.CurrentUserCurrentHost)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 모든 사용자에게 적용되는 프로파일 확인</span>
</span></span><span style="display:flex;"><span>Write-Host <span style="color:#e6db74">&#34;All Users - All Hosts: </span>$($PROFILE.AllUsersAllHosts)<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>Write-Host <span style="color:#e6db74">&#34;All Users - Current Host: </span>$($PROFILE.AllUsersCurrentHost)<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>✅ 위 명령어를 실행하면 현재 사용 가능한 모든 프로파일 파일 경로가 출력됩니다.</p>
<hr>
<h3 id="-결론-4"><strong>🚀 결론</strong><a hidden class="anchor" aria-hidden="true" href="#-결론-4">#</a></h3>
<ul>
<li>
<p><strong>PowerShell 5.x에서는</strong><br>
<code>C:\Users\RyanPark\Documents\WindowsPowerShell\profile.ps1</code><br>
→ 모든 PowerShell 실행 시 적용됨.</p>
</li>
<li>
<p><strong>PowerShell 7+에서는</strong><br>
<code>C:\Users\RyanPark\Documents\PowerShell\profile.ps1</code><br>
→ 모든 PowerShell 실행 시 적용됨.</p>
</li>
<li>
<p><strong>VS Code, Windows Terminal 등 특정 호스트에서만 적용하려면</strong><br>
<code>Microsoft.PowerShell_profile.ps1</code>을 수정해야 함.</p>
</li>
</ul>
<p>이제 <strong>어떤 프로파일을 수정해야 할지</strong> 명확하게 알 수 있을 거예요! 🚀</p>
<hr>
<h1 id="sshfs--connection-reset-by-peer">sshfs : Connection reset by peer<a hidden class="anchor" aria-hidden="true" href="#sshfs--connection-reset-by-peer">#</a></h1>
<p>현재 <code>mount-jonpark</code> 실행 시 <strong>&ldquo;Connection reset by peer&rdquo;</strong> 오류가 발생하고 있으며, 드라이브가 정상적으로 마운트되지 않는 문제가 있습니다. 이 문제를 디버깅하는 방법을 단계별로 정리해드리겠습니다.</p>
<hr>
<h2 id="1-ssh-연결-확인"><strong>1️⃣ SSH 연결 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-ssh-연결-확인">#</a></h2>
<p>먼저 SSHFS를 사용하려면 <strong>기본적으로 SSH 연결이 가능해야 합니다.</strong><br>
PowerShell에서 <strong>SSH 연결이 정상적으로 작동하는지</strong> 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>ssh jonpark@aws-sig-ts-jonpark.aws.internal
</span></span></code></pre></div><p>✅ <strong>정상적인 경우</strong></p>
<ul>
<li>비밀번호 입력 후 SSH 로그인 성공.</li>
</ul>
<p>🚨 <strong>오류 발생 시</strong></p>
<ul>
<li><code>&quot;Connection reset by peer&quot;</code> → 원격 서버 문제(SSH 서비스 중단, 방화벽 차단 등)</li>
<li><code>&quot;Permission denied&quot;</code> → 키 인증 문제 또는 계정 권한 부족</li>
</ul>
<p>📌 <strong>SSH 연결이 안 될 경우 해결 방법</strong></p>
<ul>
<li>원격 서버에서 SSH 서비스 실행 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo systemctl status ssh
</span></span></code></pre></div></li>
<li>SSH 포트가 열려 있는지 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo netstat -tulnp | grep ssh
</span></span></code></pre></div></li>
<li>방화벽(EC2 보안 그룹 포함) 설정 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo ufw status
</span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="2-sshfs가-정상적으로-동작하는지-확인"><strong>2️⃣ SSHFS가 정상적으로 동작하는지 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-sshfs가-정상적으로-동작하는지-확인">#</a></h2>
<p>SSHFS 명령어를 수동으로 실행하여 <strong>PowerShell 스크립트 없이 수동 마운트가 가능한지 확인</strong>합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/ J: -o debug
</span></span></code></pre></div><p>✅ <strong>정상적인 경우</strong></p>
<ul>
<li>드라이브가 <code>J:</code>로 마운트됨.</li>
</ul>
<p>🚨 <strong>에러 발생 시</strong></p>
<ul>
<li><code>&quot;Connection reset by peer&quot;</code> → 원격 서버 문제 가능성.</li>
<li><code>&quot;Read-only file system&quot;</code> → 파일 시스템 문제.</li>
<li><code>&quot;Transport endpoint is not connected&quot;</code> → SSHFS 프로세스 충돌 가능성.</li>
</ul>
<p>📌 <strong>디버깅 옵션 추가 실행</strong>
만약 위 명령어가 정상 작동하지 않는다면, 더 많은 디버깅 정보를 얻기 위해 아래와 같이 실행하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/ J: -o sshfs_debug -o loglevel=debug
</span></span></code></pre></div><p>🚨 <strong>디버깅 로그에서 확인해야 할 부분</strong></p>
<ul>
<li><code>&quot;Connection reset by peer&quot;</code> → 서버 문제 가능성이 큼.</li>
<li><code>&quot;Bad owner or permissions&quot;</code> → 원격 서버의 파일 권한 문제.</li>
</ul>
<hr>
<h2 id="3-sshfs-로그-확인"><strong>3️⃣ SSHFS 로그 확인</strong><a hidden class="anchor" aria-hidden="true" href="#3-sshfs-로그-확인">#</a></h2>
<p>만약 <code>sshfs</code> 명령어가 실행되었는데도 실패한다면, SSHFS가 남긴 로그를 확인해야 합니다.</p>
<p>🔹 <strong>Windows에서 SSHFS 로그 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-Content C:\Windows\Temp\sshfs.log -Tail <span style="color:#ae81ff">50</span>
</span></span></code></pre></div><p>🔹 <strong>Linux(EC2)에서 SSH 로그 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo journalctl -u ssh -n <span style="color:#ae81ff">50</span>
</span></span></code></pre></div><p>🚨 <strong>주요 에러 예시</strong></p>
<ul>
<li><code>&quot;Connection reset by peer&quot;</code> → 네트워크 문제 가능성.</li>
<li><code>&quot;Permission denied&quot;</code> → SSH 키 인증 또는 계정 문제.</li>
</ul>
<hr>
<h2 id="4-마운트-상태-확인"><strong>4️⃣ 마운트 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#4-마운트-상태-확인">#</a></h2>
<p>PowerShell에서 <code>J:</code> 드라이브가 인식되는지 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>또는 <strong>Windows 네트워크 드라이브 목록 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>net use
</span></span></code></pre></div><p>🚨 <strong>드라이브가 보이지 않는다면?</strong></p>
<ul>
<li>SSHFS가 정상적으로 실행되지 않았을 가능성이 큼.</li>
<li>기존 SSHFS 마운트가 충돌하고 있을 수도 있음.</li>
</ul>
<p>✅ <strong>모든 SSHFS 마운트 해제 후 다시 시도</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>net use J: /delete /y
</span></span></code></pre></div><hr>
<h2 id="5-powershell-스크립트-디버깅-모드-실행"><strong>5️⃣ PowerShell 스크립트 디버깅 모드 실행</strong><a hidden class="anchor" aria-hidden="true" href="#5-powershell-스크립트-디버깅-모드-실행">#</a></h2>
<p>PowerShell에서 <strong>디버깅 모드를 활성화</strong>하면 스크립트 실행 중 어디에서 오류가 발생하는지 더 자세한 정보를 얻을 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Set-PSDebug -Trace <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>mount-jonpark
</span></span><span style="display:flex;"><span>Set-PSDebug -Trace <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>✅ <strong>출력에서 <code>sshfs</code> 명령어 실행 위치를 확인</strong>하고, 해당 명령어를 수동으로 실행해봅니다.</p>
<hr>
<h2 id="-결론-순서대로-디버깅"><strong>🚀 결론 (순서대로 디버깅)</strong><a hidden class="anchor" aria-hidden="true" href="#-결론-순서대로-디버깅">#</a></h2>
<ol>
<li>
<p><strong>SSH 연결 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>ssh jonpark@aws-sig-ts-jonpark.aws.internal
</span></span></code></pre></div><ul>
<li>안 되면 원격 서버에서 SSH 서비스, 방화벽, 보안 그룹 확인.</li>
</ul>
</li>
<li>
<p><strong>SSHFS 수동 마운트 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/ J: -o debug
</span></span></code></pre></div><ul>
<li>실패하면 <code>-o sshfs_debug -o loglevel=debug</code> 옵션 추가.</li>
</ul>
</li>
<li>
<p><strong>SSHFS 로그 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-Content C:\Windows\Temp\sshfs.log -Tail <span style="color:#ae81ff">50</span>
</span></span></code></pre></div></li>
<li>
<p><strong>PowerShell 디버깅 활성화 후 실행</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Set-PSDebug -Trace <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>mount-jonpark
</span></span><span style="display:flex;"><span>Set-PSDebug -Trace <span style="color:#ae81ff">0</span>
</span></span></code></pre></div></li>
</ol>
<h2 id="이제-위-단계를-차례대로-실행하면-문제의-원인을-정확하게-파악할-수-있습니다-">이제 위 단계를 차례대로 실행하면 <strong>문제의 원인을 정확하게 파악할 수 있습니다.</strong> 🚀<a hidden class="anchor" aria-hidden="true" href="#이제-위-단계를-차례대로-실행하면-문제의-원인을-정확하게-파악할-수-있습니다-">#</a></h2>
<h1 id="remote-directory가-homejonpark이-아닐-가능성">Remote Directory가 /home/jonpark이 아닐 가능성<a hidden class="anchor" aria-hidden="true" href="#remote-directory가-homejonpark이-아닐-가능성">#</a></h1>
<h3 id="-문제-원인-remote-directory가-homejonpark이-아닐-가능성"><strong>🔍 문제 원인: Remote Directory가 <code>/home/jonpark</code>이 아닐 가능성</strong><a hidden class="anchor" aria-hidden="true" href="#-문제-원인-remote-directory가-homejonpark이-아닐-가능성">#</a></h3>
<p>SSH 접속은 정상적으로 이루어지지만, SSHFS 마운트 시 <code>bad mount point J: No such file or directory</code> 오류가 발생하고 있습니다.<br>
이 오류는 보통 <strong>원격 디렉터리가 존재하지 않거나, 접근 권한이 없을 때 발생</strong>합니다.</p>
<hr>
<h3 id="-해결-방법-1-원격-서버에서-기본-홈-디렉터리-확인"><strong>✅ 해결 방법 1: 원격 서버에서 기본 홈 디렉터리 확인</strong><a hidden class="anchor" aria-hidden="true" href="#-해결-방법-1-원격-서버에서-기본-홈-디렉터리-확인">#</a></h3>
<p>현재 SSHFS 명령어를 실행할 때 기본적으로 <strong>원격 서버의 <code>/</code> (루트 디렉터리)를 마운트하려고 하고 있음</strong>.<br>
그러나 사용자의 홈 디렉터리가 <code>/home/jonpark</code>이 아닐 수도 있습니다.<br>
먼저 SSH로 접속한 후, 현재 디렉터리가 어디인지 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo $HOME
</span></span><span style="display:flex;"><span>pwd
</span></span><span style="display:flex;"><span>ls -la ~
</span></span></code></pre></div><p>📌 <strong>출력 예시 (홈 디렉터리가 <code>/home/jonpark</code>일 경우)</strong></p>
<pre tabindex="0"><code>/home/jonpark
</code></pre><p>📌 <strong>출력 예시 (홈 디렉터리가 다른 위치일 경우)</strong></p>
<pre tabindex="0"><code>/mnt/data/jonpark
</code></pre><p>🚀 <strong>해결 방법:</strong> 만약 홈 디렉터리가 <code>/home/jonpark</code>이 아니라 <code>/mnt/data/jonpark</code>과 같은 다른 위치라면, SSHFS 명령어에서 <strong>정확한 경로를 지정해야 합니다.</strong></p>
<p>✅ <strong>예제</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/mnt/data/jonpark J: -o debug
</span></span></code></pre></div><hr>
<h3 id="-해결-방법-2-원격-디렉터리-존재-여부-확인"><strong>✅ 해결 방법 2: 원격 디렉터리 존재 여부 확인</strong><a hidden class="anchor" aria-hidden="true" href="#-해결-방법-2-원격-디렉터리-존재-여부-확인">#</a></h3>
<p>혹시 <strong>SSHFS가 마운트하려는 디렉터리가 실제로 존재하지 않는다면</strong> 마운트가 실패할 수 있습니다.<br>
아래 명령어로 마운트하려는 경로가 실제로 있는지 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ls -ld /
</span></span><span style="display:flex;"><span>ls -ld /home
</span></span><span style="display:flex;"><span>ls -ld /home/jonpark
</span></span></code></pre></div><p>🚨 <strong>출력 예시 (디렉터리가 없을 경우)</strong></p>
<pre tabindex="0"><code>ls: cannot access &#39;/home/jonpark&#39;: No such file or directory
</code></pre><p>✅ <strong>해결 방법:</strong> 존재하는 디렉터리를 확인한 후, SSHFS 마운트 경로를 수정하세요.</p>
<hr>
<h3 id="-해결-방법-3-로컬-마운트-포인트-존재-여부-확인"><strong>✅ 해결 방법 3: 로컬 마운트 포인트 존재 여부 확인</strong><a hidden class="anchor" aria-hidden="true" href="#-해결-방법-3-로컬-마운트-포인트-존재-여부-확인">#</a></h3>
<p>Windows에서 SSHFS를 사용하려면, <strong>J: 드라이브가 실제로 존재해야 합니다.</strong><br>
다음 명령어로 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Get-PSDrive -PSProvider FileSystem
</span></span></code></pre></div><p>🚨 <strong>출력 예시 (J: 드라이브 없음)</strong></p>
<pre tabindex="0"><code>Name           Used (GB)     Free (GB) Provider   Root
----           --------     --------- --------   ----
C                 50.23         100.7 FileSystem C:\
D                 80.42         150.1 FileSystem D:\
E                100.42         250.1 FileSystem E:\
</code></pre><p>✅ <strong>해결 방법:</strong> SSHFS 마운트 전에 먼저 드라이브를 생성하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>net use J: /delete /y
</span></span></code></pre></div><hr>
<h3 id="-해결-방법-4-sshfs-마운트-디버깅--o-debug-옵션-사용"><strong>✅ 해결 방법 4: SSHFS 마운트 디버깅 (<code>-o debug</code> 옵션 사용)</strong><a hidden class="anchor" aria-hidden="true" href="#-해결-방법-4-sshfs-마운트-디버깅--o-debug-옵션-사용">#</a></h3>
<p>SSHFS 마운트 시 <strong>더 많은 디버깅 정보를 확인하려면</strong> 다음과 같이 실행하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/home/jonpark J: -o sshfs_debug -o loglevel=debug
</span></span></code></pre></div><hr>
<h3 id="-최종-실행-방법"><strong>🚀 최종 실행 방법</strong><a hidden class="anchor" aria-hidden="true" href="#-최종-실행-방법">#</a></h3>
<p>✅ <strong>홈 디렉터리가 <code>/home/jonpark</code>일 경우</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/home/jonpark J: -o debug
</span></span></code></pre></div><p>✅ <strong>홈 디렉터리가 <code>/mnt/data/jonpark</code>일 경우</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/mnt/data/jonpark J: -o debug
</span></span></code></pre></div><p>✅ <strong>루트 디렉터리를 마운트하려면 (<code>/</code>)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sshfs jonpark@aws-sig-ts-jonpark.aws.internal<span style="color:#960050;background-color:#1e0010">:</span>/ J: -o debug
</span></span></code></pre></div><p>🚀 <strong>이제 다시 시도해보세요!</strong> 🚀</p>
<hr>
<h1 id="visual-studio-2022-에서-msbuildexe-위치는">visual studio 2022 에서 msbuild.exe 위치는<a hidden class="anchor" aria-hidden="true" href="#visual-studio-2022-에서-msbuildexe-위치는">#</a></h1>
<p>Visual Studio 2022에서 <code>cl.exe</code>는 Visual Studio 설치 디렉토리 안의 MSVC 도구 디렉토리에 위치합니다. <code>cl.exe</code>는 Microsoft C/C++ 컴파일러로, 아래 경로에서 찾을 수 있습니다.</p>
<hr>
<h3 id="기본-경로">기본 경로<a hidden class="anchor" aria-hidden="true" href="#기본-경로">#</a></h3>
<pre tabindex="0"><code>C:\Program Files\Microsoft Visual Studio\2022\&lt;Edition&gt;\VC\Tools\MSVC\&lt;Version&gt;\bin\Hostx64\x64\cl.exe
</code></pre><h4 id="설명">설명:<a hidden class="anchor" aria-hidden="true" href="#설명">#</a></h4>
<ul>
<li><strong><code>&lt;Edition&gt;</code></strong>: Visual Studio 에디션
<ul>
<li><code>Community</code>, <code>Professional</code>, <code>Enterprise</code></li>
</ul>
</li>
<li><strong><code>&lt;Version&gt;</code></strong>: 설치된 MSVC 도구 버전 (예: <code>14.36.32532</code>)
<ul>
<li>정확한 버전 번호는 Visual Studio 설치 시 설치된 도구 버전에 따라 달라집니다.</li>
</ul>
</li>
</ul>
<p>예를 들어, Visual Studio 2022 Community Edition과 최신 MSVC 도구를 사용하는 경우:</p>
<pre tabindex="0"><code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.36.32532\bin\Hostx64\x64\cl.exe
</code></pre><hr>
<h3 id="clexe-경로-확인-방법"><code>cl.exe</code> 경로 확인 방법<a hidden class="anchor" aria-hidden="true" href="#clexe-경로-확인-방법">#</a></h3>
<h4 id="1-visual-studio-명령-프롬프트-사용">1. <strong>Visual Studio 명령 프롬프트 사용</strong><a hidden class="anchor" aria-hidden="true" href="#1-visual-studio-명령-프롬프트-사용">#</a></h4>
<ul>
<li>Visual Studio 설치 시 제공되는 **&ldquo;x64 Native Tools Command Prompt for VS 2022&rdquo;**를 실행합니다.</li>
<li>다음 명령어를 실행하여 <code>cl.exe</code> 경로를 확인합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>where cl
</span></span></code></pre></div></li>
</ul>
<h4 id="2-visual-studio-설치-관리자에서-확인">2. <strong>Visual Studio 설치 관리자에서 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-visual-studio-설치-관리자에서-확인">#</a></h4>
<ul>
<li>Visual Studio Installer를 열고 설치된 구성에서 <strong>&ldquo;Desktop development with C++&rdquo;</strong> 워크로드가 설치되어 있는지 확인합니다.
<ul>
<li>이 워크로드가 설치되어야 <code>cl.exe</code>가 포함됩니다.</li>
</ul>
</li>
</ul>
<h4 id="3-파일-탐색기로-확인">3. <strong>파일 탐색기로 확인</strong><a hidden class="anchor" aria-hidden="true" href="#3-파일-탐색기로-확인">#</a></h4>
<ul>
<li>아래 경로에서 직접 확인:
<pre tabindex="0"><code>C:\Program Files\Microsoft Visual Studio\2022\&lt;Edition&gt;\VC\Tools\MSVC
</code></pre></li>
<li>MSVC 버전 폴더 내부를 탐색해 <code>bin\Hostx64\x64</code> 경로에서 <code>cl.exe</code> 파일을 찾습니다.</li>
</ul>
<hr>
<h3 id="환경-변수에-추가-선택-사항">환경 변수에 추가 (선택 사항)<a hidden class="anchor" aria-hidden="true" href="#환경-변수에-추가-선택-사항">#</a></h3>
<p><code>cl.exe</code>를 자주 사용해야 한다면, 해당 경로를 환경 변수 <code>PATH</code>에 추가하여 어디서나 사용할 수 있도록 설정할 수 있습니다.</p>
<ol>
<li><strong>Windows 검색</strong> → &ldquo;환경 변수 편집&rdquo; 입력 후 실행.</li>
<li>&ldquo;시스템 변수&rdquo; 섹션에서 <code>Path</code>를 선택하고 &ldquo;편집&rdquo; 클릭.</li>
<li>위 경로를 새로 추가.</li>
</ol>
<hr>
<h2 id="필요한-사항이나-추가-질문이-있으면-언제든-말씀해주세요-">필요한 사항이나 추가 질문이 있으면 언제든 말씀해주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#필요한-사항이나-추가-질문이-있으면-언제든-말씀해주세요-">#</a></h2>
<h1 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h1>
<hr>
<h1 id="heading-1"><a hidden class="anchor" aria-hidden="true" href="#heading-1">#</a></h1>
<hr>
<h1 id="heading-2"><a hidden class="anchor" aria-hidden="true" href="#heading-2">#</a></h1>
<hr>
<h1 id="heading-3"><a hidden class="anchor" aria-hidden="true" href="#heading-3">#</a></h1>
<hr>
<h1 id="heading-4"><a hidden class="anchor" aria-hidden="true" href="#heading-4">#</a></h1>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/portfolio/">RyanLabs</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
