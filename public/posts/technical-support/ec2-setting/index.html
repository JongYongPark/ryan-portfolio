<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><script src="/portfolio/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=portfolio/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>RyanLabs</title>
<meta name="keywords" content="">
<meta name="description" content="To create an EC2 instance
To create an EC2 instance for machine learning using a GPU, follow these steps:
1. Sign in to AWS Console

Go to the AWS Management Console, and sign in with your credentials.

2. Open EC2 Dashboard

From the AWS Management Console, type EC2 in the search bar and click on EC2 to open the EC2 dashboard.

3. Launch an EC2 Instance

In the EC2 Dashboard, click Launch Instance.
Give your instance a name, for example, &ldquo;ML-GPU-Instance&rdquo;.

4. Select an Amazon Machine Image (AMI)

AWS provides deep learning AMIs that come with machine learning libraries pre-installed.
In the Choose AMI section, search for “Deep Learning AMI” and select a version that is compatible with your needs (e.g., Ubuntu or Amazon Linux).
These AMIs come pre-installed with frameworks like TensorFlow, PyTorch, and MXNet.

5. Choose an Instance Type

Select an instance type that has a GPU.
P-Series (e.g., p2.xlarge, p3.xlarge): These instances are optimized for machine learning and provide NVIDIA GPUs.
G-Series (e.g., g4dn.xlarge): These instances are also suitable for ML tasks and offer GPUs with a better price-performance ratio.
If you&rsquo;re starting with lighter tasks, the g4dn.xlarge instance is a good choice. For more intense workloads, consider the p3.2xlarge.

6. Configure Instance Details

Configure the instance as per your requirement. Usually, the defaults work fine for individual or smaller-scale experiments.
If needed, you can add more details such as VPC, subnet, and Auto Scaling options.

7. Add Storage

By default, AWS allocates a root volume, but for machine learning workloads, you might need more storage for datasets.
Increase the storage size (e.g., 100 GB or more) if you&rsquo;re working with large datasets.
Ensure that the storage type is SSD (gp2 or gp3), which provides better performance.

8. Configure Security Group

Create or select a security group to allow SSH access.
Open port 22 for SSH if you want to connect to the instance.
If you plan to use Jupyter Notebooks on the instance, you will also need to open port 8888 for HTTP access.

9. Launch the Instance

Review your configuration and click on Launch.
AWS will prompt you to select a key pair. Create a new key pair if you don&rsquo;t have one, and download it (this is required to SSH into your instance).
Click Launch Instances.

10. Connect to Your EC2 Instance


After launching the instance, go to the Instances page, find your instance, and click Connect.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/portfolio/posts/technical-support/ec2-setting/">
<link crossorigin="anonymous" href="/portfolio/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/portfolio/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/portfolio/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/portfolio/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/portfolio/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/portfolio/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/portfolio/posts/technical-support/ec2-setting/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/portfolio/" accesskey="h" title="RyanLabs (Alt + H)">RyanLabs</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/portfolio/search/" title="검색">
                    <span>검색</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/categories/" title="카테고리">
                    <span>카테고리</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/tags/" title="태그">
                    <span>태그</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/archives/" title="연도">
                    <span>연도</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/lectures/" title="강의">
                    <span>강의</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/about/" title="어바웃미">
                    <span>어바웃미</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="to-create-an-ec2-instance">To create an EC2 instance<a hidden class="anchor" aria-hidden="true" href="#to-create-an-ec2-instance">#</a></h1>
<p>To create an EC2 instance for machine learning using a GPU, follow these steps:</p>
<h3 id="1-sign-in-to-aws-console">1. <strong>Sign in to AWS Console</strong><a hidden class="anchor" aria-hidden="true" href="#1-sign-in-to-aws-console">#</a></h3>
<ul>
<li>Go to the <a href="https://aws.amazon.com/console/">AWS Management Console</a>, and sign in with your credentials.</li>
</ul>
<h3 id="2-open-ec2-dashboard">2. <strong>Open EC2 Dashboard</strong><a hidden class="anchor" aria-hidden="true" href="#2-open-ec2-dashboard">#</a></h3>
<ul>
<li>From the AWS Management Console, type <strong>EC2</strong> in the search bar and click on <strong>EC2</strong> to open the EC2 dashboard.</li>
</ul>
<h3 id="3-launch-an-ec2-instance">3. <strong>Launch an EC2 Instance</strong><a hidden class="anchor" aria-hidden="true" href="#3-launch-an-ec2-instance">#</a></h3>
<ul>
<li>In the EC2 Dashboard, click <strong>Launch Instance</strong>.</li>
<li>Give your instance a name, for example, &ldquo;ML-GPU-Instance&rdquo;.</li>
</ul>
<h3 id="4-select-an-amazon-machine-image-ami">4. <strong>Select an Amazon Machine Image (AMI)</strong><a hidden class="anchor" aria-hidden="true" href="#4-select-an-amazon-machine-image-ami">#</a></h3>
<ul>
<li>AWS provides deep learning AMIs that come with machine learning libraries pre-installed.</li>
<li>In the <strong>Choose AMI</strong> section, search for “<strong>Deep Learning AMI</strong>” and select a version that is compatible with your needs (e.g., Ubuntu or Amazon Linux).</li>
<li>These AMIs come pre-installed with frameworks like TensorFlow, PyTorch, and MXNet.</li>
</ul>
<h3 id="5-choose-an-instance-type">5. <strong>Choose an Instance Type</strong><a hidden class="anchor" aria-hidden="true" href="#5-choose-an-instance-type">#</a></h3>
<ul>
<li>Select an instance type that has a GPU.</li>
<li><strong>P-Series (e.g., p2.xlarge, p3.xlarge)</strong>: These instances are optimized for machine learning and provide NVIDIA GPUs.</li>
<li><strong>G-Series (e.g., g4dn.xlarge)</strong>: These instances are also suitable for ML tasks and offer GPUs with a better price-performance ratio.</li>
<li>If you&rsquo;re starting with lighter tasks, the <strong>g4dn.xlarge</strong> instance is a good choice. For more intense workloads, consider the <strong>p3.2xlarge</strong>.</li>
</ul>
<h3 id="6-configure-instance-details">6. <strong>Configure Instance Details</strong><a hidden class="anchor" aria-hidden="true" href="#6-configure-instance-details">#</a></h3>
<ul>
<li>Configure the instance as per your requirement. Usually, the defaults work fine for individual or smaller-scale experiments.</li>
<li>If needed, you can add more details such as VPC, subnet, and Auto Scaling options.</li>
</ul>
<h3 id="7-add-storage">7. <strong>Add Storage</strong><a hidden class="anchor" aria-hidden="true" href="#7-add-storage">#</a></h3>
<ul>
<li>By default, AWS allocates a root volume, but for machine learning workloads, you might need more storage for datasets.</li>
<li>Increase the storage size (e.g., 100 GB or more) if you&rsquo;re working with large datasets.</li>
<li>Ensure that the storage type is SSD (gp2 or gp3), which provides better performance.</li>
</ul>
<h3 id="8-configure-security-group">8. <strong>Configure Security Group</strong><a hidden class="anchor" aria-hidden="true" href="#8-configure-security-group">#</a></h3>
<ul>
<li>Create or select a security group to allow SSH access.</li>
<li>Open port <strong>22</strong> for SSH if you want to connect to the instance.</li>
<li>If you plan to use Jupyter Notebooks on the instance, you will also need to open port <strong>8888</strong> for HTTP access.</li>
</ul>
<h3 id="9-launch-the-instance">9. <strong>Launch the Instance</strong><a hidden class="anchor" aria-hidden="true" href="#9-launch-the-instance">#</a></h3>
<ul>
<li>Review your configuration and click on <strong>Launch</strong>.</li>
<li>AWS will prompt you to select a key pair. Create a new key pair if you don&rsquo;t have one, and download it (this is required to SSH into your instance).</li>
<li>Click <strong>Launch Instances</strong>.</li>
</ul>
<h3 id="10-connect-to-your-ec2-instance">10. <strong>Connect to Your EC2 Instance</strong><a hidden class="anchor" aria-hidden="true" href="#10-connect-to-your-ec2-instance">#</a></h3>
<ul>
<li>
<p>After launching the instance, go to the <strong>Instances</strong> page, find your instance, and click <strong>Connect</strong>.</p>
</li>
<li>
<p>Follow the instructions to connect via SSH using your key pair:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i <span style="color:#e6db74">&#34;your-key.pem&#34;</span> ubuntu@your-instance-public-ip
</span></span></code></pre></div></li>
</ul>
<h3 id="11-install-cuda-and-cudnn-if-not-already-installed">11. <strong>Install CUDA and cuDNN (if not already installed)</strong><a hidden class="anchor" aria-hidden="true" href="#11-install-cuda-and-cudnn-if-not-already-installed">#</a></h3>
<ul>
<li>Most deep learning AMIs come pre-installed with CUDA and cuDNN, which are required to leverage the GPU.</li>
<li>If not installed, you can install them manually:
<ul>
<li>Install CUDA from the official <a href="https://developer.nvidia.com/cuda-toolkit-archive">NVIDIA CUDA website</a>.</li>
<li>Install cuDNN from <a href="https://developer.nvidia.com/cudnn">NVIDIA cuDNN library</a>.</li>
</ul>
</li>
</ul>
<h3 id="12-set-up-your-machine-learning-environment">12. <strong>Set up Your Machine Learning Environment</strong><a hidden class="anchor" aria-hidden="true" href="#12-set-up-your-machine-learning-environment">#</a></h3>
<ul>
<li>If you’re using the Deep Learning AMI, many ML frameworks like TensorFlow, PyTorch, and MXNet are already installed.</li>
<li>Activate the appropriate environment (e.g., TensorFlow or PyTorch) by running:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>source activate tensorflow_p36  <span style="color:#75715e"># for TensorFlow</span>
</span></span><span style="display:flex;"><span>source activate pytorch_p36     <span style="color:#75715e"># for PyTorch</span>
</span></span></code></pre></div></li>
</ul>
<h3 id="13-optional-set-up-jupyter-notebook">13. <strong>(Optional) Set up Jupyter Notebook</strong><a hidden class="anchor" aria-hidden="true" href="#13-optional-set-up-jupyter-notebook">#</a></h3>
<ul>
<li>Install Jupyter Notebook:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pip install jupyterlab
</span></span></code></pre></div></li>
<li>Start Jupyter Notebook and make it accessible from your browser:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>jupyter notebook --ip<span style="color:#f92672">=</span>0.0.0.0 --port<span style="color:#f92672">=</span><span style="color:#ae81ff">8888</span> --no-browser
</span></span></code></pre></div></li>
<li>Open a browser and navigate to <code>http://your-instance-public-ip:8888</code>. You will be able to interact with Jupyter Notebook for running ML experiments.</li>
</ul>
<h3 id="14-use-the-instance-for-machine-learning">14. <strong>Use the Instance for Machine Learning</strong><a hidden class="anchor" aria-hidden="true" href="#14-use-the-instance-for-machine-learning">#</a></h3>
<ul>
<li>
<p>With everything set up, you can now use the GPU for training machine learning models. You can start with TensorFlow or PyTorch examples to ensure that the GPU is properly being used.</p>
</li>
<li>
<p>For TensorFlow, run the following to verify that the GPU is detected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> tensorflow <span style="color:#66d9ef">as</span> tf
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Num GPUs Available: &#34;</span>, len(tf<span style="color:#f92672">.</span>config<span style="color:#f92672">.</span>experimental<span style="color:#f92672">.</span>list_physical_devices(<span style="color:#e6db74">&#39;GPU&#39;</span>)))
</span></span></code></pre></div></li>
<li>
<p>For PyTorch, you can check GPU availability by running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> torch
</span></span><span style="display:flex;"><span>print(torch<span style="color:#f92672">.</span>cuda<span style="color:#f92672">.</span>is_available())
</span></span></code></pre></div></li>
</ul>
<h3 id="15-shutdown-the-instance">15. <strong>Shutdown the Instance</strong><a hidden class="anchor" aria-hidden="true" href="#15-shutdown-the-instance">#</a></h3>
<ul>
<li>GPU instances can be expensive, so remember to <strong>stop</strong> or <strong>terminate</strong> your instance when you’re not using it.</li>
<li>You can stop it from the EC2 dashboard by selecting the instance and choosing <strong>Actions &gt; Instance State &gt; Stop</strong>.</li>
</ul>
<p>By following these steps, you can create an EC2 instance with GPU support for machine learning tasks.</p>
<h1 id="ec2-스토리지">EC2 스토리지<a hidden class="anchor" aria-hidden="true" href="#ec2-스토리지">#</a></h1>
<p>아마도 EC2 인스턴스에 연결되어 있던 임시 스토리지(Ephemeral Storage) 혹은 LVM 볼륨이 정상적으로 인식되지 않아 발생하는 문제로 보입니다. Amazon EC2 환경에서 Ephemeral 스토리지는 인스턴스를 멈추거나 재부팅할 때 초기화되거나 사라질 수 있으므로, 다음 단계를 통해 문제를 진단하고 해결할 수 있습니다.</p>
<hr>
<h2 id="1-현재-디스크볼륨-상태-확인">1. 현재 디스크/볼륨 상태 확인<a hidden class="anchor" aria-hidden="true" href="#1-현재-디스크볼륨-상태-확인">#</a></h2>
<ol>
<li>
<p><strong>블록 디바이스 목록 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>lsblk
</span></span></code></pre></div><ul>
<li>현재 연결된 디바이스와 마운트 여부, 파티션 정보를 확인합니다.</li>
<li><code>/dev/mapper/vg.01-lv_ephemeral</code> 디바이스가 실제로 존재하는지, 어떤 파일시스템을 사용하는지 살펴봅니다.</li>
</ul>
</li>
<li>
<p><strong>LVM 볼륨 상태 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lvscan
</span></span><span style="display:flex;"><span>sudo vgscan
</span></span><span style="display:flex;"><span>sudo pvscan
</span></span></code></pre></div><ul>
<li>LVM 볼륨(vg.01-lv_ephemeral)이 제대로 인식되고 있는지 확인합니다.</li>
<li>볼륨 그룹(vg.01)이나 논리 볼륨(lv_ephemeral)에 오류가 있는지 점검합니다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-파일시스템-유형-및-무결성-검사">2. 파일시스템 유형 및 무결성 검사<a hidden class="anchor" aria-hidden="true" href="#2-파일시스템-유형-및-무결성-검사">#</a></h2>
<ol>
<li>
<p><strong>파일시스템 유형 확인</strong></p>
<ul>
<li><code>/etc/fstab</code> 파일에서 <code>vg.01-lv_ephemeral</code> 파티션이 어떤 파일시스템 유형으로 설정되어 있는지 확인합니다. (<code>ext4</code>, <code>xfs</code>, etc.)</li>
<li><code>lsblk -f</code> 명령어나 <code>sudo file -s /dev/mapper/vg.01-lv_ephemeral</code> 명령어를 통해 실제 디스크가 어떤 파일시스템 유형으로 포맷되어 있는지 확인합니다.</li>
</ul>
</li>
<li>
<p><strong>파일시스템 무결성 검사</strong></p>
<ul>
<li>파일시스템이 <code>ext4</code>라면 <code>sudo fsck -f /dev/mapper/vg.01-lv_ephemeral</code>로 점검해볼 수 있고, <code>xfs</code>라면 <code>xfs_repair</code> 명령어를 사용해야 합니다.</li>
<li>만약 슈퍼블록이나 메타데이터가 손상되었을 경우, fsck나 xfs_repair를 통해 복구해야 할 수 있습니다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-fstab-설정-점검">3. fstab 설정 점검<a hidden class="anchor" aria-hidden="true" href="#3-fstab-설정-점검">#</a></h2>
<ol>
<li>
<p><strong>fstab 라인 확인</strong></p>
<ul>
<li><code>/etc/fstab</code> 파일에 등록된 해당 항목을 확인합니다. 예를 들어 다음과 같은 방식일 수 있습니다:
<pre tabindex="0"><code>/dev/mapper/vg.01-lv_ephemeral  /home/ubuntu/workspace  ext4  defaults,nofail  0  2
</code></pre></li>
<li>실제 파일시스템 유형과 <code>fstab</code>에 명시된 파일시스템 유형이 일치해야 합니다.</li>
<li><code>defaults</code> 외에 다른 옵션(<code>noauto</code>, <code>nouuid</code>, <code>nodev</code> 등)이 잘못 들어가 있는지도 확인합니다.</li>
</ul>
</li>
<li>
<p><strong>자동 마운트 제거 혹은 주석 처리(임시 조치)</strong></p>
<ul>
<li>문제가 지속되거나 부팅이 방해된다면 해당 라인을 주석 처리하고 수동으로 마운트 테스트를 해봅니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># /dev/mapper/vg.01-lv_ephemeral  /home/ubuntu/workspace  ext4  defaults,nofail  0  2</span>
</span></span></code></pre></div></li>
<li>이후 수동 마운트 시도:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -t ext4 /dev/mapper/vg.01-lv_ephemeral /home/ubuntu/workspace
</span></span></code></pre></div><ul>
<li>정상적으로 마운트가 되는지 확인합니다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-ephemeral-스토리지-특성-주의">4. Ephemeral 스토리지 특성 주의<a hidden class="anchor" aria-hidden="true" href="#4-ephemeral-스토리지-특성-주의">#</a></h2>
<ul>
<li>EC2의 **인스턴스 스토어(Ephemeral Storage)**는 인스턴스를 중지(stop)했다가 다시 시작하면(재부팅과는 다름) 데이터가 보장되지 않을 수 있습니다.</li>
<li>만약 영구적으로 사용해야 할 스토리지라면 <strong>EBS 볼륨</strong>을 사용하는 것이 일반적입니다.</li>
<li>Ephemeral 스토리지를 재활용하려면, 인스턴스가 재시작될 때마다 다시 파티션을 생성하고, 파일시스템을 포맷한 뒤 마운트해야 할 수도 있습니다.</li>
</ul>
<hr>
<h2 id="5-해결-시나리오-요약">5. 해결 시나리오 요약<a hidden class="anchor" aria-hidden="true" href="#5-해결-시나리오-요약">#</a></h2>
<ol>
<li><strong>임시로 fstab 항목을 주석 처리</strong>하여 부팅 시 오류가 발생하지 않도록 한 뒤, 부팅 후에 수동 마운트를 시도합니다.</li>
<li>LVM 볼륨과 실제 디스크 상태를 확인하고, 파일시스템을 맞게 설정했는지(예: ext4 vs xfs) 점검합니다.</li>
<li>파일시스템이 손상되었거나 슈퍼블록에 문제가 있다면 <code>fsck</code> 또는 <code>xfs_repair</code>를 통해 복구를 시도합니다.</li>
<li>Ephemeral 스토리지 특성상 인스턴스 중지 후 데이터가 사라질 수 있으므로, 장기적으로 사용할 저장소라면 EBS로 마이그레이션을 고려합니다.</li>
</ol>
<hr>
<p>위 단계를 수행하면 대부분의 경우 “wrong fs type, bad option, bad superblock…” 등의 마운트 실패 문제를 해결할 수 있습니다. 만약 모든 과정을 거쳤음에도 불구하고 계속 오류가 발생한다면, AWS 콘솔에서 블록 디바이스 매핑이 올바른지(혹은 원하는 디바이스가 실제로 존재하는지) 다시 한 번 확인하시기 바랍니다.</p>
<h1 id="work로-마운트-경로를-변경"><code>~/work</code>로 마운트 경로를 변경<a hidden class="anchor" aria-hidden="true" href="#work로-마운트-경로를-변경">#</a></h1>
<p>EC2 Ubuntu에서 <code>/dev/mapper/vg.01-lv_ephemeral</code>을 현재 <code>/opt/dlami/nvme</code>에 마운트하고 있다면, 이를 <code>~/work</code>로 마운트 경로를 변경하려면 아래 단계를 따르면 됩니다.</p>
<hr>
<h3 id="1-현재-마운트-상태-확인"><strong>1. 현재 마운트 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-현재-마운트-상태-확인">#</a></h3>
<ol>
<li>
<p>터미널에서 다음 명령을 실행하여 마운트 상태를 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -h
</span></span></code></pre></div><ul>
<li><code>/dev/mapper/vg.01-lv_ephemeral</code>이 <code>/opt/dlami/nvme</code>에 마운트된 상태를 확인할 수 있습니다.</li>
</ul>
</li>
<li>
<p><code>/etc/fstab</code> 파일에서 관련 마운트 설정을 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /etc/fstab
</span></span></code></pre></div><ul>
<li><code>/dev/mapper/vg.01-lv_ephemeral</code>이 <code>/opt/dlami/nvme</code>로 설정되어 있을 가능성이 있습니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-기존-마운트-해제"><strong>2. 기존 마운트 해제</strong><a hidden class="anchor" aria-hidden="true" href="#2-기존-마운트-해제">#</a></h3>
<ol>
<li>현재 <code>/dev/mapper/vg.01-lv_ephemeral</code>의 마운트를 해제합니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo umount /opt/dlami/nvme
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="3-새로운-마운트-디렉토리-생성"><strong>3. 새로운 마운트 디렉토리 생성</strong><a hidden class="anchor" aria-hidden="true" href="#3-새로운-마운트-디렉토리-생성">#</a></h3>
<ol>
<li>새로운 마운트 경로인 <code>~/work</code>를 만듭니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p ~/work
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="4-새-마운트-적용"><strong>4. 새 마운트 적용</strong><a hidden class="anchor" aria-hidden="true" href="#4-새-마운트-적용">#</a></h3>
<ol>
<li>
<p><code>~/work</code>에 <code>/dev/mapper/vg.01-lv_ephemeral</code>을 마운트합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount /dev/mapper/vg.01-lv_ephemeral ~/work
</span></span></code></pre></div></li>
<li>
<p>마운트가 성공적으로 되었는지 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -h
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="5-마운트를-영구적으로-설정"><strong>5. 마운트를 영구적으로 설정</strong><a hidden class="anchor" aria-hidden="true" href="#5-마운트를-영구적으로-설정">#</a></h3>
<ol>
<li>
<p><code>/etc/fstab</code> 파일을 편집하여 부팅 시 자동 마운트를 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/fstab
</span></span></code></pre></div></li>
<li>
<p>기존 <code>/opt/dlami/nvme</code>와 관련된 라인을 주석 처리하거나 제거하고, 다음 라인을 추가합니다.</p>
<pre tabindex="0"><code>/dev/mapper/vg.01-lv_ephemeral /home/username/work ext4 defaults 0 0
</code></pre><ul>
<li><code>username</code>을 현재 사용자 이름으로 변경합니다.</li>
<li>파일시스템 유형(<code>ext4</code>)은 현재 설정과 동일해야 합니다. 필요하면 <code>lsblk -f</code>로 확인하세요.</li>
</ul>
</li>
<li>
<p>변경 내용을 저장하고 나옵니다.</p>
</li>
<li>
<p>설정이 올바른지 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -a
</span></span></code></pre></div><ul>
<li>오류가 없다면 설정이 성공적으로 적용된 것입니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-권한-조정-선택-사항"><strong>6. 권한 조정 (선택 사항)</strong><a hidden class="anchor" aria-hidden="true" href="#6-권한-조정-선택-사항">#</a></h3>
<ol>
<li>
<p>사용자 홈 디렉토리 내에서 마운트를 설정했으므로 적절한 소유권을 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chown -R $USER:$USER ~/work
</span></span></code></pre></div></li>
<li>
<p>권한을 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -ld ~/work
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="결과"><strong>결과</strong><a hidden class="anchor" aria-hidden="true" href="#결과">#</a></h3>
<p>이제 <code>/dev/mapper/vg.01-lv_ephemeral</code>이 <code>~/work</code>로 마운트됩니다. 시스템을 재부팅해도 설정이 유지됩니다. 문제가 발생하면 말씀해 주세요! 😊</p>
<h1 id="devmappervg01-lv_ephemeral을-optdlaminvme-대신-work로-마운트하도록-설정을-변경"><code>/dev/mapper/vg.01-lv_ephemeral</code>을 <code>/opt/dlami/nvme</code> 대신 <code>~/work</code>로 마운트하도록 설정을 변경<a hidden class="anchor" aria-hidden="true" href="#devmappervg01-lv_ephemeral을-optdlaminvme-대신-work로-마운트하도록-설정을-변경">#</a></h1>
<p>제공하신 정보를 바탕으로 <code>/dev/mapper/vg.01-lv_ephemeral</code>을 <code>/opt/dlami/nvme</code> 대신 <code>~/work</code>로 마운트하도록 설정을 변경하는 방법을 안내드립니다.</p>
<hr>
<h3 id="수정-방법"><strong>수정 방법</strong><a hidden class="anchor" aria-hidden="true" href="#수정-방법">#</a></h3>
<ol>
<li>
<p><strong>기존 마운트 해제</strong></p>
<ul>
<li><code>/dev/mapper/vg.01-lv_ephemeral</code>이 <code>/opt/dlami/nvme</code>에 마운트되어 있으므로 이를 먼저 해제해야 합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo umount /opt/dlami/nvme
</span></span></code></pre></div></li>
<li>
<p><strong>새 마운트 디렉토리 생성</strong></p>
<ul>
<li>홈 디렉토리 아래에 새로운 마운트 경로를 만듭니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p ~/work
</span></span></code></pre></div></li>
<li>
<p><strong>수동 마운트 테스트</strong></p>
<ul>
<li>새 경로에 장치를 수동으로 마운트하여 정상 작동하는지 확인합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount /dev/mapper/vg.01-lv_ephemeral ~/work
</span></span></code></pre></div><ul>
<li>정상적으로 마운트되었는지 확인하려면 다음 명령을 실행합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -h
</span></span></code></pre></div></li>
<li>
<p><strong><code>/etc/fstab</code> 파일 수정</strong></p>
<ul>
<li><code>/etc/fstab</code> 파일을 열고, <code>/dev/mapper/vg.01-lv_ephemeral</code>을 <code>/opt/dlami/nvme</code> 대신 <code>~/work</code>로 마운트되도록 설정합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/fstab
</span></span></code></pre></div><ul>
<li>아래와 같은 라인을 추가합니다. (홈 디렉토리를 절대 경로로 지정해야 하므로, <code>~/work</code> 대신 <code>/home/ubuntu/work</code>로 설정)</li>
</ul>
<pre tabindex="0"><code>/dev/mapper/vg.01-lv_ephemeral /home/ubuntu/work ext4 defaults 0 0
</code></pre><ul>
<li>파일을 저장하고 종료합니다. (Nano에서 저장: <code>Ctrl+O</code>, 종료: <code>Ctrl+X</code>)</li>
</ul>
</li>
<li>
<p><strong>자동 마운트 테스트</strong></p>
<ul>
<li>설정을 적용하려면 다음 명령을 실행하여 <code>/etc/fstab</code>의 구성을 테스트합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -a
</span></span></code></pre></div><ul>
<li>에러가 없으면 설정이 올바르게 적용된 것입니다.</li>
</ul>
</li>
<li>
<p><strong>권한 조정 (선택 사항)</strong></p>
<ul>
<li><code>~/work</code> 디렉토리를 현재 사용자(<code>ubuntu</code>)가 소유하도록 권한을 설정합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chown -R $USER:$USER ~/work
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="확인"><strong>확인</strong><a hidden class="anchor" aria-hidden="true" href="#확인">#</a></h3>
<ol>
<li>
<p>마운트 상태를 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -h
</span></span></code></pre></div><ul>
<li><code>/dev/mapper/vg.01-lv_ephemeral</code>이 <code>/home/ubuntu/work</code>에 마운트되어 있는지 확인합니다.</li>
</ul>
</li>
<li>
<p>시스템 재부팅 후에도 마운트가 유지되는지 확인합니다.</p>
</li>
</ol>
<hr>
<h3 id="주의-사항"><strong>주의 사항</strong><a hidden class="anchor" aria-hidden="true" href="#주의-사항">#</a></h3>
<ul>
<li>현재 루트 디스크(<code>/dev/root</code>)가 100% 사용 중입니다. 이로 인해 시스템 성능이 저하되거나 추가 작업에 문제가 발생할 수 있습니다. 불필요한 파일을 삭제하거나 디스크 용량을 늘리는 작업을 먼저 수행하는 것이 좋습니다.</li>
<li><code>/etc/fstab</code> 파일의 설정이 잘못되면 시스템이 부팅되지 않을 수 있으니, 수정 전에 항상 백업을 만들어 두는 것이 좋습니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo cp /etc/fstab /etc/fstab.backup
</span></span></code></pre></div></li>
</ul>
<hr>
<h1 id="etcfstab-설정에서-devmappervg01-lv_ephemeral을-homeubuntuwork에-마운트하도록-설정"><code>/etc/fstab</code> 설정에서 <code>/dev/mapper/vg.01-lv_ephemeral</code>을 <code>/home/ubuntu/work</code>에 마운트하도록 설정<a hidden class="anchor" aria-hidden="true" href="#etcfstab-설정에서-devmappervg01-lv_ephemeral을-homeubuntuwork에-마운트하도록-설정">#</a></h1>
<p>현재 <code>/etc/fstab</code> 설정에서 <code>/dev/mapper/vg.01-lv_ephemeral</code>을 <code>/home/ubuntu/work</code>에 마운트하도록 설정한 것은 기본적으로 맞습니다. 그러나 마운트 시 기본 소유권을 현재 사용자(<code>$USER</code>)로 설정하려면 약간의 수정이 필요합니다.</p>
<hr>
<h3 id="수정-방법-소유권을-user로-설정"><strong>수정 방법: 소유권을 <code>$USER</code>로 설정</strong><a hidden class="anchor" aria-hidden="true" href="#수정-방법-소유권을-user로-설정">#</a></h3>
<p>기본 마운트 옵션(<code>defaults</code>)으로는 소유권이 <code>root</code>로 설정됩니다. 이를 해결하려면 <code>fstab</code>의 마운트 옵션에 <code>uid</code>와 <code>gid</code>를 추가해야 합니다.</p>
<ol>
<li>
<p><strong>현재 사용자 UID와 GID 확인</strong></p>
<ul>
<li>터미널에서 다음 명령을 실행하여 UID와 GID를 확인합니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>id $USER
</span></span></code></pre></div></li>
<li>출력 예시:
<pre tabindex="0"><code>uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu)
</code></pre></li>
<li>여기서 UID와 GID는 각각 <code>1000</code>입니다.</li>
</ul>
</li>
<li>
<p><strong><code>/etc/fstab</code> 수정</strong></p>
<ul>
<li><code>/etc/fstab</code> 파일을 편집합니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/fstab
</span></span></code></pre></div></li>
<li>현재 라인을 다음과 같이 수정합니다:
<pre tabindex="0"><code>/dev/mapper/vg.01-lv_ephemeral /home/ubuntu/work ext4 defaults,uid=1000,gid=1000 0 0
</code></pre></li>
<li>여기서 <code>uid=1000</code>과 <code>gid=1000</code>은 현재 사용자 <code>ubuntu</code>의 소유권을 지정합니다.</li>
</ul>
</li>
<li>
<p><strong>마운트 재적용</strong></p>
<ul>
<li>변경 내용을 적용하려면 <code>/home/ubuntu/work</code>을 다시 마운트합니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo umount /home/ubuntu/work
</span></span><span style="display:flex;"><span>sudo mount -a
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>결과 확인</strong></p>
<ul>
<li>소유권이 <code>$USER</code>로 설정되었는지 확인합니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -ld /home/ubuntu/work
</span></span></code></pre></div></li>
<li>출력 예시:
<pre tabindex="0"><code>drwxr-xr-x 2 ubuntu ubuntu 4096 Jan 22 10:00 /home/ubuntu/work
</code></pre></li>
</ul>
</li>
</ol>
<hr>
<h3 id="추가-설정-선택-사항"><strong>추가 설정 (선택 사항)</strong><a hidden class="anchor" aria-hidden="true" href="#추가-설정-선택-사항">#</a></h3>
<ul>
<li>만약 특정 사용자 외에 그룹 전체로 접근을 허용하고 싶다면 <code>umask</code> 옵션을 추가할 수도 있습니다:
<pre tabindex="0"><code>/dev/mapper/vg.01-lv_ephemeral /home/ubuntu/work ext4 defaults,uid=1000,gid=1000,umask=0022 0 0
</code></pre><ul>
<li><code>umask=0022</code>는 그룹과 다른 사용자에게 읽기 권한을 허용합니다.</li>
</ul>
</li>
</ul>
<hr>
<p>이 설정을 적용하면 마운트 시 기본적으로 <code>$USER</code>가 소유권을 가지게 됩니다. 문제가 있거나 추가로 궁금한 사항이 있으면 알려주세요! 😊</p>
<hr>
<h1 id="ollama-설치-시-기본-데이터를-저장하는-디렉토리인-llama를-다른-디렉토리로-변경"><code>ollama</code> 설치 시 기본 데이터를 저장하는 디렉토리인 <code>~/.llama</code>를 다른 디렉토리로 변경<a hidden class="anchor" aria-hidden="true" href="#ollama-설치-시-기본-데이터를-저장하는-디렉토리인-llama를-다른-디렉토리로-변경">#</a></h1>
<p><code>ollama</code> 설치 시 기본 데이터를 저장하는 디렉토리인 <code>~/.llama</code>를 다른 디렉토리로 변경하려면 환경 변수 설정이나 심볼릭 링크를 사용하여 경로를 변경할 수 있습니다. 아래 방법 중 하나를 선택하여 설정을 변경할 수 있습니다.</p>
<hr>
<h3 id="1-환경-변수로-기본-디렉토리-변경"><strong>1. 환경 변수로 기본 디렉토리 변경</strong><a hidden class="anchor" aria-hidden="true" href="#1-환경-변수로-기본-디렉토리-변경">#</a></h3>
<p><code>ollama</code>는 데이터를 저장할 디렉토리를 <code>OLLAMA_HOME</code> 환경 변수로 지정할 수 있습니다.</p>
<h4 id="단계"><strong>단계</strong><a hidden class="anchor" aria-hidden="true" href="#단계">#</a></h4>
<ol>
<li>
<p><strong>환경 변수 설정</strong></p>
<ul>
<li><code>~/.bashrc</code> 또는 <code>~/.zshrc</code> 파일에 다음 줄을 추가하여 <code>OLLAMA_HOME</code>을 설정합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export OLLAMA_HOME<span style="color:#f92672">=</span>~/workspace/.llama
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>환경 변수 적용</strong></p>
<ul>
<li>파일을 저장한 후, 다음 명령을 실행하여 변경 사항을 적용합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>source ~/.bashrc
</span></span></code></pre></div>또는
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>source ~/.zshrc
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>ollama 설치 및 실행</strong></p>
<ul>
<li><code>ollama</code>를 설치하거나 실행하면 데이터가 <code>~/workspace/.llama</code>에 저장됩니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-기존-데이터-이동-및-심볼릭-링크-사용"><strong>2. 기존 데이터 이동 및 심볼릭 링크 사용</strong><a hidden class="anchor" aria-hidden="true" href="#2-기존-데이터-이동-및-심볼릭-링크-사용">#</a></h3>
<p>기본 디렉토리(<code>~/.llama</code>)를 유지하면서, 다른 경로로 데이터를 이동하고 심볼릭 링크를 설정하는 방법입니다.</p>
<h4 id="단계-1"><strong>단계</strong><a hidden class="anchor" aria-hidden="true" href="#단계-1">#</a></h4>
<ol>
<li>
<p><strong>기존 데이터 이동</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mv ~/.llama ~/workspace/.llama
</span></span></code></pre></div></li>
<li>
<p><strong>심볼릭 링크 생성</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ln -s ~/workspace/.llama ~/.llama
</span></span></code></pre></div></li>
<li>
<p><strong>설정 확인</strong></p>
<ul>
<li>이제 <code>ollama</code>는 <code>~/workspace/.llama</code>를 사용하면서도 <code>~/.llama</code>로 접근합니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-ollama-실행-시-옵션으로-경로-지정"><strong>3. ollama 실행 시 옵션으로 경로 지정</strong><a hidden class="anchor" aria-hidden="true" href="#3-ollama-실행-시-옵션으로-경로-지정">#</a></h3>
<p><code>ollama</code> 실행 시 특정 옵션을 통해 저장 경로를 지정할 수도 있습니다(ollama에서 지원할 경우).<br>
예를 들어, 다음 명령어를 사용하여 실행할 때마다 저장 경로를 설정합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama --home ~/workspace/.llama
</span></span></code></pre></div><ul>
<li>이 방법은 지속적이지 않으므로 매번 명령에 옵션을 추가해야 합니다.</li>
</ul>
<hr>
<h3 id="추천"><strong>추천</strong><a hidden class="anchor" aria-hidden="true" href="#추천">#</a></h3>
<ul>
<li>환경 변수를 설정하는 <strong>방법 1</strong>은 지속적이고 간단하며, 여러 프로젝트에서 동일한 경로를 사용할 수 있어 가장 유용합니다.</li>
<li>기존 데이터를 보존하면서 다른 경로로 리디렉션하려면 <strong>방법 2</strong>를 사용할 수 있습니다.</li>
</ul>
<p>필요한 추가 정보나 문제가 발생하면 알려주세요! 😊</p>
<hr>
<h1 id="aws-ec2-인스턴스에서-메모리를-증가시키는-방법">AWS EC2 인스턴스에서 메모리를 증가시키는 방법<a hidden class="anchor" aria-hidden="true" href="#aws-ec2-인스턴스에서-메모리를-증가시키는-방법">#</a></h1>
<p>AWS EC2 인스턴스에서 메모리를 증가시키는 방법은 주로 <strong>인스턴스 유형 변경</strong>을 통해 이루어집니다. 현재 사용 중인 인스턴스 유형보다 더 많은 메모리를 제공하는 유형으로 변경해야 합니다. 아래에 단계별로 안내드립니다.</p>
<hr>
<h3 id="1-현재-인스턴스-유형-확인"><strong>1. 현재 인스턴스 유형 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-현재-인스턴스-유형-확인">#</a></h3>
<p>먼저, 현재 인스턴스 유형과 메모리 크기를 확인합니다.</p>
<ol>
<li>AWS Management Console에서 <strong>EC2 대시보드</strong>로 이동.</li>
<li><strong>인스턴스</strong> 메뉴에서 해당 인스턴스를 선택.</li>
<li><strong>인스턴스 유형</strong>(e.g., <code>t2.micro</code>)과 세부 사양(메모리 크기 포함)을 확인.</li>
</ol>
<p>또는, SSH로 인스턴스에 접속하여 다음 명령어를 실행:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>free -h
</span></span></code></pre></div><p>이 명령은 현재 사용 가능한 메모리를 보여줍니다.</p>
<hr>
<h3 id="2-적합한-인스턴스-유형-선택"><strong>2. 적합한 인스턴스 유형 선택</strong><a hidden class="anchor" aria-hidden="true" href="#2-적합한-인스턴스-유형-선택">#</a></h3>
<p>AWS에서는 다양한 인스턴스 유형이 있으며, 각 유형은 메모리와 CPU의 비율이 다릅니다.</p>
<ul>
<li><strong>메모리 중심 인스턴스</strong>: <code>r</code> 계열 (<code>r5.large</code>, <code>r5.xlarge</code> 등)</li>
<li><strong>균형형 인스턴스</strong>: <code>t</code> 또는 <code>m</code> 계열 (<code>t3.large</code>, <code>m5.large</code> 등)</li>
</ul>
<p>AWS 인스턴스 유형에 대한 자세한 정보는 <a href="https://aws.amazon.com/ec2/instance-types/">AWS 공식 문서</a>를 참고하세요.</p>
<hr>
<h3 id="3-인스턴스-정지"><strong>3. 인스턴스 정지</strong><a hidden class="anchor" aria-hidden="true" href="#3-인스턴스-정지">#</a></h3>
<p>인스턴스 유형을 변경하려면 인스턴스를 일시적으로 정지해야 합니다.</p>
<ol>
<li>AWS Management Console에서 <strong>인스턴스</strong>를 선택.</li>
<li>상단 메뉴에서 <strong>인스턴스 상태</strong> &gt; <strong>인스턴스 중지</strong>를 클릭.</li>
<li>인스턴스가 정지될 때까지 기다립니다.</li>
</ol>
<hr>
<h3 id="4-인스턴스-유형-변경"><strong>4. 인스턴스 유형 변경</strong><a hidden class="anchor" aria-hidden="true" href="#4-인스턴스-유형-변경">#</a></h3>
<ol>
<li>
<p><strong>인스턴스 유형 수정</strong>:</p>
<ul>
<li>AWS Management Console에서 <strong>인스턴스</strong>를 선택.</li>
<li>상단 메뉴에서 <strong>인스턴스 설정</strong> &gt; <strong>인스턴스 유형 수정</strong>을 클릭.</li>
<li>원하는 인스턴스 유형(예: <code>t3.large</code>, <code>r5.xlarge</code> 등)을 선택.</li>
<li><strong>저장</strong>을 클릭.</li>
</ul>
</li>
<li>
<p><strong>명령어로 변경</strong>(CLI를 사용하는 경우):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 modify-instance-attribute --instance-id &lt;instance-id&gt; --instance-type &lt;new-instance-type&gt;
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="5-인스턴스-시작"><strong>5. 인스턴스 시작</strong><a hidden class="anchor" aria-hidden="true" href="#5-인스턴스-시작">#</a></h3>
<p>인스턴스 유형을 변경한 후, 인스턴스를 다시 시작합니다.</p>
<ol>
<li>AWS Management Console에서 <strong>인스턴스 상태</strong> &gt; <strong>인스턴스 시작</strong>을 클릭.</li>
<li>SSH로 접속하여 메모리가 증가했는지 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>free -h
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="6-확인-및-추가-작업"><strong>6. 확인 및 추가 작업</strong><a hidden class="anchor" aria-hidden="true" href="#6-확인-및-추가-작업">#</a></h3>
<ul>
<li>
<p><strong>스토리지 크기 확인</strong>:
인스턴스 유형 변경으로 스토리지 용량은 변경되지 않습니다. 필요한 경우 EBS 볼륨 크기를 늘려야 합니다.</p>
</li>
<li>
<p><strong>애플리케이션 구성 확인</strong>:
새 메모리를 활용하도록 애플리케이션 설정을 업데이트하세요.</p>
</li>
</ul>
<hr>
<h3 id="주의사항"><strong>주의사항</strong><a hidden class="anchor" aria-hidden="true" href="#주의사항">#</a></h3>
<ol>
<li><strong>중단 시간</strong>: 인스턴스 정지 및 시작으로 인한 중단 시간 발생.</li>
<li><strong>비용 증가</strong>: 더 큰 인스턴스 유형은 비용이 증가할 수 있으니 예산을 확인하세요.</li>
<li><strong>가용성 영역(AZ)</strong>: 새로운 인스턴스 유형이 현재 가용성 영역에서 지원되지 않을 수 있습니다. 다른 AZ로 이동해야 할 수도 있습니다.</li>
</ol>
<hr>
<h2 id="필요한-추가-정보나-문제가-있으면-알려주세요-">필요한 추가 정보나 문제가 있으면 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#필요한-추가-정보나-문제가-있으면-알려주세요-">#</a></h2>
<h1 id="aws-ec2에서-ubuntu를-사용-중일-때-현재-실행-중인-인스턴스의-유형-및-기타-정보를-확인">AWS EC2에서 Ubuntu를 사용 중일 때, 현재 실행 중인 인스턴스의 유형 및 기타 정보를 확인<a hidden class="anchor" aria-hidden="true" href="#aws-ec2에서-ubuntu를-사용-중일-때-현재-실행-중인-인스턴스의-유형-및-기타-정보를-확인">#</a></h1>
<p>AWS EC2에서 Ubuntu를 사용 중일 때, 현재 실행 중인 인스턴스의 유형 및 기타 정보를 확인하려면 다음 방법을 사용할 수 있습니다.</p>
<hr>
<h3 id="1-메타데이터-서비스-활용"><strong>1. 메타데이터 서비스 활용</strong><a hidden class="anchor" aria-hidden="true" href="#1-메타데이터-서비스-활용">#</a></h3>
<p>AWS EC2 인스턴스에서 실행 중인 메타데이터 서비스를 통해 인스턴스 유형을 확인할 수 있습니다.</p>
<ol>
<li>
<p><strong>현재 인스턴스 유형 확인</strong></p>
<ul>
<li>다음 명령어를 실행:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl http://169.254.169.254/latest/meta-data/instance-type
</span></span></code></pre></div></li>
<li>출력 예시:
<pre tabindex="0"><code>t2.micro
</code></pre></li>
</ul>
</li>
<li>
<p><strong>추가적인 메타데이터 정보 확인</strong></p>
<ul>
<li>현재 실행 중인 인스턴스 ID:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl http://169.254.169.254/latest/meta-data/instance-id
</span></span></code></pre></div></li>
<li>가용성 영역:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl http://169.254.169.254/latest/meta-data/placement/availability-zone
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-aws-cli-활용"><strong>2. AWS CLI 활용</strong><a hidden class="anchor" aria-hidden="true" href="#2-aws-cli-활용">#</a></h3>
<p>AWS CLI가 설치되어 있고, EC2 인스턴스에 적절한 IAM 역할이 연결되어 있거나 자격 증명이 설정되어 있다면 다음을 사용할 수 있습니다:</p>
<ol>
<li>
<p><strong>현재 인스턴스의 ID 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl http://169.254.169.254/latest/meta-data/instance-id
</span></span></code></pre></div><ul>
<li>출력 예시: <code>i-1234567890abcdef0</code></li>
</ul>
</li>
<li>
<p><strong>AWS CLI로 인스턴스 유형 확인</strong></p>
<ul>
<li>인스턴스 ID를 기반으로 AWS CLI 명령어 실행:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 describe-instances --instance-ids i-1234567890abcdef0 --query <span style="color:#e6db74">&#34;Reservations[].Instances[].InstanceType&#34;</span> --output text
</span></span></code></pre></div></li>
<li>출력 예시:
<pre tabindex="0"><code>t2.micro
</code></pre></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-시스템-파일-확인"><strong>3. 시스템 파일 확인</strong><a hidden class="anchor" aria-hidden="true" href="#3-시스템-파일-확인">#</a></h3>
<p>Ubuntu에서는 <code>/sys/devices/virtual/dmi/id</code> 디렉토리에서 인스턴스 정보를 확인할 수도 있습니다.</p>
<ol>
<li>
<p><strong>현재 인스턴스 유형 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /sys/devices/virtual/dmi/id/product_name
</span></span></code></pre></div><ul>
<li>출력 예시:
<pre tabindex="0"><code>t2.micro
</code></pre></li>
</ul>
</li>
<li>
<p><strong>인스턴스 ID 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /sys/devices/virtual/dmi/id/board_asset_tag
</span></span></code></pre></div><ul>
<li>출력 예시:
<pre tabindex="0"><code>i-1234567890abcdef0
</code></pre></li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-amazon-ec2-대시보드-확인"><strong>4. Amazon EC2 대시보드 확인</strong><a hidden class="anchor" aria-hidden="true" href="#4-amazon-ec2-대시보드-확인">#</a></h3>
<ol>
<li>AWS Management Console에 로그인.</li>
<li>EC2 대시보드로 이동.</li>
<li>실행 중인 인스턴스를 선택하여 <strong>인스턴스 유형</strong>을 확인.</li>
</ol>
<hr>
<h3 id="요약"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약">#</a></h3>
<ul>
<li><strong>빠른 확인</strong>: <code>curl http://169.254.169.254/latest/meta-data/instance-type</code></li>
<li><strong>추가 정보</strong>: AWS CLI 명령어를 활용하거나 메타데이터에서 추가 정보를 조회.</li>
</ul>
<p>이 방법들을 사용하면 인스턴스 유형과 기타 세부 정보를 쉽게 확인할 수 있습니다. 추가 질문이 있다면 알려주세요! 😊</p>
<hr>
<h1 id="메모리를-64gb로-늘리고-싶다면">메모리를 64GB로 늘리고 싶다면<a hidden class="anchor" aria-hidden="true" href="#메모리를-64gb로-늘리고-싶다면">#</a></h1>
<p>현재 사용 중인 인스턴스 유형 <strong>g4dn.2xlarge</strong>는 <strong>32GB 메모리</strong>를 제공합니다. 만약 메모리를 <strong>64GB</strong>로 늘리고 싶다면, 적합한 인스턴스 유형으로 변경해야 합니다. 아래는 64GB 메모리를 제공하는 AWS EC2 인스턴스의 몇 가지 옵션입니다.</p>
<hr>
<h3 id="64gb-메모리를-제공하는-주요-인스턴스-유형"><strong>64GB 메모리를 제공하는 주요 인스턴스 유형</strong><a hidden class="anchor" aria-hidden="true" href="#64gb-메모리를-제공하는-주요-인스턴스-유형">#</a></h3>
<h4 id="1-그래픽-처리가-중요한-경우-gpu-지원"><strong>1. 그래픽 처리가 중요한 경우 (GPU 지원)</strong><a hidden class="anchor" aria-hidden="true" href="#1-그래픽-처리가-중요한-경우-gpu-지원">#</a></h4>
<ul>
<li>
<p><strong>g4dn.4xlarge</strong></p>
<ul>
<li><strong>vCPU</strong>: 16</li>
<li><strong>메모리</strong>: 64GB</li>
<li><strong>GPU</strong>: NVIDIA T4 GPU 1개</li>
<li><strong>용도</strong>: 딥러닝, 머신러닝 추론, 그래픽 처리.</li>
</ul>
</li>
<li>
<p><strong>g5.2xlarge</strong></p>
<ul>
<li><strong>vCPU</strong>: 8</li>
<li><strong>메모리</strong>: 64GB</li>
<li><strong>GPU</strong>: NVIDIA A10G Tensor Core GPU 1개</li>
<li><strong>용도</strong>: 고성능 그래픽 및 머신러닝 워크로드.</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-메모리와-cpu가-균형-잡힌-작업용"><strong>2. 메모리와 CPU가 균형 잡힌 작업용</strong><a hidden class="anchor" aria-hidden="true" href="#2-메모리와-cpu가-균형-잡힌-작업용">#</a></h4>
<ul>
<li>
<p><strong>m5.4xlarge</strong></p>
<ul>
<li><strong>vCPU</strong>: 16</li>
<li><strong>메모리</strong>: 64GB</li>
<li><strong>용도</strong>: 웹 서버, 데이터베이스, 애플리케이션 서버 등 일반적인 워크로드.</li>
</ul>
</li>
<li>
<p><strong>m6i.4xlarge</strong></p>
<ul>
<li><strong>vCPU</strong>: 16</li>
<li><strong>메모리</strong>: 64GB</li>
<li><strong>용도</strong>: 최신 세대의 CPU를 사용하며, 더 나은 성능 제공.</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-메모리-집약적인-작업용"><strong>3. 메모리 집약적인 작업용</strong><a hidden class="anchor" aria-hidden="true" href="#3-메모리-집약적인-작업용">#</a></h4>
<ul>
<li>
<p><strong>r5.2xlarge</strong></p>
<ul>
<li><strong>vCPU</strong>: 8</li>
<li><strong>메모리</strong>: 64GB</li>
<li><strong>용도</strong>: 데이터베이스, 인메모리 캐싱, 고성능 데이터 처리.</li>
</ul>
</li>
<li>
<p><strong>r6i.2xlarge</strong></p>
<ul>
<li><strong>vCPU</strong>: 8</li>
<li><strong>메모리</strong>: 64GB</li>
<li><strong>용도</strong>: 메모리 집약적인 워크로드에 최적화.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="권장-인스턴스-유형"><strong>권장 인스턴스 유형</strong><a hidden class="anchor" aria-hidden="true" href="#권장-인스턴스-유형">#</a></h3>
<ul>
<li><strong>g4dn.4xlarge</strong>: 현재 GPU가 필요하고 메모리도 64GB로 증가시키려면 적합.</li>
<li><strong>m5.4xlarge</strong> 또는 <strong>m6i.4xlarge</strong>: GPU가 필요 없고, CPU와 메모리 간 균형이 필요한 경우.</li>
<li><strong>r5.2xlarge</strong> 또는 <strong>r6i.2xlarge</strong>: 메모리 사용량이 매우 높은 워크로드를 처리하는 데 최적.</li>
</ul>
<hr>
<h3 id="인스턴스-변경-방법"><strong>인스턴스 변경 방법</strong><a hidden class="anchor" aria-hidden="true" href="#인스턴스-변경-방법">#</a></h3>
<ol>
<li>
<p><strong>현재 인스턴스 정지</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 stop-instances --instance-ids &lt;instance-id&gt;
</span></span></code></pre></div></li>
<li>
<p><strong>인스턴스 유형 변경</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 modify-instance-attribute --instance-id &lt;instance-id&gt; --instance-type &lt;new-instance-type&gt;
</span></span></code></pre></div></li>
<li>
<p><strong>인스턴스 재시작</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 start-instances --instance-ids &lt;instance-id&gt;
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="비용-고려"><strong>비용 고려</strong><a hidden class="anchor" aria-hidden="true" href="#비용-고려">#</a></h3>
<p>64GB 메모리를 제공하는 인스턴스는 현재 인스턴스보다 비용이 더 높을 수 있습니다. AWS 공식 <a href="https://aws.amazon.com/ec2/pricing/">EC2 가격 페이지</a>에서 비용을 확인한 후 적합한 인스턴스를 선택하세요.</p>
<p>궁금한 점이나 추가 지원이 필요하면 알려주세요! 😊</p>
<hr>
<h1 id="인스턴스-유형을-변경할-때는-보통-os를-다시-설치할-필요는-없다">인스턴스 유형을 변경할 때는 보통 OS를 다시 설치할 필요는 없다<a hidden class="anchor" aria-hidden="true" href="#인스턴스-유형을-변경할-때는-보통-os를-다시-설치할-필요는-없다">#</a></h1>
<p>AWS에서 <strong>인스턴스 유형</strong>을 변경할 때는 보통 <strong>OS를 다시 설치할 필요는 없습니다</strong>. 변경 작업은 인스턴스의 하드웨어 스펙(메모리, CPU 등)을 변경하는 것이며, 기존에 사용하던 <strong>EBS 루트 볼륨</strong>과 데이터는 그대로 유지됩니다. 하지만 몇 가지 사항을 확인하고 조치해야 할 수도 있습니다.</p>
<hr>
<h3 id="1-os-재설치-여부"><strong>1. OS 재설치 여부</strong><a hidden class="anchor" aria-hidden="true" href="#1-os-재설치-여부">#</a></h3>
<ul>
<li><strong>OS 재설치 필요 없음</strong>: AWS EC2는 스토리지(EBS 볼륨)와 하드웨어를 분리해서 관리하기 때문에 인스턴스 유형 변경 시 OS와 데이터를 유지합니다.</li>
<li>기존 애플리케이션과 설정도 그대로 유지됩니다.</li>
</ul>
<hr>
<h3 id="2-확인해야-할-사항"><strong>2. 확인해야 할 사항</strong><a hidden class="anchor" aria-hidden="true" href="#2-확인해야-할-사항">#</a></h3>
<h4 id="21-현재-ami-호환성"><strong>2.1. 현재 AMI 호환성</strong><a hidden class="anchor" aria-hidden="true" href="#21-현재-ami-호환성">#</a></h4>
<p>AWS에서 사용하는 Amazon Machine Image(AMI)가 변경하려는 인스턴스 유형과 호환되는지 확인하세요. 예를 들어:</p>
<ul>
<li><strong>GPU 드라이버 및 소프트웨어</strong>:
<ul>
<li><code>g4dn</code>에서 사용하는 NVIDIA 드라이버가 새 인스턴스(<code>g4dn.4xlarge</code>)에서도 제대로 동작하는지 확인.</li>
<li>NVIDIA 드라이버를 최신 버전으로 유지하는 것이 좋습니다.</li>
</ul>
</li>
</ul>
<h4 id="22-네트워크-및-ip"><strong>2.2. 네트워크 및 IP</strong><a hidden class="anchor" aria-hidden="true" href="#22-네트워크-및-ip">#</a></h4>
<ul>
<li><strong>고정 IP</strong>: 인스턴스를 중지했다가 시작하면 퍼블릭 IP가 변경됩니다. 고정 IP를 사용하려면 <strong>Elastic IP</strong>를 연결해야 합니다.</li>
<li><strong>보안 그룹 및 네트워크 설정</strong>: 보안 그룹은 변경되지 않으므로 별도로 확인할 필요는 없습니다.</li>
</ul>
<h4 id="23-데이터"><strong>2.3. 데이터</strong><a hidden class="anchor" aria-hidden="true" href="#23-데이터">#</a></h4>
<ul>
<li>모든 데이터는 EBS 볼륨에 저장되므로 인스턴스 중지 후에도 데이터가 손실되지 않습니다. 그러나 중요한 데이터를 백업하는 것이 안전합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 create-snapshot --volume-id &lt;volume-id&gt; --description <span style="color:#e6db74">&#34;Backup before instance type change&#34;</span>
</span></span></code></pre></div></li>
</ul>
<h4 id="24-애플리케이션-호환성"><strong>2.4. 애플리케이션 호환성</strong><a hidden class="anchor" aria-hidden="true" href="#24-애플리케이션-호환성">#</a></h4>
<ul>
<li>변경된 메모리와 CPU 환경에서 애플리케이션이 올바르게 동작하는지 확인하세요.</li>
<li>GPU 인스턴스를 사용하는 경우, GPU 관련 라이브러리(CUDA, cuDNN 등)를 업데이트하는 것이 좋습니다.</li>
</ul>
<hr>
<h3 id="3-작업-순서"><strong>3. 작업 순서</strong><a hidden class="anchor" aria-hidden="true" href="#3-작업-순서">#</a></h3>
<ol>
<li>
<p><strong>인스턴스 중지</strong></p>
<ul>
<li>인스턴스를 변경하려면 먼저 인스턴스를 중지해야 합니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 stop-instances --instance-ids &lt;instance-id&gt;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>인스턴스 유형 변경</strong></p>
<ul>
<li>AWS Management Console:
<ul>
<li>EC2 대시보드 &gt; 인스턴스 선택 &gt; &ldquo;인스턴스 설정&rdquo; &gt; &ldquo;인스턴스 유형 수정&rdquo; 클릭.</li>
</ul>
</li>
<li>CLI:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 modify-instance-attribute --instance-id &lt;instance-id&gt; --instance-type g4dn.4xlarge
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>인스턴스 시작</strong></p>
<ul>
<li>변경 후 인스턴스를 다시 시작합니다.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 start-instances --instance-ids &lt;instance-id&gt;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>GPU 드라이버 확인</strong></p>
<ul>
<li>NVIDIA 드라이버를 다시 설치하거나 업데이트가 필요한 경우, 아래 명령으로 GPU 상태를 확인하세요:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nvidia-smi
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-추가-권장-작업"><strong>4. 추가 권장 작업</strong><a hidden class="anchor" aria-hidden="true" href="#4-추가-권장-작업">#</a></h3>
<ul>
<li><strong>EBS 볼륨 크기 확인</strong>: 메모리를 증가시키면서 스토리지 요구량이 커질 가능성이 있다면, EBS 볼륨 크기를 확장하세요.</li>
<li><strong>애플리케이션 테스트</strong>: 변경 후 애플리케이션이 제대로 동작하는지 테스트합니다.</li>
</ul>
<hr>
<h3 id="결론"><strong>결론</strong><a hidden class="anchor" aria-hidden="true" href="#결론">#</a></h3>
<ul>
<li>OS를 다시 설치하거나 추가적인 복잡한 작업은 필요하지 않습니다.</li>
<li>NVIDIA 드라이버 및 GPU 관련 설정만 확인하거나 업데이트하는 정도로 충분합니다.</li>
<li>안전을 위해 데이터를 백업한 뒤 변경 작업을 진행하세요.</li>
</ul>
<h2 id="추가적으로-필요한-사항이-있으면-언제든지-알려주세요-">추가적으로 필요한 사항이 있으면 언제든지 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#추가적으로-필요한-사항이-있으면-언제든지-알려주세요-">#</a></h2>
<h1 id="g4dn2xlarge와-g4dn4xlarge의-가격을-비교">g4dn.2xlarge와 g4dn.4xlarge의 가격을 비교<a hidden class="anchor" aria-hidden="true" href="#g4dn2xlarge와-g4dn4xlarge의-가격을-비교">#</a></h1>
<h3 id="인스턴스-사양-비교"><strong>인스턴스 사양 비교</strong><a hidden class="anchor" aria-hidden="true" href="#인스턴스-사양-비교">#</a></h3>
<table>
  <thead>
      <tr>
          <th>인스턴스 유형</th>
          <th>vCPU</th>
          <th>메모리 (GiB)</th>
          <th>GPU</th>
          <th>네트워크 대역폭 (Gbps)</th>
          <th>로컬 스토리지 (GB)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>g4dn.2xlarge</td>
          <td>8</td>
          <td>32</td>
          <td>NVIDIA T4 1개</td>
          <td>최대 25</td>
          <td>225</td>
      </tr>
      <tr>
          <td>g4dn.4xlarge</td>
          <td>16</td>
          <td>64</td>
          <td>NVIDIA T4 1개</td>
          <td>최대 25</td>
          <td>225</td>
      </tr>
  </tbody>
</table>
<h3 id="가격-비교"><strong>가격 비교</strong><a hidden class="anchor" aria-hidden="true" href="#가격-비교">#</a></h3>
<p>두 인스턴스의 시간당 요금은 다음과 같습니다:</p>
<table>
  <thead>
      <tr>
          <th>인스턴스 유형</th>
          <th>온디맨드 요금 (시간당)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>g4dn.2xlarge</td>
          <td>$0.752</td>
      </tr>
      <tr>
          <td>g4dn.4xlarge</td>
          <td>$1.204</td>
      </tr>
  </tbody>
</table>
<p><strong>참고</strong>: 요금은 리전 및 사용 조건에 따라 다를 수 있으므로, 정확한 가격은 <a href="https://aws.amazon.com/ko/ec2/pricing/on-demand/">AWS 공식 온디맨드 요금 페이지</a>를 확인하시기 바랍니다.</p>
<h3 id="요약-1"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-1">#</a></h3>
<ul>
<li><strong>g4dn.2xlarge</strong>: 8 vCPU, 32 GiB 메모리, 시간당 $0.752</li>
<li><strong>g4dn.4xlarge</strong>: 16 vCPU, 64 GiB 메모리, 시간당 $1.204</li>
</ul>
<p>따라서, g4dn.4xlarge 인스턴스는 g4dn.2xlarge에 비해 두 배의 vCPU와 메모리를 제공하며, 시간당 요금은 약 1.6배 높습니다.</p>
<p><strong>주의사항</strong>: AWS 요금은 리전, 예약 옵션, 구매 옵션 등에 따라 변동될 수 있으므로, 사용 전에 반드시 최신 정보를 확인하시기 바랍니다.</p>
<hr>
<h1 id="ec2-인스턴스에서-stop과-terminate의-차이점">EC2 인스턴스에서 Stop과 Terminate의 차이점<a hidden class="anchor" aria-hidden="true" href="#ec2-인스턴스에서-stop과-terminate의-차이점">#</a></h1>
<h3 id="ec2-인스턴스에서-stop과-terminate의-차이점-1"><strong>EC2 인스턴스에서 Stop과 Terminate의 차이점</strong><a hidden class="anchor" aria-hidden="true" href="#ec2-인스턴스에서-stop과-terminate의-차이점-1">#</a></h3>
<p>AWS EC2에서 <strong>Stop</strong>과 <strong>Terminate</strong>는 인스턴스 상태를 관리하는 두 가지 주요 옵션입니다. 아래는 두 옵션의 차이점과 비용 관련 사항을 설명합니다.</p>
<hr>
<h3 id="1-stop-중지"><strong>1. Stop (중지)</strong><a hidden class="anchor" aria-hidden="true" href="#1-stop-중지">#</a></h3>
<h4 id="동작"><strong>동작</strong><a hidden class="anchor" aria-hidden="true" href="#동작">#</a></h4>
<ul>
<li>인스턴스를 <strong>중지</strong>하면 운영 체제가 정상적으로 종료되고 인스턴스의 상태가 <code>stopped</code>로 변경됩니다.</li>
<li>EBS 볼륨(루트 볼륨 포함)은 삭제되지 않고 유지됩니다.</li>
<li>중지 상태에서는 하드웨어 리소스(CPU, 메모리 등)는 할당되지 않습니다.</li>
<li>다시 시작할 경우 기존의 인스턴스 ID와 함께 인스턴스가 재시작됩니다. 하지만 <strong>퍼블릭 IP 주소는 변경</strong>됩니다.</li>
</ul>
<h4 id="비용"><strong>비용</strong><a hidden class="anchor" aria-hidden="true" href="#비용">#</a></h4>
<ul>
<li><strong>비용 발생</strong>:
<ul>
<li><strong>스토리지(EBS 볼륨)</strong>: 인스턴스를 중지해도 EBS 볼륨은 유지되므로 저장 비용이 계속 발생합니다.</li>
<li>예: 루트 볼륨 + 추가 EBS 볼륨 크기에 따라 월별 비용 청구.</li>
</ul>
</li>
<li><strong>비용 중단</strong>:
<ul>
<li>CPU, 메모리, 네트워크 리소스는 사용하지 않으므로 이에 대한 비용은 발생하지 않습니다.</li>
</ul>
</li>
</ul>
<h4 id="적용-시나리오"><strong>적용 시나리오</strong><a hidden class="anchor" aria-hidden="true" href="#적용-시나리오">#</a></h4>
<ul>
<li>임시로 인스턴스를 사용하지 않을 때 중지하여 비용을 절감하고, 이후 동일한 데이터를 사용하여 재시작하려는 경우.</li>
</ul>
<hr>
<h3 id="2-terminate-종료"><strong>2. Terminate (종료)</strong><a hidden class="anchor" aria-hidden="true" href="#2-terminate-종료">#</a></h3>
<h4 id="동작-1"><strong>동작</strong><a hidden class="anchor" aria-hidden="true" href="#동작-1">#</a></h4>
<ul>
<li>인스턴스를 <strong>종료</strong>하면 인스턴스가 완전히 삭제되며, 상태가 <code>terminated</code>로 변경됩니다.</li>
<li>기본적으로 루트 볼륨은 삭제되고, 추가로 연결된 EBS 볼륨은 <strong>삭제 설정 여부에 따라</strong> 유지되거나 삭제됩니다.</li>
<li>종료된 인스턴스는 복구할 수 없으며, 재시작이 불가능합니다.</li>
</ul>
<h4 id="비용-1"><strong>비용</strong><a hidden class="anchor" aria-hidden="true" href="#비용-1">#</a></h4>
<ul>
<li><strong>비용 중단</strong>:
<ul>
<li>인스턴스와 관련된 모든 하드웨어 리소스(CPU, 메모리 등)에 대한 비용이 중단됩니다.</li>
<li>기본 설정에 따라 루트 볼륨이 삭제되므로 <strong>스토리지 비용도 더 이상 발생하지 않습니다</strong>.</li>
</ul>
</li>
<li><strong>추가 스토리지</strong>:
<ul>
<li>연결된 EBS 볼륨이 삭제되지 않은 경우, 해당 볼륨의 스토리지 비용은 계속 발생합니다.</li>
</ul>
</li>
</ul>
<h4 id="적용-시나리오-1"><strong>적용 시나리오</strong><a hidden class="anchor" aria-hidden="true" href="#적용-시나리오-1">#</a></h4>
<ul>
<li>인스턴스를 더 이상 사용하지 않고, 데이터를 보존할 필요가 없거나 이미 백업된 경우.</li>
</ul>
<hr>
<h3 id="3-stop과-terminate의-차이점-요약"><strong>3. Stop과 Terminate의 차이점 요약</strong><a hidden class="anchor" aria-hidden="true" href="#3-stop과-terminate의-차이점-요약">#</a></h3>
<table>
  <thead>
      <tr>
          <th><strong>기능</strong></th>
          <th><strong>Stop (중지)</strong></th>
          <th><strong>Terminate (종료)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>인스턴스 상태</strong></td>
          <td>중지 상태로 유지, 이후 재시작 가능</td>
          <td>인스턴스가 삭제되며 복구 불가능</td>
      </tr>
      <tr>
          <td><strong>EBS 볼륨</strong></td>
          <td>루트 볼륨 및 추가 볼륨이 유지됨</td>
          <td>루트 볼륨은 기본적으로 삭제, 추가 볼륨은 설정에 따라 유지 가능</td>
      </tr>
      <tr>
          <td><strong>퍼블릭 IP 주소</strong></td>
          <td>재시작 시 새로운 퍼블릭 IP 주소 할당</td>
          <td>종료 시 퍼블릭 IP 주소와 모든 네트워크 리소스 삭제</td>
      </tr>
      <tr>
          <td><strong>비용</strong></td>
          <td>EBS 스토리지 비용 발생</td>
          <td>모든 비용 중단 (EBS 볼륨이 삭제되지 않은 경우 비용 발생)</td>
      </tr>
      <tr>
          <td><strong>재시작 가능 여부</strong></td>
          <td>재시작 가능</td>
          <td>불가능</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="4-비용-차이"><strong>4. 비용 차이</strong><a hidden class="anchor" aria-hidden="true" href="#4-비용-차이">#</a></h3>
<ul>
<li><strong>Stop 상태</strong>:
<ul>
<li>CPU, 메모리 등의 사용량 비용은 발생하지 않음.</li>
<li><strong>스토리지(EBS 볼륨)</strong>: 스토리지 크기와 IOPS에 따라 비용 발생.
<ul>
<li>예: 루트 볼륨 30GB의 EBS gp2 볼륨은 약 $3~4/월.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Terminate 상태</strong>:
<ul>
<li>모든 비용이 중단되지만, 추가로 연결된 EBS 볼륨이 삭제되지 않으면 해당 볼륨에 대해 비용이 계속 발생.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-선택-가이드"><strong>5. 선택 가이드</strong><a hidden class="anchor" aria-hidden="true" href="#5-선택-가이드">#</a></h3>
<table>
  <thead>
      <tr>
          <th><strong>상황</strong></th>
          <th><strong>권장 액션</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>인스턴스를 임시로 사용하지 않는 경우</td>
          <td><strong>Stop</strong></td>
      </tr>
      <tr>
          <td>인스턴스를 더 이상 사용하지 않는 경우</td>
          <td><strong>Terminate</strong></td>
      </tr>
      <tr>
          <td>데이터를 유지하면서 비용을 줄이려는 경우</td>
          <td>Stop 후 추가 EBS 볼륨 확인 및 필요 시 스냅샷 백업.</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="추가적으로-비용-계산이나-설정-관련-질문이-있다면-언제든-문의해주세요-">추가적으로 비용 계산이나 설정 관련 질문이 있다면 언제든 문의해주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#추가적으로-비용-계산이나-설정-관련-질문이-있다면-언제든-문의해주세요-">#</a></h2>
<h1 id="ec2-인스턴스-유형을-변경한-후-ssh로-로그인할-수-없는-문제">EC2 인스턴스 유형을 변경한 후 SSH로 로그인할 수 없는 문제<a hidden class="anchor" aria-hidden="true" href="#ec2-인스턴스-유형을-변경한-후-ssh로-로그인할-수-없는-문제">#</a></h1>
<p>EC2 인스턴스 유형을 변경한 후 SSH로 로그인할 수 없는 문제는 여러 가지 원인에서 발생할 수 있습니다. 아래에서 가능한 원인, 해결 방법, SSH 디버깅 명령어, 그리고 제공된 <code>sshfs</code> 명령어와 관련된 수정 방안을 설명합니다.</p>
<hr>
<h2 id="1-가능한-원인"><strong>1. 가능한 원인</strong><a hidden class="anchor" aria-hidden="true" href="#1-가능한-원인">#</a></h2>
<ol>
<li>
<p><strong>네트워크 설정 문제</strong>:</p>
<ul>
<li>변경된 인스턴스가 다른 가용성 영역(AZ)으로 이동했을 가능성이 있음.</li>
<li>보안 그룹에서 SSH(포트 22)에 대한 인바운드 규칙이 제대로 설정되지 않았을 수 있음.</li>
<li>Elastic IP가 설정되어 있지 않아 퍼블릭 IP가 변경되었을 가능성.</li>
</ul>
</li>
<li>
<p><strong>스토리지 연결 문제</strong>:</p>
<ul>
<li>루트 EBS 볼륨이 손상되었거나, 부팅에 실패했을 수 있음.</li>
</ul>
</li>
<li>
<p><strong>SSH 구성 문제</strong>:</p>
<ul>
<li><code>authorized_keys</code>가 삭제되었거나, 올바르지 않은 퍼미션 문제로 인해 SSH가 차단되었을 수 있음.</li>
</ul>
</li>
<li>
<p><strong>변경된 인스턴스 유형과 드라이버 호환성 문제</strong>:</p>
<ul>
<li>GPU 드라이버 등 특정 하드웨어에 의존적인 설정이 문제를 일으킬 수 있음.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-문제-해결-방법"><strong>2. 문제 해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#2-문제-해결-방법">#</a></h2>
<h3 id="21-네트워크-설정-확인"><strong>2.1. 네트워크 설정 확인</strong><a hidden class="anchor" aria-hidden="true" href="#21-네트워크-설정-확인">#</a></h3>
<ol>
<li>
<p><strong>퍼블릭 IP 확인</strong>:</p>
<ul>
<li>EC2 대시보드에서 새 퍼블릭 IP를 확인합니다. SSH 시 올바른 IP를 사용하고 있는지 확인하세요.</li>
<li>Elastic IP를 사용하고 있지 않다면, IP가 변경되었을 가능성이 큽니다.</li>
</ul>
</li>
<li>
<p><strong>보안 그룹 확인</strong>:</p>
<ul>
<li>EC2 대시보드 &gt; <strong>보안 그룹</strong> &gt; 인스턴스에 연결된 보안 그룹 확인.</li>
<li>SSH(포트 22)에 대한 인바운드 규칙이 아래와 같이 설정되어야 합니다:
<pre tabindex="0"><code>Type: SSH
Protocol: TCP
Port Range: 22
Source: 0.0.0.0/0 (또는 특정 IP)
</code></pre></li>
</ul>
</li>
<li>
<p><strong>Network ACL 확인</strong>:</p>
<ul>
<li>서브넷의 네트워크 ACL이 SSH 트래픽을 허용하는지 확인하세요.</li>
<li>아웃바운드 및 인바운드 규칙 모두 포트 22를 허용해야 합니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="22-스토리지-및-시스템-설정-확인"><strong>2.2. 스토리지 및 시스템 설정 확인</strong><a hidden class="anchor" aria-hidden="true" href="#22-스토리지-및-시스템-설정-확인">#</a></h3>
<ol>
<li>
<p><strong>EBS 볼륨 확인</strong>:</p>
<ul>
<li>EC2 대시보드에서 인스턴스의 **루트 볼륨(EBS)**이 연결되어 있는지 확인.</li>
<li>루트 볼륨이 연결되지 않았거나 손상된 경우, 동일한 볼륨을 새 인스턴스에 연결하여 복구 작업을 진행합니다.</li>
</ul>
</li>
<li>
<p><strong><code>authorized_keys</code> 확인</strong>:</p>
<ul>
<li>SSH가 실패하는 경우, <code>~/.ssh/authorized_keys</code> 파일이 손상되었을 수 있습니다.</li>
<li>EBS 볼륨을 다른 인스턴스에 연결하여 아래 파일을 확인하세요:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /home/ubuntu/.ssh/authorized_keys
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="23-ssh-디버깅"><strong>2.3. SSH 디버깅</strong><a hidden class="anchor" aria-hidden="true" href="#23-ssh-디버깅">#</a></h3>
<p>로컬에서 SSH 연결 문제를 디버깅하려면 다음 명령어를 사용하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i ~/jonpark-ec2.pem -vvv ubuntu@&lt;your-ec2-public-ip&gt;
</span></span></code></pre></div><ul>
<li><strong><code>-vvv</code> 옵션</strong>: SSH 연결의 디버깅 정보를 상세히 출력합니다.</li>
<li><strong>디버깅 결과 분석</strong>:
<ul>
<li><code>Permission denied</code>:
<ul>
<li><code>authorized_keys</code> 파일이 없거나 퍼미션이 잘못된 경우.</li>
</ul>
</li>
<li><code>Connection timed out</code>:
<ul>
<li>네트워크 문제(보안 그룹, ACL 등) 또는 인스턴스가 종료된 경우.</li>
</ul>
</li>
<li><code>No route to host</code>:
<ul>
<li>잘못된 IP를 사용했거나 네트워크 연결 문제가 있는 경우.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-sshfs-명령어-관련"><strong>3. SSHFS 명령어 관련</strong><a hidden class="anchor" aria-hidden="true" href="#3-sshfs-명령어-관련">#</a></h2>
<p>제공된 <code>sshfs</code> 명령어를 사용하면서 문제를 겪고 있다면, 아래 항목을 확인하세요.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshfs -o uid<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>id -u jonpark<span style="color:#66d9ef">)</span> -o gid<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>id -g jonpark<span style="color:#66d9ef">)</span> -o allow_other ubuntu@&lt;your-ec2-public-ip&gt;:/home/ubuntu -o IdentityFile<span style="color:#f92672">=</span>~/jonpark-ec2.pem ~/work_ec2
</span></span></code></pre></div><h3 id="확인-사항"><strong>확인 사항</strong><a hidden class="anchor" aria-hidden="true" href="#확인-사항">#</a></h3>
<ol>
<li>
<p><strong>올바른 퍼블릭 IP 사용</strong>:</p>
<ul>
<li>EC2의 퍼블릭 IP 주소를 <code>jonpark-ec2</code> 부분 대신 명시적으로 사용하세요.</li>
</ul>
</li>
<li>
<p><strong>보안 그룹</strong>:</p>
<ul>
<li>SSHFS도 포트 22를 사용하므로, 보안 그룹의 SSH 인바운드 규칙이 제대로 설정되어야 합니다.</li>
</ul>
</li>
<li>
<p><strong>디렉토리 권한</strong>:</p>
<ul>
<li>로컬의 <code>~/work_ec2</code> 디렉토리가 존재하고, 쓰기 권한이 있는지 확인합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p ~/work_ec2
</span></span><span style="display:flex;"><span>chmod <span style="color:#ae81ff">755</span> ~/work_ec2
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>디버깅 명령</strong>:</p>
<ul>
<li>SSHFS 연결 문제를 디버깅하려면 아래 명령어를 사용:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshfs -o uid<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>id -u jonpark<span style="color:#66d9ef">)</span> -o gid<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>id -g jonpark<span style="color:#66d9ef">)</span> -o allow_other ubuntu@&lt;your-ec2-public-ip&gt;:/home/ubuntu -o IdentityFile<span style="color:#f92672">=</span>~/jonpark-ec2.pem ~/work_ec2 -d
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-최종-복구-절차"><strong>4. 최종 복구 절차</strong><a hidden class="anchor" aria-hidden="true" href="#4-최종-복구-절차">#</a></h2>
<p>만약 위 방법으로도 문제를 해결하지 못했다면, 아래 단계를 따라 복구 작업을 수행합니다:</p>
<ol>
<li>
<p><strong>EBS 볼륨 분리 및 새 인스턴스에 연결</strong>:</p>
<ul>
<li>문제 인스턴스의 루트 볼륨을 분리하고, 새 인스턴스에 연결.</li>
<li>새 인스턴스에서 해당 볼륨을 마운트하여 <code>authorized_keys</code> 또는 기타 설정을 복구.</li>
</ul>
</li>
<li>
<p><strong>기본 설정 복구</strong>:</p>
<ul>
<li><code>~/.ssh/authorized_keys</code> 파일을 올바른 SSH 키로 복구.</li>
<li><code>chmod 600 ~/.ssh/authorized_keys</code>로 권한 설정.</li>
</ul>
</li>
<li>
<p><strong>인스턴스 재부팅</strong>:</p>
<ul>
<li>복구된 루트 볼륨을 원래 인스턴스에 다시 연결하고 재부팅:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 reboot-instances --instance-ids &lt;instance-id&gt;
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-요약"><strong>5. 요약</strong><a hidden class="anchor" aria-hidden="true" href="#5-요약">#</a></h2>
<ol>
<li><strong>SSH 로그인 문제 해결</strong>:
<ul>
<li>네트워크 설정(보안 그룹, IP 주소 등) 확인.</li>
<li><code>authorized_keys</code> 복구 및 권한 확인.</li>
</ul>
</li>
<li><strong>SSH 디버깅</strong>:
<ul>
<li><code>ssh -vvv</code> 또는 <code>sshfs -d</code>를 사용하여 연결 문제를 분석.</li>
</ul>
</li>
<li><strong>루트 볼륨 복구</strong>:
<ul>
<li>EBS 볼륨을 다른 인스턴스에 연결하여 설정 복구.</li>
</ul>
</li>
</ol>
<h2 id="추가적으로-궁금한-점이나-진행-중-문제가-있다면-알려주세요-">추가적으로 궁금한 점이나 진행 중 문제가 있다면 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#추가적으로-궁금한-점이나-진행-중-문제가-있다면-알려주세요-">#</a></h2>
<h1 id="connection-refused">Connection refused<a hidden class="anchor" aria-hidden="true" href="#connection-refused">#</a></h1>
<p><code>Connection refused</code> 오류는 SSH가 EC2 인스턴스의 <strong>포트 22</strong>로 연결을 시도했지만, 해당 연결이 거부된 것을 의미합니다. 이 문제는 주로 네트워크 설정, SSH 데몬 서비스, 또는 EC2 인스턴스 상태와 관련이 있습니다.</p>
<hr>
<h2 id="1-주요-원인"><strong>1. 주요 원인</strong><a hidden class="anchor" aria-hidden="true" href="#1-주요-원인">#</a></h2>
<h3 id="11-네트워크-문제"><strong>1.1. 네트워크 문제</strong><a hidden class="anchor" aria-hidden="true" href="#11-네트워크-문제">#</a></h3>
<ul>
<li><strong>보안 그룹 설정 문제</strong>:
<ul>
<li>EC2의 보안 그룹이 SSH(포트 22)에 대한 인바운드 트래픽을 허용하지 않는 경우.</li>
</ul>
</li>
<li><strong>퍼블릭 IP 문제</strong>:
<ul>
<li>인스턴스의 퍼블릭 IP가 변경되었는데, 올바르지 않은 IP로 연결을 시도한 경우.</li>
</ul>
</li>
</ul>
<h3 id="12-ssh-데몬-문제"><strong>1.2. SSH 데몬 문제</strong><a hidden class="anchor" aria-hidden="true" href="#12-ssh-데몬-문제">#</a></h3>
<ul>
<li>SSH 데몬(<code>sshd</code>)이 인스턴스에서 실행 중이지 않거나, 제대로 구성되지 않은 경우.</li>
<li><code>/etc/ssh/sshd_config</code> 설정이 잘못되어 SSH 연결이 차단된 경우.</li>
</ul>
<h3 id="13-인스턴스-문제"><strong>1.3. 인스턴스 문제</strong><a hidden class="anchor" aria-hidden="true" href="#13-인스턴스-문제">#</a></h3>
<ul>
<li>EC2 인스턴스가 네트워크 인터페이스를 제대로 연결하지 못했거나, 부팅에 실패한 경우.</li>
</ul>
<hr>
<h2 id="2-해결-방법"><strong>2. 해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#2-해결-방법">#</a></h2>
<h3 id="21-네트워크-설정-확인-1"><strong>2.1. 네트워크 설정 확인</strong><a hidden class="anchor" aria-hidden="true" href="#21-네트워크-설정-확인-1">#</a></h3>
<ol>
<li>
<p><strong>보안 그룹 설정</strong>:</p>
<ul>
<li>EC2 인스턴스의 보안 그룹에서 SSH(포트 22)에 대한 규칙이 설정되어 있는지 확인.</li>
<li>AWS 콘솔에서 <strong>EC2 대시보드</strong> &gt; <strong>보안 그룹</strong> &gt; <strong>인바운드 규칙</strong>을 확인:
<pre tabindex="0"><code>Type: SSH
Protocol: TCP
Port Range: 22
Source: 0.0.0.0/0 (또는 특정 IP 범위)
</code></pre></li>
</ul>
</li>
<li>
<p><strong>퍼블릭 IP 확인</strong>:</p>
<ul>
<li>인스턴스의 퍼블릭 IP가 올바른지 확인. AWS 콘솔에서 퍼블릭 IP를 확인하고, <code>ssh</code> 명령에서 올바른 IP를 사용:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i ~/jonpark-ec2.pem ubuntu@&lt;correct-public-ip&gt;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Network ACL 설정 확인</strong>:</p>
<ul>
<li>서브넷의 네트워크 ACL이 포트 22에 대한 트래픽을 허용하는지 확인.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="22-인스턴스-상태-확인"><strong>2.2. 인스턴스 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#22-인스턴스-상태-확인">#</a></h3>
<ol>
<li>
<p><strong>EC2 상태 확인</strong>:</p>
<ul>
<li>AWS 콘솔에서 해당 인스턴스의 상태 확인:
<ul>
<li>**상태 검사(Status Check)**가 통과되었는지 확인.</li>
<li>&ldquo;2/2 checks passed&rdquo; 상태인지 확인.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>인스턴스 부팅 문제 확인</strong>:</p>
<ul>
<li>AWS 콘솔에서 EC2 인스턴스를 선택 &gt; **시스템 로그 보기(View System Log)**를 클릭.</li>
<li>부팅 로그에서 오류 메시지(특히 SSH 관련 오류)를 확인.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="23-ssh-데몬-문제-해결"><strong>2.3. SSH 데몬 문제 해결</strong><a hidden class="anchor" aria-hidden="true" href="#23-ssh-데몬-문제-해결">#</a></h3>
<p>만약 네트워크 설정이 올바른데도 문제가 지속된다면, SSH 데몬이 제대로 동작하지 않을 수 있습니다. SSH 데몬 관련 문제를 해결하려면 EBS 볼륨을 분리하여 문제를 진단해야 합니다.</p>
<h4 id="ebs-볼륨-분리-및-복구"><strong>EBS 볼륨 분리 및 복구</strong><a hidden class="anchor" aria-hidden="true" href="#ebs-볼륨-분리-및-복구">#</a></h4>
<ol>
<li>
<p><strong>루트 볼륨 분리</strong>:</p>
<ul>
<li>AWS 콘솔에서 문제 인스턴스의 <strong>루트 볼륨</strong>을 다른 임시 인스턴스에 연결.</li>
</ul>
</li>
<li>
<p><strong>볼륨 마운트</strong>:</p>
<ul>
<li>새 인스턴스에 연결된 볼륨을 마운트:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir /mnt/recovery
</span></span><span style="display:flex;"><span>sudo mount /dev/xvdf1 /mnt/recovery
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>SSH 설정 파일 확인 및 수정</strong>:</p>
<ul>
<li>SSH 설정 파일이 올바른지 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /mnt/recovery/etc/ssh/sshd_config
</span></span></code></pre></div></li>
<li>아래 항목들이 제대로 설정되어 있는지 확인:
<pre tabindex="0"><code>Port 22
PermitRootLogin yes
PasswordAuthentication yes
</code></pre></li>
</ul>
</li>
<li>
<p><strong><code>authorized_keys</code> 파일 확인</strong>:</p>
<ul>
<li>SSH 키가 제대로 설정되어 있는지 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /mnt/recovery/home/ubuntu/.ssh/authorized_keys
</span></span></code></pre></div></li>
<li>SSH 키가 삭제되었거나 잘못되었다면 다시 추가.</li>
</ul>
</li>
<li>
<p><strong>볼륨 재연결 및 재부팅</strong>:</p>
<ul>
<li>수정한 볼륨을 원래 인스턴스에 다시 연결하고 인스턴스를 재부팅.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="24-ssh-디버깅-명령"><strong>2.4. SSH 디버깅 명령</strong><a hidden class="anchor" aria-hidden="true" href="#24-ssh-디버깅-명령">#</a></h3>
<p>다음 명령으로 SSH 연결 상태를 다시 확인하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i ~/jonpark-ec2.pem -vvv ubuntu@&lt;public-ip&gt;
</span></span></code></pre></div><h4 id="디버깅-메시지-분석"><strong>디버깅 메시지 분석</strong><a hidden class="anchor" aria-hidden="true" href="#디버깅-메시지-분석">#</a></h4>
<ul>
<li><strong><code>Connection refused</code></strong>:
<ul>
<li>보안 그룹 설정 문제, SSH 데몬이 비활성화된 경우.</li>
</ul>
</li>
<li><strong><code>Connection timed out</code></strong>:
<ul>
<li>네트워크 설정 또는 인스턴스 상태 문제.</li>
</ul>
</li>
<li><strong><code>Permission denied</code></strong>:
<ul>
<li><code>authorized_keys</code> 파일 문제 또는 SSH 키 불일치.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-sshfs와-관련된-수정"><strong>3. SSHFS와 관련된 수정</strong><a hidden class="anchor" aria-hidden="true" href="#3-sshfs와-관련된-수정">#</a></h3>
<p>SSH 연결이 복구되면, 기존 <code>sshfs</code> 명령어를 다음과 같이 수정하여 재사용하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshfs -o uid<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>id -u jonpark<span style="color:#66d9ef">)</span> -o gid<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>id -g jonpark<span style="color:#66d9ef">)</span> -o allow_other ubuntu@&lt;public-ip&gt;:/home/ubuntu -o IdentityFile<span style="color:#f92672">=</span>~/jonpark-ec2.pem ~/work_ec2
</span></span></code></pre></div><hr>
<h3 id="4-최종-요약"><strong>4. 최종 요약</strong><a hidden class="anchor" aria-hidden="true" href="#4-최종-요약">#</a></h3>
<ol>
<li><strong>Connection refused 해결</strong>:
<ul>
<li>보안 그룹, 퍼블릭 IP, 네트워크 ACL 확인.</li>
<li>SSH 데몬 및 인스턴스 상태 확인.</li>
</ul>
</li>
<li><strong>SSH 디버깅 명령</strong>:
<ul>
<li><code>ssh -vvv</code>를 사용해 원인 분석.</li>
</ul>
</li>
<li><strong>EBS 복구</strong>:
<ul>
<li>루트 볼륨을 분리하여 SSH 설정 파일(<code>sshd_config</code>) 및 키를 복구.</li>
</ul>
</li>
</ol>
<h2 id="문제를-해결하지-못했거나-추가적인-지원이-필요하면-언제든-알려주세요-">문제를 해결하지 못했거나 추가적인 지원이 필요하면 언제든 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#문제를-해결하지-못했거나-추가적인-지원이-필요하면-언제든-알려주세요-">#</a></h2>
<h1 id="x11-forwarding">X11 Forwarding<a hidden class="anchor" aria-hidden="true" href="#x11-forwarding">#</a></h1>
<p>AWS EC2에 SSH로 접근하고 <strong>X11 Forwarding</strong>을 활성화하여 MobaXterm에서 X Windows 애플리케이션을 실행하려면 EC2 인스턴스의 SSH 서버 설정(<code>/etc/ssh/sshd_config</code>)을 수정해야 합니다.</p>
<hr>
<h3 id="1-etcsshsshd_config-수정"><strong>1. <code>/etc/ssh/sshd_config</code> 수정</strong><a hidden class="anchor" aria-hidden="true" href="#1-etcsshsshd_config-수정">#</a></h3>
<ol>
<li>
<p><strong>SSH 설정 파일 열기</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/ssh/sshd_config
</span></span></code></pre></div></li>
<li>
<p><strong>X11 포워딩 관련 설정 확인 및 수정</strong>:
아래 항목들을 찾아 수정하거나 추가하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>X11Forwarding yes
</span></span><span style="display:flex;"><span>X11DisplayOffset 10
</span></span><span style="display:flex;"><span>X11UseLocalhost yes
</span></span></code></pre></div><ul>
<li><strong><code>X11Forwarding yes</code></strong>: X11 포워딩을 활성화.</li>
<li><strong><code>X11DisplayOffset 10</code></strong>: X11 디스플레이를 기본적으로 <code>10</code>번부터 할당.</li>
<li><strong><code>X11UseLocalhost yes</code></strong>: 로컬호스트만 X11 연결을 허용(보안 강화).</li>
</ul>
</li>
<li>
<p><strong>기타 옵션 확인</strong>:
아래 옵션이 올바르게 설정되어 있는지 확인하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>AllowTcpForwarding yes
</span></span><span style="display:flex;"><span>PermitRootLogin no
</span></span></code></pre></div><ul>
<li><code>AllowTcpForwarding yes</code>: X11 포워딩에 필요.</li>
</ul>
</li>
<li>
<p><strong>파일 저장 및 종료</strong>:</p>
<ul>
<li><code>Ctrl+O</code> &gt; <code>Enter</code> &gt; <code>Ctrl+X</code>로 저장 후 종료.</li>
</ul>
</li>
<li>
<p><strong>SSH 데몬 재시작</strong>:
변경 사항을 적용하려면 SSH 서비스를 재시작합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="2-x11-포워딩을-위한-필수-소프트웨어-설치"><strong>2. X11 포워딩을 위한 필수 소프트웨어 설치</strong><a hidden class="anchor" aria-hidden="true" href="#2-x11-포워딩을-위한-필수-소프트웨어-설치">#</a></h3>
<p>EC2 인스턴스에서 X11 애플리케이션을 실행하려면 X11 라이브러리를 설치해야 합니다.</p>
<h4 id="ubuntudebian"><strong>Ubuntu/Debian</strong><a hidden class="anchor" aria-hidden="true" href="#ubuntudebian">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install -y xauth x11-apps
</span></span></code></pre></div><h4 id="amazon-linux-2"><strong>Amazon Linux 2</strong><a hidden class="anchor" aria-hidden="true" href="#amazon-linux-2">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo yum update -y
</span></span><span style="display:flex;"><span>sudo yum install -y xauth xorg-x11-apps
</span></span></code></pre></div><hr>
<h3 id="3-mobaxterm에서-ssh-연결-설정"><strong>3. MobaXterm에서 SSH 연결 설정</strong><a hidden class="anchor" aria-hidden="true" href="#3-mobaxterm에서-ssh-연결-설정">#</a></h3>
<ol>
<li>
<p><strong>새 세션 생성</strong>:</p>
<ul>
<li>MobaXterm에서 <strong>Session</strong> 버튼을 클릭.</li>
<li><strong>SSH</strong>를 선택.</li>
</ul>
</li>
<li>
<p><strong>EC2 인스턴스 정보 입력</strong>:</p>
<ul>
<li>Remote host: EC2의 퍼블릭 IP 주소.</li>
<li>Specify username: <code>ubuntu</code>(또는 사용 중인 계정).</li>
<li>Use private key: EC2 인스턴스에 연결하는 PEM 파일 지정(예: <code>~/jonpark-ec2.pem</code>).</li>
</ul>
</li>
<li>
<p><strong>X11 포워딩 활성화</strong>:</p>
<ul>
<li>&ldquo;Advanced SSH settings&rdquo; 탭을 선택.</li>
<li><strong>X11-Forwarding</strong> 옵션 체크.</li>
</ul>
</li>
<li>
<p><strong>연결 테스트</strong>:</p>
<ul>
<li>세션을 저장하고 연결합니다.</li>
<li>연결 후, X11 애플리케이션 테스트:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>xclock
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-문제-해결"><strong>4. 문제 해결</strong><a hidden class="anchor" aria-hidden="true" href="#4-문제-해결">#</a></h3>
<ol>
<li>
<p><strong><code>DISPLAY</code> 환경 변수 확인</strong>:
SSH로 연결된 후, 아래 명령을 실행해 <code>DISPLAY</code> 환경 변수가 설정되어 있는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo $DISPLAY
</span></span></code></pre></div><ul>
<li>정상 출력 예시:
<pre tabindex="0"><code>localhost:10.0
</code></pre></li>
<li>설정되어 있지 않다면 수동으로 설정:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export DISPLAY<span style="color:#f92672">=</span>localhost:10.0
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>SSH 로그 확인</strong>:</p>
<ul>
<li>SSH 연결 문제나 X11 포워딩 문제 발생 시 <code>/var/log/auth.log</code> 또는 <code>/var/log/secure</code> 파일을 확인하세요:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo tail -f /var/log/auth.log
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>방화벽 확인</strong>:</p>
<ul>
<li>X11 포워딩은 기본적으로 SSH 포트(22번)를 사용하므로, 방화벽 규칙에 문제가 없는지 확인.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-요약-1"><strong>5. 요약</strong><a hidden class="anchor" aria-hidden="true" href="#5-요약-1">#</a></h3>
<ol>
<li><code>/etc/ssh/sshd_config</code> 수정:
<ul>
<li><code>X11Forwarding yes</code></li>
<li><code>X11UseLocalhost yes</code></li>
</ul>
</li>
<li>SSH 서비스 재시작: <code>sudo systemctl restart sshd</code></li>
<li>인스턴스에 X11 관련 패키지 설치: <code>xauth</code>, <code>x11-apps</code></li>
<li>MobaXterm에서 <strong>X11-Forwarding</strong> 옵션 활성화.</li>
</ol>
<p>위 설정을 적용하면 EC2 인스턴스에서 X11 애플리케이션을 실행할 수 있습니다. 문제가 있으면 알려주세요! 😊</p>
<hr>
<h1 id="ssh를-어디서나-접근-가능하도록-설정">SSH를 어디서나 접근 가능하도록 설정<a hidden class="anchor" aria-hidden="true" href="#ssh를-어디서나-접근-가능하도록-설정">#</a></h1>
<p>AWS EC2 인스턴스에서 <strong>SSH를 어디서나 접근 가능하도록 설정하려면</strong>, 보안 그룹과 SSH 설정 파일(<code>/etc/ssh/sshd_config</code>)을 적절히 변경해야 합니다. 다만, 이는 보안 위험을 증가시킬 수 있으므로 신중히 설정하고 필요할 경우 추가적인 보안 조치를 적용해야 합니다.</p>
<hr>
<h3 id="1-보안-그룹-설정-변경"><strong>1. 보안 그룹 설정 변경</strong><a hidden class="anchor" aria-hidden="true" href="#1-보안-그룹-설정-변경">#</a></h3>
<p>AWS 보안 그룹에서 SSH(포트 22)에 대한 <strong>인바운드 규칙</strong>을 다음과 같이 수정합니다:</p>
<ol>
<li>AWS Management Console에 로그인하고 <strong>EC2 대시보드</strong>로 이동.</li>
<li>해당 인스턴스의 <strong>보안 그룹</strong>을 클릭.</li>
<li><strong>인바운드 규칙</strong> 탭에서 <strong>규칙 편집</strong> 클릭.</li>
<li>다음과 같이 SSH(포트 22) 규칙 추가:
<pre tabindex="0"><code>Type: SSH
Protocol: TCP
Port Range: 22
Source: 0.0.0.0/0
</code></pre><ul>
<li><strong><code>0.0.0.0/0</code></strong>: 모든 IP 주소에서 접근 가능.</li>
<li>보안 강화가 필요할 경우 특정 IP 대역(예: <code>192.168.1.0/24</code>)만 허용하도록 설정.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-ssh-설정-파일-변경"><strong>2. SSH 설정 파일 변경</strong><a hidden class="anchor" aria-hidden="true" href="#2-ssh-설정-파일-변경">#</a></h3>
<p><code>/etc/ssh/sshd_config</code> 파일에서 SSH 접근을 전 세계에서 허용하도록 설정을 조정합니다.</p>
<ol>
<li>
<p><strong>설정 파일 열기</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/ssh/sshd_config
</span></span></code></pre></div></li>
<li>
<p><strong>수정할 항목</strong>:</p>
<ul>
<li>
<p><strong>포트 설정</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Port 22
</span></span></code></pre></div><ul>
<li>기본 포트(22)를 유지하거나, 보안을 위해 다른 포트(예: 2222)로 변경할 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>허용된 IP 확인</strong>:
아래 설정이 있는 경우 주석 처리하거나 삭제하여 모든 IP에서 접근을 허용합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>AllowUsers ubuntu@192.168.1.*
</span></span></code></pre></div><p>→ 주석 처리:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#AllowUsers ubuntu@192.168.1.*
</span></span></code></pre></div></li>
<li>
<p><strong>루트 로그인 허용 여부</strong>:
보안상 루트 로그인은 비활성화 상태를 유지하는 것이 좋습니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>PermitRootLogin no
</span></span></code></pre></div></li>
<li>
<p><strong>암호 인증</strong>:
키 기반 인증이 아닌 암호 인증을 허용하려면 설정을 변경:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>PasswordAuthentication yes
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>파일 저장 및 SSH 서비스 재시작</strong>:</p>
<ul>
<li>파일 저장 후 SSH 서비스를 재시작합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-방화벽-확인"><strong>3. 방화벽 확인</strong><a hidden class="anchor" aria-hidden="true" href="#3-방화벽-확인">#</a></h3>
<ol>
<li>
<p><strong>Ubuntu UFW 방화벽 사용 시</strong>:
SSH 트래픽을 허용하려면:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo ufw allow 22/tcp
</span></span><span style="display:flex;"><span>sudo ufw reload
</span></span></code></pre></div></li>
<li>
<p><strong>Amazon Linux 2 또는 다른 배포판에서 iptables 사용 시</strong>:
SSH 트래픽을 허용하는 규칙을 추가:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo iptables -A INPUT -p tcp --dport <span style="color:#ae81ff">22</span> -j ACCEPT
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="4-보안-강화"><strong>4. 보안 강화</strong><a hidden class="anchor" aria-hidden="true" href="#4-보안-강화">#</a></h3>
<p>어디서나 접근할 수 있도록 허용하면 보안 위험이 증가할 수 있으므로, 다음과 같은 추가적인 보안 조치를 적용하는 것이 좋습니다:</p>
<ol>
<li>
<p><strong>SSH 키 기반 인증 사용</strong>:</p>
<ul>
<li><code>PasswordAuthentication no</code>로 설정하여 암호 인증 비활성화.</li>
<li>키 기반 인증만 허용.</li>
</ul>
</li>
<li>
<p><strong>Fail2Ban 설치</strong>:</p>
<ul>
<li>SSH 브루트포스 공격 방어를 위해 <code>fail2ban</code> 설치:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install fail2ban
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>포트 변경</strong>:</p>
<ul>
<li>기본 포트(22) 대신 비표준 포트(예: 2222) 사용:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Port 2222
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>IP 제한</strong>:</p>
<ul>
<li>특정 IP 또는 IP 대역만 허용:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>AllowUsers ubuntu@192.168.1.0/24
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>SSH 연결 시간 제한</strong>:</p>
<ul>
<li>비활성 SSH 세션을 자동으로 종료하도록 설정:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ClientAliveInterval 300
</span></span><span style="display:flex;"><span>ClientAliveCountMax 0
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="요약-2"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-2">#</a></h3>
<ol>
<li>AWS 보안 그룹에서 SSH(22) 포트를 <code>0.0.0.0/0</code>로 허용.</li>
<li><code>/etc/ssh/sshd_config</code>에서 필요에 따라 설정 변경.</li>
<li>보안을 위해 키 기반 인증, Fail2Ban, 비표준 포트 사용 등의 추가 조치를 적용.</li>
</ol>
<h2 id="위-설정을-적용한-후에도-문제가-발생하거나-추가적인-설정이-필요하면-알려주세요-">위 설정을 적용한 후에도 문제가 발생하거나 추가적인 설정이 필요하면 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#위-설정을-적용한-후에도-문제가-발생하거나-추가적인-설정이-필요하면-알려주세요-">#</a></h2>
<h1 id="해결책--sudo-systemctl-restart-sshd">해결책 : sudo systemctl restart sshd<a hidden class="anchor" aria-hidden="true" href="#해결책--sudo-systemctl-restart-sshd">#</a></h1>
<p>네, <strong><code>sudo systemctl restart sshd</code></strong> 명령어는 SSH 설정을 수정한 후 변경 사항을 적용하는 데 필수적입니다. 하지만 SSH 설정 수정 후 재시작 시 발생할 수 있는 문제를 방지하거나 해결하기 위한 추가적인 주의사항도 함께 살펴보겠습니다.</p>
<hr>
<h3 id="1-문제-상황"><strong>1. 문제 상황</strong><a hidden class="anchor" aria-hidden="true" href="#1-문제-상황">#</a></h3>
<ul>
<li>SSH 설정 파일(<code>/etc/ssh/sshd_config</code>)을 수정한 후 재시작해야 할 때, 설정이 잘못되었거나 SSH 데몬이 중단되면 SSH 접속이 차단될 수 있습니다.</li>
<li>특히 AWS EC2 인스턴스처럼 원격으로 접속하는 환경에서는 SSH 데몬을 재시작할 때 문제가 발생하면 복구 작업이 까다로워질 수 있습니다.</li>
</ul>
<hr>
<h3 id="2-수정-방법"><strong>2. 수정 방법</strong><a hidden class="anchor" aria-hidden="true" href="#2-수정-방법">#</a></h3>
<h4 id="21-ssh-설정-파일-문법-확인"><strong>2.1. SSH 설정 파일 문법 확인</strong><a hidden class="anchor" aria-hidden="true" href="#21-ssh-설정-파일-문법-확인">#</a></h4>
<p>SSH 데몬을 재시작하기 전에 설정 파일의 문법 오류를 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshd -t
</span></span></code></pre></div><ul>
<li>오류가 없으면 아무 출력도 나타나지 않습니다.</li>
<li>문법 오류가 있을 경우 오류 메시지가 출력됩니다. 예:
<pre tabindex="0"><code>/etc/ssh/sshd_config line 10: Bad configuration option: XYZ
</code></pre></li>
<li>오류가 있다면 설정 파일을 다시 열어 수정합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/ssh/sshd_config
</span></span></code></pre></div></li>
</ul>
<h4 id="22-ssh-데몬-재시작"><strong>2.2. SSH 데몬 재시작</strong><a hidden class="anchor" aria-hidden="true" href="#22-ssh-데몬-재시작">#</a></h4>
<p>문법 확인 후 SSH 데몬을 재시작하여 변경 사항을 적용합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div><h4 id="23-서비스-상태-확인"><strong>2.3. 서비스 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#23-서비스-상태-확인">#</a></h4>
<p>SSH 서비스가 정상적으로 동작 중인지 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status sshd
</span></span></code></pre></div><ul>
<li>정상 동작 중이라면 아래와 비슷한 출력이 나타납니다:
<pre tabindex="0"><code>Active: active (running) since ...
</code></pre></li>
</ul>
<hr>
<h3 id="3-재시작-후-ssh-접속-불가-문제-방지"><strong>3. 재시작 후 SSH 접속 불가 문제 방지</strong><a hidden class="anchor" aria-hidden="true" href="#3-재시작-후-ssh-접속-불가-문제-방지">#</a></h3>
<h4 id="31-기존-ssh-세션-유지"><strong>3.1. 기존 SSH 세션 유지</strong><a hidden class="anchor" aria-hidden="true" href="#31-기존-ssh-세션-유지">#</a></h4>
<ul>
<li>SSH 설정을 수정하고 테스트할 때는 기존의 SSH 세션을 종료하지 마세요.</li>
<li>SSH 데몬이 올바르게 재시작되었는지 확인한 후 기존 세션을 종료합니다.</li>
</ul>
<h4 id="32-포트-22-외-추가-포트-열기"><strong>3.2. 포트 22 외 추가 포트 열기</strong><a hidden class="anchor" aria-hidden="true" href="#32-포트-22-외-추가-포트-열기">#</a></h4>
<ul>
<li>
<p>기본 포트(22)를 변경하거나 설정을 테스트하기 전에, 다른 포트를 열어 백업 접속 경로를 마련합니다. 예:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Port 22
</span></span><span style="display:flex;"><span>Port 2222
</span></span></code></pre></div></li>
<li>
<p>보안 그룹에서 새 포트(예: 2222)를 허용한 후 SSH 데몬을 재시작합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div></li>
<li>
<p>이후 새 포트로 접속 테스트:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i &lt;key.pem&gt; -p <span style="color:#ae81ff">2222</span> ubuntu@&lt;ec2-public-ip&gt;
</span></span></code></pre></div></li>
</ul>
<h4 id="33-ec2-인스턴스-복구-방법"><strong>3.3. EC2 인스턴스 복구 방법</strong><a hidden class="anchor" aria-hidden="true" href="#33-ec2-인스턴스-복구-방법">#</a></h4>
<ul>
<li>SSH 재시작 후 연결이 끊긴 경우:
<ol>
<li>AWS 콘솔에서 EC2의 루트 볼륨을 분리.</li>
<li>새 인스턴스에 연결하여 <code>/etc/ssh/sshd_config</code>를 복구.</li>
<li>원래 인스턴스에 루트 볼륨을 다시 연결.</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-최종-요약-1"><strong>4. 최종 요약</strong><a hidden class="anchor" aria-hidden="true" href="#4-최종-요약-1">#</a></h3>
<ol>
<li>SSH 설정 파일 수정 후 반드시 문법 오류 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshd -t
</span></span></code></pre></div></li>
<li>SSH 데몬 재시작:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div></li>
<li>문제가 발생하지 않도록 백업</li>
</ol>
<hr>
<h1 id="failed-to-restart-sshdservice">Failed to restart sshd.service<a hidden class="anchor" aria-hidden="true" href="#failed-to-restart-sshdservice">#</a></h1>
<p><code>Failed to restart sshd.service</code> 오류는 시스템이 현재 <strong>비상 모드(emergency mode)</strong> 또는 <strong>복구 모드(rescue mode)</strong> 상태에 있을 때 발생할 수 있습니다. 이 모드는 시스템에 심각한 문제가 있을 때 활성화되며, 기본적으로 대부분의 서비스가 중단됩니다.</p>
<p>아래는 이 문제를 해결하기 위한 단계입니다.</p>
<hr>
<h2 id="1-현재-상태-확인"><strong>1. 현재 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-현재-상태-확인">#</a></h2>
<p>먼저, 시스템이 비상 모드 또는 복구 모드에 있는지 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl get-default
</span></span></code></pre></div><ul>
<li><strong>출력 예시</strong>:
<ul>
<li><code>emergency.target</code>: 시스템이 비상 모드에 있음.</li>
<li><code>rescue.target</code>: 시스템이 복구 모드에 있음.</li>
<li><code>multi-user.target</code> 또는 <code>graphical.target</code>: 정상 모드.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-시스템이-비상-모드에-있는-경우-해결-방법"><strong>2. 시스템이 비상 모드에 있는 경우 해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#2-시스템이-비상-모드에-있는-경우-해결-방법">#</a></h2>
<h3 id="21-현재-모드에서-ssh-재시작-불가-이유"><strong>2.1. 현재 모드에서 SSH 재시작 불가 이유</strong><a hidden class="anchor" aria-hidden="true" href="#21-현재-모드에서-ssh-재시작-불가-이유">#</a></h3>
<ul>
<li>비상 모드에서는 <code>emergency.target</code>이 활성화되며, 대부분의 서비스가 중단되거나 제한됩니다.</li>
<li>이 상태에서 <code>sshd.service</code>를 재시작하려고 하면 충돌이 발생합니다.</li>
</ul>
<hr>
<h3 id="22-기본-모드로-전환"><strong>2.2. 기본 모드로 전환</strong><a hidden class="anchor" aria-hidden="true" href="#22-기본-모드로-전환">#</a></h3>
<p>정상 모드로 전환해야 SSH 서비스와 관련된 작업을 수행할 수 있습니다.</p>
<ol>
<li>
<p><strong>시스템 기본 타겟을 multi-user.target으로 전환</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl set-default multi-user.target
</span></span><span style="display:flex;"><span>sudo systemctl isolate multi-user.target
</span></span></code></pre></div></li>
<li>
<p><strong>SSH 데몬 재시작</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div></li>
<li>
<p><strong>시스템 상태 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status sshd
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="3-비상-모드에서-직접-ssh-서비스-활성화"><strong>3. 비상 모드에서 직접 SSH 서비스 활성화</strong><a hidden class="anchor" aria-hidden="true" href="#3-비상-모드에서-직접-ssh-서비스-활성화">#</a></h2>
<p>만약 시스템을 정상 모드로 전환하지 않고 SSH 서비스를 다시 시작하려면 강제로 시작해야 합니다.</p>
<ol>
<li>
<p><strong>SSH 데몬 강제 시작</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl start sshd.service
</span></span></code></pre></div></li>
<li>
<p><strong>강제 재시작</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd.service --force
</span></span></code></pre></div></li>
<li>
<p><strong>서비스 상태 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status sshd.service
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="4-로그-확인"><strong>4. 로그 확인</strong><a hidden class="anchor" aria-hidden="true" href="#4-로그-확인">#</a></h2>
<p>SSH 서비스가 여전히 시작되지 않으면, 시스템 로그를 확인하여 문제의 원인을 파악해야 합니다.</p>
<h3 id="41-ssh-관련-로그-확인"><strong>4.1. SSH 관련 로그 확인</strong><a hidden class="anchor" aria-hidden="true" href="#41-ssh-관련-로그-확인">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>journalctl -u sshd.service
</span></span></code></pre></div><ul>
<li>최근 SSH 관련 오류 메시지가 출력됩니다.</li>
</ul>
<h3 id="42-시스템-전체-로그-확인"><strong>4.2. 시스템 전체 로그 확인</strong><a hidden class="anchor" aria-hidden="true" href="#42-시스템-전체-로그-확인">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dmesg | grep ssh
</span></span><span style="display:flex;"><span>sudo tail -f /var/log/syslog
</span></span></code></pre></div><hr>
<h2 id="5-루트-원인-해결"><strong>5. 루트 원인 해결</strong><a hidden class="anchor" aria-hidden="true" href="#5-루트-원인-해결">#</a></h2>
<h3 id="51-비상-모드의-원인-해결"><strong>5.1. 비상 모드의 원인 해결</strong><a hidden class="anchor" aria-hidden="true" href="#51-비상-모드의-원인-해결">#</a></h3>
<ul>
<li>비상 모드의 원인을 파악하기 위해 시스템 로그를 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>journalctl -xb
</span></span></code></pre></div></li>
<li>디스크 마운트 실패, 파일 시스템 손상, 잘못된 설정 등 비상 모드를 유발한 이유를 해결해야 합니다.</li>
</ul>
<h3 id="52-디스크-확인-및-복구"><strong>5.2. 디스크 확인 및 복구</strong><a hidden class="anchor" aria-hidden="true" href="#52-디스크-확인-및-복구">#</a></h3>
<ul>
<li>파일 시스템 문제가 의심되면 아래 명령으로 복구:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo fsck -f /
</span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="6-최종-점검"><strong>6. 최종 점검</strong><a hidden class="anchor" aria-hidden="true" href="#6-최종-점검">#</a></h2>
<p>모든 작업 후, 시스템의 기본 모드를 다시 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl get-default
</span></span></code></pre></div><p>시스템이 정상 모드(<code>multi-user.target</code> 또는 <code>graphical.target</code>)에 있어야 하며, SSH 서비스가 정상적으로 동작해야 합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status sshd
</span></span></code></pre></div><hr>
<p>문제가 해결되지 않거나 추가 지원이 필요하면 알려주세요! 😊</p>
<hr>
<h1 id="aws-ec2의-ubuntu-인스턴스를-바로-재시작하려면">AWS EC2의 Ubuntu 인스턴스를 바로 재시작하려면<a hidden class="anchor" aria-hidden="true" href="#aws-ec2의-ubuntu-인스턴스를-바로-재시작하려면">#</a></h1>
<p>AWS EC2의 Ubuntu 인스턴스를 바로 재시작하려면 다음 방법 중 하나를 사용할 수 있습니다.</p>
<hr>
<h3 id="1-cli에서-재시작-명령-사용"><strong>1. CLI에서 재시작 명령 사용</strong><a hidden class="anchor" aria-hidden="true" href="#1-cli에서-재시작-명령-사용">#</a></h3>
<h4 id="11-시스템-내에서-재시작"><strong>1.1. 시스템 내에서 재시작</strong><a hidden class="anchor" aria-hidden="true" href="#11-시스템-내에서-재시작">#</a></h4>
<p>SSH로 EC2 인스턴스에 접속한 상태라면 아래 명령어로 시스템을 바로 재시작할 수 있습니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo reboot
</span></span></code></pre></div><ul>
<li>이 명령은 즉시 재시작을 수행하며, 사용 중인 모든 연결(예: SSH 세션)이 종료됩니다.</li>
<li>재시작 후 몇 분 동안 SSH 접속이 불가능할 수 있으므로 기다려야 합니다.</li>
</ul>
<hr>
<h3 id="2-aws-management-console에서-재시작"><strong>2. AWS Management Console에서 재시작</strong><a hidden class="anchor" aria-hidden="true" href="#2-aws-management-console에서-재시작">#</a></h3>
<p>AWS Management Console에서 EC2 인스턴스를 재시작할 수도 있습니다:</p>
<ol>
<li><strong>AWS 콘솔에 로그인</strong>: <a href="https://aws.amazon.com/console/">AWS Management Console</a>에 접속합니다.</li>
<li><strong>EC2 대시보드로 이동</strong>: <strong>EC2 &gt; 인스턴스 &gt; 실행 중인 인스턴스</strong>로 이동.</li>
<li><strong>인스턴스 선택</strong>: 재시작하려는 인스턴스를 선택.</li>
<li><strong>인스턴스 상태 &gt; 인스턴스 재시작</strong> 클릭:
<ul>
<li>AWS 콘솔에서 인스턴스를 재시작하면 동일한 퍼블릭 IP가 유지됩니다(Elastic IP 사용 시).</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-aws-cli를-사용한-재시작"><strong>3. AWS CLI를 사용한 재시작</strong><a hidden class="anchor" aria-hidden="true" href="#3-aws-cli를-사용한-재시작">#</a></h3>
<p>AWS CLI가 설정되어 있다면 EC2 인스턴스를 명령어로 재시작할 수 있습니다:</p>
<ol>
<li>
<p><strong>인스턴스 ID 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 describe-instances --filters <span style="color:#e6db74">&#34;Name=tag:Name,Values=&lt;your-instance-name&gt;&#34;</span> --query <span style="color:#e6db74">&#34;Reservations[*].Instances[*].InstanceId&#34;</span> --output text
</span></span></code></pre></div></li>
<li>
<p><strong>인스턴스 재시작</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 reboot-instances --instance-ids &lt;instance-id&gt;
</span></span></code></pre></div></li>
<li>
<p><strong>재시작 상태 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>aws ec2 describe-instance-status --instance-ids &lt;instance-id&gt;
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="4-긴급-재시작-강제-재부팅"><strong>4. 긴급 재시작 (강제 재부팅)</strong><a hidden class="anchor" aria-hidden="true" href="#4-긴급-재시작-강제-재부팅">#</a></h3>
<p>만약 일반적인 <code>reboot</code> 명령어로 재시작이 불가능한 경우(예: 시스템이 멈춤), 강제로 재부팅하려면 아래 명령어를 사용합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#ae81ff">1</span> | sudo tee /proc/sys/kernel/sysrq
</span></span><span style="display:flex;"><span>echo b | sudo tee /proc/sysrq-trigger
</span></span></code></pre></div><ul>
<li><strong>주의</strong>: 이 방법은 시스템을 강제로 재부팅하므로, 데이터 손실 위험이 있을 수 있습니다.</li>
</ul>
<hr>
<h3 id="5-재시작-후-상태-확인"><strong>5. 재시작 후 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#5-재시작-후-상태-확인">#</a></h3>
<p>재시작 후 EC2 인스턴스가 정상적으로 부팅되었는지 확인하려면:</p>
<ol>
<li>
<p><strong>AWS 콘솔에서 상태 검사 확인</strong>:</p>
<ul>
<li>EC2 대시보드에서 **상태 검사(Status Checks)**가 &ldquo;2/2 checks passed&rdquo; 상태인지 확인.</li>
</ul>
</li>
<li>
<p><strong>SSH 접속 확인</strong>:</p>
<ul>
<li>인스턴스에 SSH로 다시 접속:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i ~/path-to-key.pem ubuntu@&lt;public-ip&gt;
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="추가-주의-사항"><strong>추가 주의 사항</strong><a hidden class="anchor" aria-hidden="true" href="#추가-주의-사항">#</a></h3>
<ul>
<li><strong>Elastic IP 사용 여부</strong>:
<ul>
<li>퍼블릭 IP가 변경되지 않으려면 Elastic IP를 사용해야 합니다.</li>
</ul>
</li>
<li><strong>실시간 데이터 백업</strong>:
<ul>
<li>재시작 전에 중요한 데이터를 백업하세요.</li>
</ul>
</li>
<li><strong>정상 종료</strong>:
<ul>
<li>일반적으로 <code>sudo reboot</code> 명령으로 종료/재시작하는 것이 안전합니다.</li>
</ul>
</li>
</ul>
<h2 id="필요한-추가-사항이-있으면-알려주세요-">필요한 추가 사항이 있으면 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#필요한-추가-사항이-있으면-알려주세요-">#</a></h2>
<h1 id="ssh-서비스가-inactive-dead-상태">SSH 서비스가 &ldquo;inactive (dead)&rdquo; 상태<a hidden class="anchor" aria-hidden="true" href="#ssh-서비스가-inactive-dead-상태">#</a></h1>
<p>EC2 Ubuntu 인스턴스에서 SSH 서비스가 &ldquo;inactive (dead)&rdquo; 상태로 표시되는 문제는 SSH 서버가 비활성화된 상태를 나타냅니다. 이 문제를 해결하려면 SSH 서비스를 활성화하고, 관련 로그를 확인하여 원인을 파악해야 합니다.</p>
<hr>
<h2 id="문제-해결-방법"><strong>문제 해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#문제-해결-방법">#</a></h2>
<h3 id="1-ssh-서비스-상태-확인"><strong>1. SSH 서비스 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-ssh-서비스-상태-확인">#</a></h3>
<p>SSH 서비스가 비활성화된 이유를 파악하려면 다음 명령어를 실행합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo journalctl -xe
</span></span></code></pre></div><p>이 명령어는 최근 시스템 로그를 출력하며, SSH 서비스가 비활성화된 이유를 확인하는 데 유용합니다.</p>
<hr>
<h3 id="2-ssh-서비스-활성화"><strong>2. SSH 서비스 활성화</strong><a hidden class="anchor" aria-hidden="true" href="#2-ssh-서비스-활성화">#</a></h3>
<p>SSH 서비스를 다시 활성화하려면 아래 단계를 따릅니다:</p>
<ol>
<li>
<p><strong>SSH 서비스 시작</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl start sshd
</span></span></code></pre></div></li>
<li>
<p><strong>서비스 상태 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status sshd
</span></span></code></pre></div><p>정상적으로 실행 중이라면 다음과 비슷한 출력이 나타납니다:</p>
<pre tabindex="0"><code>Active: active (running) since ...
</code></pre></li>
<li>
<p><strong>SSH 서비스 활성화 (부팅 시 자동 실행)</strong>
만약 SSH 서비스가 비활성화되어 있다면 부팅 시 자동으로 시작되도록 활성화합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl enable sshd
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="3-ssh-데몬-구성-확인"><strong>3. SSH 데몬 구성 확인</strong><a hidden class="anchor" aria-hidden="true" href="#3-ssh-데몬-구성-확인">#</a></h3>
<p><code>/etc/ssh/sshd_config</code> 파일에서 SSH 데몬 설정이 올바른지 확인합니다:</p>
<ol>
<li>
<p><strong>설정 파일 열기</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/ssh/sshd_config
</span></span></code></pre></div></li>
<li>
<p><strong>다음 설정이 포함되어 있는지 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Port 22
</span></span><span style="display:flex;"><span>PermitRootLogin prohibit-password
</span></span><span style="display:flex;"><span>PasswordAuthentication yes
</span></span></code></pre></div></li>
<li>
<p><strong>파일 저장 후 종료</strong></p>
<ul>
<li><code>Ctrl+O</code> → <code>Enter</code> → <code>Ctrl+X</code>로 저장 후 나옵니다.</li>
</ul>
</li>
<li>
<p><strong>SSH 데몬 설정 재확인</strong>
설정 파일의 문법 오류를 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshd -t
</span></span></code></pre></div><ul>
<li>오류가 없다면 출력이 없습니다.</li>
<li>오류가 있다면 메시지가 표시됩니다. 예를 들어:
<pre tabindex="0"><code>/etc/ssh/sshd_config line 10: Bad configuration option: XYZ
</code></pre></li>
</ul>
</li>
<li>
<p><strong>SSH 서비스 재시작</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="4-ssh-관련-로그-확인"><strong>4. SSH 관련 로그 확인</strong><a hidden class="anchor" aria-hidden="true" href="#4-ssh-관련-로그-확인">#</a></h3>
<p>만약 위 단계를 따라도 SSH 서비스가 실행되지 않으면 로그를 확인하여 더 자세한 원인을 파악합니다:</p>
<ol>
<li>
<p><strong>SSH 서비스 로그 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo journalctl -u sshd
</span></span></code></pre></div></li>
<li>
<p><strong>시스템 로그 확인</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo tail -n <span style="color:#ae81ff">50</span> /var/log/syslog
</span></span></code></pre></div></li>
<li>
<p><strong>로그에서 다음을 확인</strong></p>
<ul>
<li>포트 충돌: &ldquo;Address already in use&rdquo;</li>
<li>구성 오류: &ldquo;sshd_config: bad configuration&rdquo;</li>
<li>권한 문제: &ldquo;Permission denied&rdquo;</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-ec2-관련-추가-확인"><strong>5. EC2 관련 추가 확인</strong><a hidden class="anchor" aria-hidden="true" href="#5-ec2-관련-추가-확인">#</a></h3>
<ol>
<li>
<p><strong>보안 그룹 설정 확인</strong></p>
<ul>
<li>SSH(포트 22)가 EC2 인스턴스의 보안 그룹에서 허용되는지 확인합니다:
<pre tabindex="0"><code>Type: SSH
Protocol: TCP
Port Range: 22
Source: 0.0.0.0/0 (또는 특정 IP)
</code></pre></li>
</ul>
</li>
<li>
<p><strong>네트워크 ACL 확인</strong></p>
<ul>
<li>서브넷의 네트워크 ACL이 SSH 트래픽을 허용하는지 확인.</li>
</ul>
</li>
<li>
<p><strong>Elastic IP 확인</strong></p>
<ul>
<li>EC2 인스턴스의 퍼블릭 IP가 변경되지 않았는지 확인하고, 올바른 IP로 접속 시도.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-ebs-볼륨-복구-심각한-경우"><strong>6. EBS 볼륨 복구 (심각한 경우)</strong><a hidden class="anchor" aria-hidden="true" href="#6-ebs-볼륨-복구-심각한-경우">#</a></h3>
<p>만약 SSH 서비스가 복구되지 않고 인스턴스에 접근할 수 없으면 EBS 볼륨을 다른 인스턴스에 연결하여 설정을 수정해야 할 수도 있습니다:</p>
<ol>
<li>
<p><strong>EBS 볼륨 분리 및 다른 인스턴스에 연결</strong></p>
<ul>
<li>문제 인스턴스의 루트 볼륨을 새 인스턴스에 연결.</li>
</ul>
</li>
<li>
<p><strong>SSH 설정 복구</strong></p>
<ul>
<li>새 인스턴스에서 <code>/etc/ssh/sshd_config</code>를 수정.</li>
</ul>
</li>
<li>
<p><strong>루트 볼륨 재연결</strong></p>
<ul>
<li>수정한 볼륨을 원래 인스턴스에 다시 연결.</li>
</ul>
</li>
<li>
<p><strong>인스턴스 시작</strong></p>
</li>
</ol>
<hr>
<h3 id="7-최종-점검"><strong>7. 최종 점검</strong><a hidden class="anchor" aria-hidden="true" href="#7-최종-점검">#</a></h3>
<ul>
<li>
<p>SSH 서비스가 정상 실행 상태인지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status sshd
</span></span></code></pre></div></li>
<li>
<p>EC2 퍼블릭 IP로 SSH 접속 시도:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i ~/your-key.pem ubuntu@&lt;ec2-public-ip&gt;
</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="추가-지원"><strong>추가 지원</strong><a hidden class="anchor" aria-hidden="true" href="#추가-지원">#</a></h3>
<p>위 단계를 수행해도 문제가 해결되지 않거나 추가적인 지원이 필요하면 세부 로그와 상황을 공유해 주세요. 😊</p>
<hr>
<h1 id="etcsshsshd_config">/etc/ssh/sshd_config<a hidden class="anchor" aria-hidden="true" href="#etcsshsshd_config">#</a></h1>
<p>AWS EC2 인스턴스에서 <code>/etc/ssh/sshd_config</code>는 SSH 서버의 동작을 제어하는 중요한 설정 파일입니다. 보안과 기능을 모두 고려하여 적절하게 설정해야 합니다. 아래는 일반적으로 EC2에서 추천되는 SSH 설정과 보안 강화를 위한 추가 설정입니다.</p>
<hr>
<h2 id="1-기본-설정-예시"><strong>1. 기본 설정 예시</strong><a hidden class="anchor" aria-hidden="true" href="#1-기본-설정-예시">#</a></h2>
<p>다음은 <code>/etc/ssh/sshd_config</code>의 추천 기본 설정입니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span># 기본 포트 설정
</span></span><span style="display:flex;"><span>Port 22  # (필요에 따라 포트를 변경 가능. 예: 2222)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 프로토콜 버전
</span></span><span style="display:flex;"><span>Protocol 2  # SSH 버전 2만 허용 (버전 1은 비활성화)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 루트 사용자 로그인
</span></span><span style="display:flex;"><span>PermitRootLogin prohibit-password  # 루트 로그인 비활성화 (필요하면 `yes` 설정)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 공개 키 인증만 허용 (암호 인증 비활성화)
</span></span><span style="display:flex;"><span>PasswordAuthentication no  # 키 기반 인증 사용 (비밀번호 인증 비활성화)
</span></span><span style="display:flex;"><span>ChallengeResponseAuthentication no
</span></span><span style="display:flex;"><span>UsePAM yes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># X11 포워딩
</span></span><span style="display:flex;"><span>X11Forwarding no  # X11 포워딩이 필요한 경우 `yes`로 변경
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 호스트 키 파일
</span></span><span style="display:flex;"><span>HostKey /etc/ssh/ssh_host_rsa_key
</span></span><span style="display:flex;"><span>HostKey /etc/ssh/ssh_host_ecdsa_key
</span></span><span style="display:flex;"><span>HostKey /etc/ssh/ssh_host_ed25519_key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 로그 수준
</span></span><span style="display:flex;"><span>LogLevel VERBOSE  # 연결 문제를 진단하려면 VERBOSE로 설정
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 사용자 인증 제한
</span></span><span style="display:flex;"><span>AllowAgentForwarding no  # 에이전트 포워딩 비활성화
</span></span><span style="display:flex;"><span>AllowTcpForwarding no    # TCP 포워딩 비활성화 (필요한 경우만 허용)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 연결 시간 제한
</span></span><span style="display:flex;"><span>ClientAliveInterval 300  # 5분 동안 비활성 상태인 클라이언트를 체크
</span></span><span style="display:flex;"><span>ClientAliveCountMax 0    # 체크 실패 시 연결 종료
</span></span></code></pre></div><hr>
<h2 id="2-보안-강화를-위한-추가-설정"><strong>2. 보안 강화를 위한 추가 설정</strong><a hidden class="anchor" aria-hidden="true" href="#2-보안-강화를-위한-추가-설정">#</a></h2>
<h3 id="21-포트-변경"><strong>2.1. 포트 변경</strong><a hidden class="anchor" aria-hidden="true" href="#21-포트-변경">#</a></h3>
<p>기본 포트 22는 일반적으로 사용되며, 공격 시도 대상이 되기 쉽습니다. 포트를 변경하면 보안 수준을 약간 높일 수 있습니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Port 2222  # 비표준 포트 사용
</span></span></code></pre></div><p><strong>주의</strong>: 포트를 변경하면 AWS 보안 그룹에서 해당 포트를 허용해야 합니다.</p>
<hr>
<h3 id="22-특정-사용자그룹만-허용"><strong>2.2. 특정 사용자/그룹만 허용</strong><a hidden class="anchor" aria-hidden="true" href="#22-특정-사용자그룹만-허용">#</a></h3>
<p>EC2 인스턴스에 접근할 수 있는 사용자 또는 그룹을 제한하려면 다음을 추가:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>AllowUsers ubuntu john
</span></span><span style="display:flex;"><span># 또는
</span></span><span style="display:flex;"><span>AllowGroups sshusers
</span></span></code></pre></div><hr>
<h3 id="23-키-기반-인증만-허용"><strong>2.3. 키 기반 인증만 허용</strong><a hidden class="anchor" aria-hidden="true" href="#23-키-기반-인증만-허용">#</a></h3>
<p>AWS EC2는 기본적으로 키 기반 인증을 사용합니다. 보안 강화를 위해 암호 인증을 비활성화합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>PasswordAuthentication no
</span></span></code></pre></div><p>암호 인증이 필요하지 않으면 위 설정을 적용하세요.</p>
<hr>
<h3 id="24-루트-사용자-로그인-금지"><strong>2.4. 루트 사용자 로그인 금지</strong><a hidden class="anchor" aria-hidden="true" href="#24-루트-사용자-로그인-금지">#</a></h3>
<p>루트 계정으로 직접 로그인하는 것은 보안상 위험합니다. 루트 로그인을 금지하고 필요 시 <code>sudo</code>를 사용:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>PermitRootLogin no
</span></span></code></pre></div><hr>
<h3 id="25-최대-인증-시도-제한"><strong>2.5. 최대 인증 시도 제한</strong><a hidden class="anchor" aria-hidden="true" href="#25-최대-인증-시도-제한">#</a></h3>
<p>무작위 대입 공격(Brute Force Attack)을 방지하기 위해 최대 인증 시도를 제한:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>MaxAuthTries 3
</span></span></code></pre></div><hr>
<h3 id="26-로그-수준-설정"><strong>2.6. 로그 수준 설정</strong><a hidden class="anchor" aria-hidden="true" href="#26-로그-수준-설정">#</a></h3>
<p>SSH 로그를 통해 비정상적인 활동을 감지할 수 있도록 로그 수준을 높입니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>LogLevel VERBOSE
</span></span></code></pre></div><hr>
<h3 id="27-시간-초과-설정"><strong>2.7. 시간 초과 설정</strong><a hidden class="anchor" aria-hidden="true" href="#27-시간-초과-설정">#</a></h3>
<p>유휴 클라이언트 연결을 자동으로 종료하여 세션 남용을 방지:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ClientAliveInterval 300  # 5분 동안 유휴 상태 감지
</span></span><span style="display:flex;"><span>ClientAliveCountMax 0    # 1회 실패 시 세션 종료
</span></span></code></pre></div><hr>
<h2 id="3-설정-적용"><strong>3. 설정 적용</strong><a hidden class="anchor" aria-hidden="true" href="#3-설정-적용">#</a></h2>
<p>설정을 변경한 후 아래 명령어를 통해 SSH 서비스를 재시작하여 적용합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div><p>또는 구성 파일의 문법 오류를 확인 후 재시작:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshd -t  <span style="color:#75715e"># 문법 오류 확인</span>
</span></span><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div><hr>
<h2 id="4-aws-ec2-보안-그룹-설정"><strong>4. AWS EC2 보안 그룹 설정</strong><a hidden class="anchor" aria-hidden="true" href="#4-aws-ec2-보안-그룹-설정">#</a></h2>
<p>SSH 설정만으로는 충분하지 않을 수 있습니다. AWS 보안 그룹도 적절히 구성해야 합니다:</p>
<ol>
<li>
<p><strong>보안 그룹에서 인바운드 규칙 설정</strong>:</p>
<ul>
<li>포트 22(또는 변경한 포트) 허용:
<pre tabindex="0"><code>Type: SSH
Protocol: TCP
Port Range: 22 (또는 변경된 포트 번호)
Source: 0.0.0.0/0 (또는 특정 IP 대역)
</code></pre></li>
</ul>
</li>
<li>
<p><strong>IP 제한</strong>:</p>
<ul>
<li>SSH 접근을 특정 IP로 제한하여 보안 강화:
<pre tabindex="0"><code>Source: &lt;Your IP Address&gt;/32
</code></pre></li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-설정-후-테스트"><strong>5. 설정 후 테스트</strong><a hidden class="anchor" aria-hidden="true" href="#5-설정-후-테스트">#</a></h2>
<ul>
<li>변경된 설정이 올바르게 적용되었는지 확인하려면 새 SSH 세션을 사용하여 접속 테스트를 수행합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i ~/your-key.pem -p <span style="color:#ae81ff">2222</span> ubuntu@&lt;your-ec2-ip&gt;
</span></span></code></pre></div></li>
</ul>
<hr>
<h2 id="6-최종-파일-예시"><strong>6. 최종 파일 예시</strong><a hidden class="anchor" aria-hidden="true" href="#6-최종-파일-예시">#</a></h2>
<p>아래는 위 내용을 종합한 <code>/etc/ssh/sshd_config</code> 설정 예시입니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Port 2222
</span></span><span style="display:flex;"><span>Protocol 2
</span></span><span style="display:flex;"><span>PermitRootLogin no
</span></span><span style="display:flex;"><span>PasswordAuthentication no
</span></span><span style="display:flex;"><span>ChallengeResponseAuthentication no
</span></span><span style="display:flex;"><span>UsePAM yes
</span></span><span style="display:flex;"><span>X11Forwarding no
</span></span><span style="display:flex;"><span>AllowUsers ubuntu
</span></span><span style="display:flex;"><span>ClientAliveInterval 300
</span></span><span style="display:flex;"><span>ClientAliveCountMax 0
</span></span><span style="display:flex;"><span>LogLevel VERBOSE
</span></span><span style="display:flex;"><span>MaxAuthTries 3
</span></span></code></pre></div><hr>
<h3 id="추가-팁"><strong>추가 팁</strong><a hidden class="anchor" aria-hidden="true" href="#추가-팁">#</a></h3>
<ul>
<li>설정 변경 후 기존 SSH 세션을 종료하지 마세요. 잘못된 설정으로 인해 연결이 끊길 수 있습니다.</li>
<li>설정을 실수로 잘못 적용해 SSH 접근이 불가능할 경우, AWS 콘솔을 통해 EBS 볼륨을 수정하거나 EC2 인스턴스를 복구해야 합니다.</li>
</ul>
<h2 id="추가적인-질문이나-지원이-필요하면-언제든-알려주세요-">추가적인 질문이나 지원이 필요하면 언제든 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#추가적인-질문이나-지원이-필요하면-언제든-알려주세요-">#</a></h2>
<h1 id="missing-privilege-separation-directory-runsshd">Missing privilege separation directory: /run/sshd<a hidden class="anchor" aria-hidden="true" href="#missing-privilege-separation-directory-runsshd">#</a></h1>
<p><code>Missing privilege separation directory: /run/sshd</code> 오류는 SSH 데몬이 필요한 디렉토리 <code>/run/sshd</code>가 없어서 발생하는 문제입니다. 이 디렉토리는 SSH 데몬이 권한 분리를 수행하는 데 필요하며, 대부분의 경우 SSH 서비스가 시작될 때 자동으로 생성됩니다. 그러나 특정 상황에서는 디렉토리가 누락될 수 있습니다.</p>
<h3 id="해결-방법"><strong>해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#해결-방법">#</a></h3>
<h4 id="1-runsshd-디렉토리-생성"><strong>1. /run/sshd 디렉토리 생성</strong><a hidden class="anchor" aria-hidden="true" href="#1-runsshd-디렉토리-생성">#</a></h4>
<ol>
<li>
<p>디렉토리를 수동으로 생성합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir -p /run/sshd
</span></span></code></pre></div></li>
<li>
<p>올바른 권한을 설정합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chmod <span style="color:#ae81ff">755</span> /run/sshd
</span></span></code></pre></div></li>
</ol>
<hr>
<h4 id="2-ssh-데몬-테스트"><strong>2. SSH 데몬 테스트</strong><a hidden class="anchor" aria-hidden="true" href="#2-ssh-데몬-테스트">#</a></h4>
<ol>
<li>
<p>SSH 설정 파일의 문법 오류를 다시 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sshd -t
</span></span></code></pre></div><ul>
<li>오류가 없으면 아무 출력도 나타나지 않습니다.</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-ssh-서비스-재시작"><strong>3. SSH 서비스 재시작</strong><a hidden class="anchor" aria-hidden="true" href="#3-ssh-서비스-재시작">#</a></h4>
<p>SSH 서비스를 다시 시작하여 문제가 해결되었는지 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart sshd
</span></span></code></pre></div><p>서비스가 제대로 시작되었는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status sshd
</span></span></code></pre></div><hr>
<h4 id="4-문제-원인-분석-및-예방"><strong>4. 문제 원인 분석 및 예방</strong><a hidden class="anchor" aria-hidden="true" href="#4-문제-원인-분석-및-예방">#</a></h4>
<p><code>/run/sshd</code> 디렉토리가 누락된 원인을 분석하고 재발을 방지하기 위해 다음을 확인하세요:</p>
<ol>
<li>
<p><strong><code>/run</code> 디렉토리</strong></p>
<ul>
<li><code>/run</code> 디렉토리는 시스템이 부팅될 때 초기화되며, 여기에 생성된 디렉토리는 부팅 후 초기화될 수 있습니다.</li>
<li>SSH 서비스가 시작될 때 <code>/run/sshd</code> 디렉토리를 생성하도록 설계되어 있으므로, 서비스가 올바르게 작동하지 않으면 디렉토리가 생성되지 않을 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>SSH 서비스의 Unit 파일 확인</strong>
SSH 서비스의 Unit 파일에 <code>/run/sshd</code> 디렉토리 생성이 누락되었는지 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /lib/systemd/system/ssh.service
</span></span></code></pre></div><p>Unit 파일에 다음 줄이 포함되어 있는지 확인하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ExecStartPre=/usr/sbin/sshd -t
</span></span><span style="display:flex;"><span>ExecStartPre=/bin/mkdir -p /run/sshd
</span></span></code></pre></div><ul>
<li>누락된 경우, 이를 추가하거나 기본 Unit 파일을 복구합니다.</li>
</ul>
</li>
<li>
<p><strong>SSH 서비스 재설치 (필요 시)</strong>
문제가 지속된다면 SSH 서버를 재설치합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install --reinstall openssh-server
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="5-최종-확인"><strong>5. 최종 확인</strong><a hidden class="anchor" aria-hidden="true" href="#5-최종-확인">#</a></h3>
<p>SSH 서비스가 올바르게 작동하는지 확인하고, SSH로 정상적으로 접속 가능한지 테스트합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh -i ~/your-key.pem ubuntu@&lt;ec2-public-ip&gt;
</span></span></code></pre></div><h2 id="추가적으로-문제가-있거나-도움이-필요하면-언제든-알려주세요-">추가적으로 문제가 있거나 도움이 필요하면 언제든 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#추가적으로-문제가-있거나-도움이-필요하면-언제든-알려주세요-">#</a></h2>
<h1 id="devmappervg01-lv_ephemeral-디바이스가-사라진-이유">/dev/mapper/vg.01-lv_ephemeral 디바이스가 사라진 이유<a hidden class="anchor" aria-hidden="true" href="#devmappervg01-lv_ephemeral-디바이스가-사라진-이유">#</a></h1>
<p>EC2 인스턴스의 <strong>instance type</strong>을 변경한 후 <code>/dev/mapper/vg.01-lv_ephemeral</code> 디바이스가 사라진 이유는 다음과 같은 이유일 가능성이 큽니다:</p>
<ol>
<li>
<p><strong>Ephemeral Storage가 새 인스턴스 유형에서 지원되지 않음</strong>:</p>
<ul>
<li>일부 EC2 인스턴스 유형에서는 **ephemeral storage(임시 스토리지)**를 지원하지 않을 수 있습니다.</li>
<li>특히 GPU 기반 또는 최신 인스턴스 유형으로 변경할 경우, ephemeral 디스크가 비활성화될 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>Ephemeral Storage가 연결되지 않음</strong>:</p>
<ul>
<li>instance type 변경 후, ephemeral 스토리지(예: NVMe 디바이스)가 다시 연결되지 않을 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>Logical Volume 설정 손실</strong>:</p>
<ul>
<li><code>/dev/mapper/vg.01-lv_ephemeral</code>은 논리 볼륨(LVM)을 통해 구성된 것으로 보입니다. 변경된 인스턴스에 맞게 디스크를 다시 설정해야 합니다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="해결-방법-1"><strong>해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#해결-방법-1">#</a></h2>
<h3 id="1-새로운-instance-type의-ephemeral-storage-지원-여부-확인"><strong>1. 새로운 instance type의 ephemeral storage 지원 여부 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-새로운-instance-type의-ephemeral-storage-지원-여부-확인">#</a></h3>
<ol>
<li>
<p><strong>Ephemeral Storage 지원 여부</strong>:</p>
<ul>
<li>AWS 공식 문서를 참조하거나 아래 명령으로 현재 스토리지 디스크를 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>lsblk
</span></span></code></pre></div>NVMe 디스크 또는 임시 디스크(<code>/dev/nvme0n1</code>, <code>/dev/xvdb</code> 등)가 표시되지 않으면 해당 인스턴스 유형은 ephemeral storage를 지원하지 않을 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>Ephemeral 스토리지 지원 인스턴스 유형 확인</strong>:</p>
<ul>
<li>AWS 콘솔에서 <strong>인스턴스 유형</strong>을 확인하거나 <a href="https://aws.amazon.com/ec2/instance-types/">AWS EC2 인스턴스 유형 문서</a>를 참조하여 ephemeral storage 지원 여부를 확인합니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-nvme-디스크-다시-연결"><strong>2. NVMe 디스크 다시 연결</strong><a hidden class="anchor" aria-hidden="true" href="#2-nvme-디스크-다시-연결">#</a></h3>
<p>변경된 인스턴스에서 ephemeral 디스크가 나타나지 않았다면 디스크를 다시 확인하고 연결합니다.</p>
<ol>
<li>
<p><strong>NVMe 디스크 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nvme list
</span></span></code></pre></div><ul>
<li>NVMe 디스크가 목록에 나타나면 ephemeral 스토리지입니다.</li>
<li>보통 <code>/dev/nvme0n1</code> 또는 <code>/dev/xvdb</code>와 같은 디스크로 표시됩니다.</li>
</ul>
</li>
<li>
<p><strong>디스크 마운트 여부 확인</strong>:</p>
<ul>
<li>디스크가 마운트되지 않았다면 아래 명령으로 디스크를 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo fdisk -l
</span></span></code></pre></div></li>
<li>디스크가 있지만 마운트되지 않았다면 새로 마운트해야 합니다.</li>
</ul>
</li>
<li>
<p><strong>마운트 및 LVM 복구</strong>:</p>
<ul>
<li><code>vg.01-lv_ephemeral</code> 논리 볼륨을 복구하려면 다음 단계를 수행합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo pvscan
</span></span><span style="display:flex;"><span>sudo vgscan
</span></span><span style="display:flex;"><span>sudo lvscan
</span></span></code></pre></div></li>
<li><code>vg.01-lv_ephemeral</code>이 발견되면 활성화:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo vgchange -ay
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>마운트</strong>:</p>
<ul>
<li>복구된 볼륨을 특정 디렉토리에 마운트합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount /dev/mapper/vg.01-lv_ephemeral /mnt
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-logical-volumelvm-재설정"><strong>3. Logical Volume(LVM) 재설정</strong><a hidden class="anchor" aria-hidden="true" href="#3-logical-volumelvm-재설정">#</a></h3>
<p>만약 LVM 볼륨을 다시 설정해야 한다면, 아래 절차를 따라야 합니다.</p>
<ol>
<li>
<p><strong>디스크 확인 및 초기화</strong>:</p>
<ul>
<li>새로운 디스크를 LVM에 사용할 준비:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo pvcreate /dev/nvme0n1
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Volume Group 생성</strong>:</p>
<ul>
<li>새로운 볼륨 그룹 생성:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo vgcreate vg.01 /dev/nvme0n1
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>Logical Volume 생성</strong>:</p>
<ul>
<li>논리 볼륨을 생성:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo lvcreate -L 100G -n lv_ephemeral vg.01
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>파일 시스템 생성 및 마운트</strong>:</p>
<ul>
<li>
<p>파일 시스템 생성:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkfs.ext4 /dev/vg.01/lv_ephemeral
</span></span></code></pre></div></li>
<li>
<p>마운트:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir -p /mnt/ephemeral
</span></span><span style="display:flex;"><span>sudo mount /dev/vg.01/lv_ephemeral /mnt/ephemeral
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>자동 마운트 설정</strong>:</p>
<ul>
<li><code>/etc/fstab</code>에 추가:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/dev/mapper/vg.01-lv_ephemeral /mnt/ephemeral ext4 defaults,nofail <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">2</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-지원되지-않는-경우"><strong>4. 지원되지 않는 경우</strong><a hidden class="anchor" aria-hidden="true" href="#4-지원되지-않는-경우">#</a></h3>
<p>만약 현재 인스턴스 유형에서 ephemeral storage가 지원되지 않는 경우:</p>
<ol>
<li>
<p><strong>EBS 볼륨 사용</strong>:</p>
<ul>
<li>대신 <strong>EBS 볼륨</strong>을 추가하여 데이터를 저장하고 사용하세요.</li>
<li>AWS 콘솔에서 새 EBS 볼륨을 생성하고 EC2 인스턴스에 연결.</li>
</ul>
</li>
<li>
<p><strong>인스턴스 유형 변경</strong>:</p>
<ul>
<li>ephemeral storage가 필요한 경우, ephemeral storage를 지원하는 인스턴스 유형으로 다시 변경하세요. 예:
<ul>
<li><code>m5d</code>, <code>i3</code>, <code>c5d</code> 등.</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-디버깅-명령어"><strong>5. 디버깅 명령어</strong><a hidden class="anchor" aria-hidden="true" href="#5-디버깅-명령어">#</a></h3>
<ul>
<li>
<p><strong>디스크 및 마운트 상태 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>lsblk
</span></span><span style="display:flex;"><span>sudo fdisk -l
</span></span></code></pre></div></li>
<li>
<p><strong>LVM 상태 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo pvscan
</span></span><span style="display:flex;"><span>sudo vgscan
</span></span><span style="display:flex;"><span>sudo lvscan
</span></span></code></pre></div></li>
<li>
<p><strong>NVMe 디스크 상태 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nvme list
</span></span></code></pre></div></li>
<li>
<p><strong>시스템 로그 확인</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dmesg | grep nvme
</span></span></code></pre></div></li>
</ul>
<hr>
<h3 id="요약-3"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-3">#</a></h3>
<ol>
<li><code>lsblk</code> 또는 <code>nvme list</code>로 디스크를 확인.</li>
<li>디스크가 있다면 LVM 논리 볼륨을 활성화 (<code>vgscan</code>, <code>lvscan</code>, <code>vgchange -ay</code>).</li>
<li>논리 볼륨을 마운트하거나 재설정.</li>
<li>ephemeral storage가 지원되지 않는 경우, 지원되는 인스턴스 유형으로 변경하거나 EBS 볼륨 사용.</li>
</ol>
<p>추가적으로 도움이 필요하면 알려주세요! 😊</p>
<hr>
<h1 id="devnvme0n1-디스크에-데이터가-저장되어-있었는데-현재-lvm-볼륨이나-파일-시스템이-감지되지-않는-상황">/dev/nvme0n1 디스크에 데이터가 저장되어 있었는데, 현재 LVM 볼륨이나 파일 시스템이 감지되지 않는 상황<a hidden class="anchor" aria-hidden="true" href="#devnvme0n1-디스크에-데이터가-저장되어-있었는데-현재-lvm-볼륨이나-파일-시스템이-감지되지-않는-상황">#</a></h1>
<p><code>/dev/nvme0n1</code> 디스크에 데이터가 저장되어 있었는데, 현재 LVM 볼륨이나 파일 시스템이 감지되지 않는 상황입니다. 아래는 데이터를 복구할 수 있는 단계별 방법입니다.</p>
<hr>
<h2 id="1-문제-원인-분석"><strong>1. 문제 원인 분석</strong><a hidden class="anchor" aria-hidden="true" href="#1-문제-원인-분석">#</a></h2>
<ul>
<li><code>pvscan</code>에서 &ldquo;No matching physical volumes found&quot;라는 메시지가 나타나는 것은 <code>/dev/nvme0n1</code>에 LVM이 구성되어 있지 않거나, LVM 메타데이터가 손상되었음을 의미합니다.</li>
<li>디스크가 인식되었지만 마운트되지 않았으므로, 파일 시스템이 손상되었거나 삭제되었을 가능성도 있습니다.</li>
</ul>
<hr>
<h2 id="2-데이터-복구를-위한-단계"><strong>2. 데이터 복구를 위한 단계</strong><a hidden class="anchor" aria-hidden="true" href="#2-데이터-복구를-위한-단계">#</a></h2>
<h3 id="21-디스크-상태-확인"><strong>2.1. 디스크 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#21-디스크-상태-확인">#</a></h3>
<ol>
<li>
<p><strong>디스크 파티션 정보 확인</strong>:</p>
<ul>
<li>현재 <code>/dev/nvme0n1</code> 디스크의 파티션이 없는 것으로 보입니다. <code>fdisk</code>를 사용하여 파티션 정보를 확인합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo fdisk -l /dev/nvme0n1
</span></span></code></pre></div><ul>
<li>출력 예시:
<ul>
<li>파티션이 없는 경우: <code>Disk /dev/nvme0n1 doesn't contain a valid partition table</code></li>
<li>기존 파티션이 감지되는 경우: 파티션 정보를 출력.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>파일 시스템 확인</strong>:</p>
<ul>
<li>파일 시스템이 존재하는지 확인:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo file -s /dev/nvme0n1
</span></span></code></pre></div><ul>
<li>출력 예시:
<ul>
<li>파일 시스템이 없는 경우: <code>data</code></li>
<li>파일 시스템이 있는 경우: <code>ext4 filesystem</code> 또는 <code>xfs filesystem</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="22-lvm-복구-lvm이-사용된-경우"><strong>2.2. LVM 복구 (LVM이 사용된 경우)</strong><a hidden class="anchor" aria-hidden="true" href="#22-lvm-복구-lvm이-사용된-경우">#</a></h3>
<p><code>/dev/nvme0n1</code>이 LVM 볼륨 그룹의 일부였을 가능성이 있다면, 아래 단계를 시도합니다:</p>
<ol>
<li>
<p><strong>LVM 메타데이터 스캔</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo vgscan
</span></span></code></pre></div><ul>
<li>논리 볼륨 그룹이 표시되면 활성화:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo vgchange -ay
</span></span></code></pre></div></li>
<li>
<p><strong>LVM 볼륨 마운트</strong>:</p>
<ul>
<li>논리 볼륨을 찾았다면 이를 마운트:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount /dev/mapper/&lt;volume-group&gt;-&lt;logical-volume&gt; /mnt
</span></span></code></pre></div></li>
<li>
<p><strong>LVM 복구 (손상된 경우)</strong>:</p>
<ul>
<li>LVM 메타데이터가 손상된 경우 복구를 시도합니다:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo pvck /dev/nvme0n1
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="23-파일-시스템-복구"><strong>2.3. 파일 시스템 복구</strong><a hidden class="anchor" aria-hidden="true" href="#23-파일-시스템-복구">#</a></h3>
<p>파일 시스템이 손상되었거나 인식되지 않을 경우, 아래 단계를 시도합니다.</p>
<ol>
<li>
<p><strong>파일 시스템 체크 및 복구</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo fsck /dev/nvme0n1
</span></span></code></pre></div><ul>
<li><code>fsck</code>가 자동으로 복구를 시도합니다.</li>
</ul>
</li>
<li>
<p><strong>마운트 시도</strong>:</p>
<ul>
<li>파일 시스템이 복구되었다면 디스크를 마운트:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir -p /mnt/nvme0n1
</span></span><span style="display:flex;"><span>sudo mount /dev/nvme0n1 /mnt/nvme0n1
</span></span></code></pre></div><ul>
<li>마운트 후 데이터를 확인:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls /mnt/nvme0n1
</span></span></code></pre></div></li>
<li>
<p><strong>파일 시스템 복구 도구 사용</strong>:</p>
<ul>
<li>파일 시스템이 심각하게 손상된 경우, <code>testdisk</code>와 같은 도구를 사용하여 복구를 시도합니다:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install testdisk
</span></span><span style="display:flex;"><span>sudo testdisk /dev/nvme0n1
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="24-데이터-복구-도구-사용"><strong>2.4. 데이터 복구 도구 사용</strong><a hidden class="anchor" aria-hidden="true" href="#24-데이터-복구-도구-사용">#</a></h3>
<p>파일 시스템 또는 LVM 메타데이터가 모두 복구되지 않는 경우, 전문 데이터 복구 도구를 사용할 수 있습니다.</p>
<ol>
<li>
<p><strong><code>photorec</code> 사용</strong>:</p>
<ul>
<li>파일을 직접 복구:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install testdisk
</span></span><span style="display:flex;"><span>sudo photorec /dev/nvme0n1
</span></span></code></pre></div></li>
<li>
<p><strong><code>dd</code>를 사용하여 디스크 이미지 생성</strong>:</p>
<ul>
<li>데이터를 덮어쓰지 않기 위해 디스크 이미지를 생성합니다:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/nvme0n1 of<span style="color:#f92672">=</span>~/nvme0n1.img bs<span style="color:#f92672">=</span>4M status<span style="color:#f92672">=</span>progress
</span></span></code></pre></div><ul>
<li>생성된 이미지를 <code>testdisk</code> 또는 <code>photorec</code>를 사용해 분석.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-문제-재발-방지"><strong>3. 문제 재발 방지</strong><a hidden class="anchor" aria-hidden="true" href="#3-문제-재발-방지">#</a></h3>
<ol>
<li>
<p><strong>인스턴스 유형 변경 시 주의</strong>:</p>
<ul>
<li>Ephemeral 디스크는 임시 스토리지로, 인스턴스 종료 또는 유형 변경 시 데이터가 삭제될 수 있습니다.</li>
<li>데이터를 영구적으로 보관하려면 EBS 볼륨을 사용하세요.</li>
</ul>
</li>
<li>
<p><strong>정기적인 데이터 백업</strong>:</p>
<ul>
<li>중요한 데이터는 S3 또는 다른 스토리지 서비스에 정기적으로 백업합니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="요약-4"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-4">#</a></h3>
<ol>
<li><strong>디스크 상태 확인</strong>:
<ul>
<li><code>fdisk</code>, <code>file</code>, <code>fsck</code> 명령으로 디스크 상태 점검.</li>
</ul>
</li>
<li><strong>LVM 복구</strong>:
<ul>
<li><code>vgscan</code>, <code>lvscan</code>으로 논리 볼륨 검색 및 활성화.</li>
</ul>
</li>
<li><strong>파일 시스템 복구</strong>:
<ul>
<li><code>fsck</code>로 파일 시스템 복구 및 마운트 시도.</li>
</ul>
</li>
<li><strong>데이터 복구 도구</strong>:
<ul>
<li><code>testdisk</code>, <code>photorec</code>를 사용해 데이터를 복구.</li>
</ul>
</li>
</ol>
<h2 id="위-단계를-시도한-후에도-복구가-어렵다면-디스크-이미지dd를-생성한-후-전문-데이터-복구-도구-또는-서비스를-고려해야-합니다-추가적인-지원이-필요하면-알려주세요-">위 단계를 시도한 후에도 복구가 어렵다면 디스크 이미지(<code>dd</code>)를 생성한 후, 전문 데이터 복구 도구 또는 서비스를 고려해야 합니다. 추가적인 지원이 필요하면 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#위-단계를-시도한-후에도-복구가-어렵다면-디스크-이미지dd를-생성한-후-전문-데이터-복구-도구-또는-서비스를-고려해야-합니다-추가적인-지원이-필요하면-알려주세요-">#</a></h2>
<h1 id="devnvme0n1-디스크를-ext4-파일-시스템으로-포맷하고-workspace-디렉토리에-마운트하려면">/dev/nvme0n1 디스크를 ext4 파일 시스템으로 포맷하고 ~/workspace 디렉토리에 마운트하려면<a hidden class="anchor" aria-hidden="true" href="#devnvme0n1-디스크를-ext4-파일-시스템으로-포맷하고-workspace-디렉토리에-마운트하려면">#</a></h1>
<p><code>/dev/nvme0n1</code> 디스크를 ext4 파일 시스템으로 포맷하고 <code>~/workspace</code> 디렉토리에 마운트하려면 아래 단계를 따르세요. <strong>주의:</strong> 이 과정에서 기존 데이터가 삭제되므로, 데이터를 복구할 필요가 없다면 진행하세요.</p>
<hr>
<h2 id="1-디스크-상태-확인"><strong>1. 디스크 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-디스크-상태-확인">#</a></h2>
<p>먼저 <code>/dev/nvme0n1</code>이 올바르게 디스크로 인식되고 있는지 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>lsblk
</span></span></code></pre></div><p>출력 예시:</p>
<pre tabindex="0"><code>NAME         MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
nvme0n1      259:4    0 209.5G  0 disk
</code></pre><p><code>/dev/nvme0n1</code>이 디스크로 표시되고, 파티션(<code>nvme0n1p1</code>)이 없는지 확인합니다.</p>
<hr>
<h2 id="2-기존-데이터-제거-선택-사항"><strong>2. 기존 데이터 제거 (선택 사항)</strong><a hidden class="anchor" aria-hidden="true" href="#2-기존-데이터-제거-선택-사항">#</a></h2>
<p>기존 데이터를 삭제하고 디스크를 초기화합니다.</p>
<ol>
<li>
<p><strong>디스크 초기화</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo wipefs -a /dev/nvme0n1
</span></span></code></pre></div></li>
<li>
<p><strong>파티션 제거 (필요 시)</strong>:
만약 <code>nvme0n1</code>에 기존 파티션이 있는 경우 <code>fdisk</code>를 사용해 제거합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo fdisk /dev/nvme0n1
</span></span></code></pre></div><ul>
<li><code>d</code>를 눌러 기존 파티션 삭제.</li>
<li><code>w</code>를 눌러 변경 사항 저장.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-ext4-파일-시스템-생성"><strong>3. ext4 파일 시스템 생성</strong><a hidden class="anchor" aria-hidden="true" href="#3-ext4-파일-시스템-생성">#</a></h2>
<p>디스크에 ext4 파일 시스템을 생성합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkfs.ext4 /dev/nvme0n1
</span></span></code></pre></div><p>출력 예시:</p>
<pre tabindex="0"><code>mke2fs 1.46.5 (30-Dec-2021)
Creating filesystem with 52428800 4k blocks and 13107200 inodes
Filesystem UUID: &lt;generated-uuid&gt;
Superblock backups stored on blocks: ...
</code></pre><hr>
<h2 id="4-디스크-마운트"><strong>4. 디스크 마운트</strong><a hidden class="anchor" aria-hidden="true" href="#4-디스크-마운트">#</a></h2>
<ol>
<li>
<p><strong>마운트 지점 생성</strong>:
<code>~/workspace</code> 디렉토리가 없으면 생성합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p ~/workspace
</span></span></code></pre></div></li>
<li>
<p><strong>디스크 마운트</strong>:
<code>/dev/nvme0n1</code>을 <code>~/workspace</code>에 마운트:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount /dev/nvme0n1 ~/workspace
</span></span></code></pre></div></li>
<li>
<p><strong>권한 설정</strong>:
<code>~/workspace</code> 디렉토리의 소유자를 현재 사용자로 변경:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chown -R <span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span>:<span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span> ~/workspace
</span></span></code></pre></div></li>
<li>
<p><strong>마운트 확인</strong>:
마운트가 제대로 되었는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -h ~/workspace
</span></span></code></pre></div></li>
</ol>
<p>출력 예시:</p>
<pre tabindex="0"><code>Filesystem      Size  Used Avail Use% Mounted on
/dev/nvme0n1    200G  1G   199G   1% /home/username/workspace
</code></pre><hr>
<h2 id="5-자동-마운트-설정"><strong>5. 자동 마운트 설정</strong><a hidden class="anchor" aria-hidden="true" href="#5-자동-마운트-설정">#</a></h2>
<p>재부팅 후에도 <code>/dev/nvme0n1</code>이 <code>~/workspace</code>에 자동 마운트되도록 설정합니다.</p>
<ol>
<li>
<p><strong>UUID 확인</strong>:
디스크의 UUID를 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo blkid /dev/nvme0n1
</span></span></code></pre></div><p>출력 예시:</p>
<pre tabindex="0"><code>/dev/nvme0n1: UUID=&#34;12345678-1234-1234-1234-123456789abc&#34; TYPE=&#34;ext4&#34;
</code></pre></li>
<li>
<p><strong><code>/etc/fstab</code>에 항목 추가</strong>:
<code>/etc/fstab</code> 파일을 열고 아래 내용을 추가:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>UUID<span style="color:#f92672">=</span>12345678-1234-1234-1234-123456789abc /home/username/workspace ext4 defaults <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><ul>
<li>위에서 확인한 UUID를 사용합니다.</li>
<li><code>username</code>을 현재 사용자 이름으로 바꿉니다.</li>
</ul>
</li>
<li>
<p><strong><code>fstab</code> 테스트</strong>:
설정을 테스트하여 문제가 없는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -a
</span></span></code></pre></div></li>
<li>
<p><strong>재부팅 후 확인</strong>:
시스템을 재부팅한 후, 디스크가 제대로 마운트되었는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -h ~/workspace
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="요약-5"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-5">#</a></h2>
<ol>
<li>
<p><strong>ext4 파일 시스템 생성</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkfs.ext4 /dev/nvme0n1
</span></span></code></pre></div></li>
<li>
<p><strong>디스크 마운트</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount /dev/nvme0n1 ~/workspace
</span></span><span style="display:flex;"><span>sudo chown -R <span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span>:<span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span> ~/workspace
</span></span></code></pre></div></li>
<li>
<p><strong>자동 마운트 설정</strong>:</p>
<ul>
<li><code>/etc/fstab</code>에 UUID를 추가하여 디스크가 자동 마운트되도록 설정.</li>
</ul>
</li>
</ol>
<h2 id="위-단계를-완료하면-devnvme0n1-디스크가-ext4-파일-시스템으로-포맷되고-workspace에-마운트됩니다-추가-질문이-있으면-말씀해주세요-">위 단계를 완료하면 <code>/dev/nvme0n1</code> 디스크가 ext4 파일 시스템으로 포맷되고 <code>~/workspace</code>에 마운트됩니다. 추가 질문이 있으면 말씀해주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#위-단계를-완료하면-devnvme0n1-디스크가-ext4-파일-시스템으로-포맷되고-workspace에-마운트됩니다-추가-질문이-있으면-말씀해주세요-">#</a></h2>
<h1 id="devmappervg01-lv_ephemeral이-현재-optdlaminvme에-마운트되어-있는데-이를-homeubuntuworkspace로-마운트하려면">/dev/mapper/vg.01-lv_ephemeral이 현재 /opt/dlami/nvme에 마운트되어 있는데, 이를 /home/ubuntu/workspace로 마운트하려면<a hidden class="anchor" aria-hidden="true" href="#devmappervg01-lv_ephemeral이-현재-optdlaminvme에-마운트되어-있는데-이를-homeubuntuworkspace로-마운트하려면">#</a></h1>
<p><code>/dev/mapper/vg.01-lv_ephemeral</code>이 현재 <code>/opt/dlami/nvme</code>에 마운트되어 있는데, 이를 <code>/home/ubuntu/workspace</code>로 마운트하려면 <code>fstab</code> 파일을 수정해야 합니다. 아래 단계를 따르세요:</p>
<hr>
<h2 id="1-etcfstab-파일-수정"><strong>1. <code>/etc/fstab</code> 파일 수정</strong><a hidden class="anchor" aria-hidden="true" href="#1-etcfstab-파일-수정">#</a></h2>
<ol>
<li>
<p><strong><code>/etc/fstab</code> 파일 열기</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/fstab
</span></span></code></pre></div></li>
<li>
<p><strong>기존 마운트 항목 수정</strong>:</p>
<ul>
<li>
<p><code>/dev/mapper/vg.01-lv_ephemeral</code>의 기존 마운트 지점(<code>/opt/dlami/nvme</code>)을 <code>/home/ubuntu/workspace</code>로 변경합니다.</p>
</li>
<li>
<p>현재 설정은 다음과 비슷할 것입니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/dev/mapper/vg.01-lv_ephemeral /opt/dlami/nvme ext4 defaults <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div></li>
<li>
<p>이를 아래와 같이 수정:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/dev/mapper/vg.01-lv_ephemeral /home/ubuntu/workspace ext4 defaults <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-새로운-마운트-디렉토리-생성"><strong>2. 새로운 마운트 디렉토리 생성</strong><a hidden class="anchor" aria-hidden="true" href="#2-새로운-마운트-디렉토리-생성">#</a></h2>
<p><code>/home/ubuntu/workspace</code> 디렉토리가 없다면, 새로 생성해야 합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir -p /home/ubuntu/workspace
</span></span></code></pre></div><hr>
<h2 id="3-기존-마운트-해제"><strong>3. 기존 마운트 해제</strong><a hidden class="anchor" aria-hidden="true" href="#3-기존-마운트-해제">#</a></h2>
<ol>
<li>
<p>현재 <code>/opt/dlami/nvme</code>에 마운트된 디스크를 해제합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo umount /opt/dlami/nvme
</span></span></code></pre></div></li>
<li>
<p><code>/opt/dlami/nvme</code> 디렉토리를 삭제(선택 사항):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo rm -rf /opt/dlami/nvme
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="4-새로운-마운트-적용"><strong>4. 새로운 마운트 적용</strong><a hidden class="anchor" aria-hidden="true" href="#4-새로운-마운트-적용">#</a></h2>
<ol>
<li>
<p><code>/etc/fstab</code> 파일을 테스트하여 설정이 올바른지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -a
</span></span></code></pre></div></li>
<li>
<p>새로운 마운트가 적용되었는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -Th
</span></span></code></pre></div><p>출력에 <code>/dev/mapper/vg.01-lv_ephemeral</code>이 <code>/home/ubuntu/workspace</code>로 마운트된 것을 확인할 수 있습니다.</p>
</li>
</ol>
<hr>
<h2 id="5-시스템-재부팅-후-확인"><strong>5. 시스템 재부팅 후 확인</strong><a hidden class="anchor" aria-hidden="true" href="#5-시스템-재부팅-후-확인">#</a></h2>
<p>재부팅 후에도 <code>/home/ubuntu/workspace</code>에 자동 마운트되도록 설정이 적용되었는지 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo reboot
</span></span></code></pre></div><p>재부팅 후 다음 명령어로 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -Th
</span></span></code></pre></div><hr>
<h2 id="최종-결과-예시"><strong>최종 결과 예시</strong><a hidden class="anchor" aria-hidden="true" href="#최종-결과-예시">#</a></h2>
<p><code>/etc/fstab</code> 파일의 최종 내용은 아래와 같아야 합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/dev/mapper/vg.01-lv_ephemeral /home/ubuntu/workspace ext4 defaults <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><hr>
<h2 id="이제-devmappervg01-lv_ephemeral-디스크가-homeubuntuworkspace에-마운트됩니다-추가-질문이-있으면-알려주세요-">이제 <code>/dev/mapper/vg.01-lv_ephemeral</code> 디스크가 <code>/home/ubuntu/workspace</code>에 마운트됩니다. 추가 질문이 있으면 알려주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#이제-devmappervg01-lv_ephemeral-디스크가-homeubuntuworkspace에-마운트됩니다-추가-질문이-있으면-알려주세요-">#</a></h2>
<h1 id="devmappervg01-lv_ephemeral이-optdlaminvme에-마운트되었지만-etcfstab에-해당-설정이-없는-이유">/dev/mapper/vg.01-lv_ephemeral이 /opt/dlami/nvme에 마운트되었지만 /etc/fstab에 해당 설정이 없는 이유<a hidden class="anchor" aria-hidden="true" href="#devmappervg01-lv_ephemeral이-optdlaminvme에-마운트되었지만-etcfstab에-해당-설정이-없는-이유">#</a></h1>
<p><code>/dev/mapper/vg.01-lv_ephemeral</code>이 <code>/opt/dlami/nvme</code>에 마운트되었지만 <code>/etc/fstab</code>에 해당 설정이 없는 이유는, AWS EC2에서 임시 스토리지(예: NVMe 또는 ephemeral storage)가 부팅 과정에서 <strong>커스텀 스크립트</strong>나 <strong>AMI 설정</strong>에 의해 자동으로 설정될 수 있기 때문입니다. 특히, Deep Learning AMI(DLAMI)와 같은 커스텀 AMI에서는 이런 작업이 자동으로 수행됩니다.</p>
<hr>
<h2 id="왜-optdlaminvme에-마운트되었는가"><strong>왜 <code>/opt/dlami/nvme</code>에 마운트되었는가?</strong><a hidden class="anchor" aria-hidden="true" href="#왜-optdlaminvme에-마운트되었는가">#</a></h2>
<ol>
<li>
<p><strong>커스텀 AMI 초기화 스크립트</strong>:</p>
<ul>
<li>Deep Learning AMI 또는 다른 AWS 제공 AMI는 초기화 과정에서 ephemeral 스토리지를 자동으로 디스크 초기화, LVM 구성, 마운트 작업을 수행합니다.</li>
<li>이 작업은 <code>/etc/fstab</code> 대신 부팅 시 실행되는 스크립트에서 처리됩니다.</li>
</ul>
</li>
<li>
<p><strong>시스템 초기화 스크립트 위치</strong>:</p>
<ul>
<li><code>/var/lib/cloud/</code> 디렉토리에서 부팅 시 실행된 초기화 스크립트를 찾을 수 있습니다.</li>
<li>다음 명령으로 초기화 스크립트를 확인하세요:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /var/lib/cloud/instance/scripts/part-001
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>시스템 서비스</strong>:</p>
<ul>
<li><code>/opt/dlami/nvme</code>로 마운트하는 작업이 <code>cloud-init</code>이나 다른 서비스에 의해 처리되었을 가능성이 있습니다.</li>
<li>실행된 서비스 로그를 확인하세요:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>journalctl | grep <span style="color:#e6db74">&#34;/opt/dlami/nvme&#34;</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h2 id="해결-방법-수동으로-설정-변경"><strong>해결 방법: 수동으로 설정 변경</strong><a hidden class="anchor" aria-hidden="true" href="#해결-방법-수동으로-설정-변경">#</a></h2>
<p><code>/opt/dlami/nvme</code>로 자동 마운트되는 설정을 제거하고 <code>/home/ubuntu/workspace</code>로 마운트하려면 아래 단계를 따르세요.</p>
<hr>
<h3 id="1-현재-마운트-해제"><strong>1. 현재 마운트 해제</strong><a hidden class="anchor" aria-hidden="true" href="#1-현재-마운트-해제">#</a></h3>
<p>자동 마운트된 <code>/opt/dlami/nvme</code>를 수동으로 해제합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo umount /opt/dlami/nvme
</span></span></code></pre></div><hr>
<h3 id="2-새-마운트-디렉토리-생성"><strong>2. 새 마운트 디렉토리 생성</strong><a hidden class="anchor" aria-hidden="true" href="#2-새-마운트-디렉토리-생성">#</a></h3>
<p>새 마운트 지점을 생성합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir -p /home/ubuntu/workspace
</span></span></code></pre></div><hr>
<h3 id="3-etcfstab에-설정-추가"><strong>3. <code>/etc/fstab</code>에 설정 추가</strong><a hidden class="anchor" aria-hidden="true" href="#3-etcfstab에-설정-추가">#</a></h3>
<p>마운트를 영구적으로 유지하려면 <code>/etc/fstab</code>에 설정을 추가합니다.</p>
<ol>
<li>
<p><strong>UUID 확인</strong>:
<code>/dev/mapper/vg.01-lv_ephemeral</code>의 UUID를 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo blkid /dev/mapper/vg.01-lv_ephemeral
</span></span></code></pre></div><p>출력 예시:</p>
<pre tabindex="0"><code>/dev/mapper/vg.01-lv_ephemeral: UUID=&#34;1234-5678-90ab-cdef&#34; TYPE=&#34;ext4&#34;
</code></pre></li>
<li>
<p><strong><code>/etc/fstab</code>에 항목 추가</strong>:
<code>/etc/fstab</code> 파일을 열고 아래 내용을 추가합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>UUID<span style="color:#f92672">=</span>1234-5678-90ab-cdef /home/ubuntu/workspace ext4 defaults,uid<span style="color:#f92672">=</span>1000,gid<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div></li>
<li>
<p><strong>설정 테스트</strong>:
설정이 올바른지 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mount -a
</span></span></code></pre></div></li>
<li>
<p><strong>확인</strong>:
마운트가 제대로 되었는지 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -Th
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="4-초기화-스크립트-수정-dlami의-경우"><strong>4. 초기화 스크립트 수정 (DLAMI의 경우)</strong><a hidden class="anchor" aria-hidden="true" href="#4-초기화-스크립트-수정-dlami의-경우">#</a></h3>
<p>만약 AWS에서 제공하는 초기화 스크립트가 <code>/opt/dlami/nvme</code>로 마운트하도록 강제하고 있다면, 이를 수정하거나 비활성화해야 합니다.</p>
<ol>
<li>
<p><strong>초기화 스크립트 위치 찾기</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>grep -r <span style="color:#e6db74">&#34;/opt/dlami/nvme&#34;</span> /var/lib/cloud/
</span></span></code></pre></div></li>
<li>
<p><strong>스크립트 수정</strong>:</p>
<ul>
<li><code>/var/lib/cloud/instance/scripts/part-001</code>과 같은 파일에 <code>/opt/dlami/nvme</code>로 마운트하는 설정이 있을 수 있습니다.</li>
<li>해당 파일을 수정하여 <code>/home/ubuntu/workspace</code>로 마운트하도록 변경하거나, 초기화 스크립트 실행을 방지합니다.</li>
</ul>
</li>
<li>
<p><strong>초기화 서비스 비활성화 (선택 사항)</strong>:</p>
<ul>
<li>초기화가 다시 실행되지 않도록 <code>cloud-init</code>을 비활성화:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo touch /etc/cloud/cloud-init.disabled
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-재부팅-후-확인"><strong>5. 재부팅 후 확인</strong><a hidden class="anchor" aria-hidden="true" href="#5-재부팅-후-확인">#</a></h3>
<p>재부팅 후에도 <code>/home/ubuntu/workspace</code>로 제대로 마운트되는지 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo reboot
</span></span></code></pre></div><p>재부팅 후:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>df -Th
</span></span></code></pre></div><hr>
<h2 id="요약-6"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-6">#</a></h2>
<ol>
<li>현재 <code>/opt/dlami/nvme</code>로 마운트되는 원인은 AWS DLAMI 또는 커스텀 초기화 스크립트 때문일 가능성이 높습니다.</li>
<li><code>/etc/fstab</code>에 수동으로 마운트 설정을 추가하여 <code>/home/ubuntu/workspace</code>로 변경 가능합니다.</li>
<li>초기화 스크립트가 강제로 마운트 작업을 수행한다면 이를 수정하거나 비활성화해야 합니다.</li>
</ol>
<h2 id="추가적으로-문제가-있거나-도움이-필요하면-말씀해주세요-">추가적으로 문제가 있거나 도움이 필요하면 말씀해주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#추가적으로-문제가-있거나-도움이-필요하면-말씀해주세요-">#</a></h2>
<h1 id="ollama가-설치된-폴더를-확인">ollama가 설치된 폴더를 확인<a hidden class="anchor" aria-hidden="true" href="#ollama가-설치된-폴더를-확인">#</a></h1>
<p><code>ollama</code>가 설치된 폴더를 확인하려면 아래 방법을 따라 진행하면 됩니다.</p>
<hr>
<h2 id="1-which-명령으로-실행-파일-경로-확인"><strong>1. <code>which</code> 명령으로 실행 파일 경로 확인</strong><a hidden class="anchor" aria-hidden="true" href="#1-which-명령으로-실행-파일-경로-확인">#</a></h2>
<p><code>ollama</code> 명령어가 실행 가능한 경로를 확인합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>which ollama
</span></span></code></pre></div><p>출력 예시:</p>
<pre tabindex="0"><code>/usr/local/bin/ollama
</code></pre><ul>
<li>이 출력은 <code>ollama</code> 실행 파일이 <code>/usr/local/bin/ollama</code>에 설치되어 있음을 의미합니다.</li>
</ul>
<hr>
<h2 id="2-파일-위치-확인"><strong>2. 파일 위치 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-파일-위치-확인">#</a></h2>
<p><code>ollama</code> 실행 파일의 심볼릭 링크나 실제 위치를 확인하려면 아래 명령을 실행하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -l <span style="color:#66d9ef">$(</span>which ollama<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><p>출력 예시:</p>
<pre tabindex="0"><code>lrwxrwxrwx 1 root root 33 Jan 23 12:00 /usr/local/bin/ollama -&gt; /path/to/actual/ollama/installation
</code></pre><ul>
<li>위 결과에서 <code>-&gt;</code> 뒤에 표시된 경로가 실제 설치된 경로입니다.</li>
</ul>
<hr>
<h2 id="3-설치-경로-직접-검색"><strong>3. 설치 경로 직접 검색</strong><a hidden class="anchor" aria-hidden="true" href="#3-설치-경로-직접-검색">#</a></h2>
<p>만약 <code>which</code>로 찾을 수 없거나 설치 경로를 확실히 확인하고 싶다면, <code>find</code> 또는 <code>locate</code> 명령어를 사용할 수 있습니다.</p>
<h3 id="31-find-명령-사용"><strong>3.1. <code>find</code> 명령 사용</strong><a hidden class="anchor" aria-hidden="true" href="#31-find-명령-사용">#</a></h3>
<p><code>ollama</code> 실행 파일을 시스템 전체에서 검색합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo find / -name ollama 2&gt;/dev/null
</span></span></code></pre></div><ul>
<li>결과 예시:
<pre tabindex="0"><code>/usr/local/bin/ollama
/opt/ollama/bin/ollama
</code></pre></li>
</ul>
<h3 id="32-locate-명령-사용"><strong>3.2. <code>locate</code> 명령 사용</strong><a hidden class="anchor" aria-hidden="true" href="#32-locate-명령-사용">#</a></h3>
<p><code>locate</code> 명령을 사용하면 빠르게 검색할 수 있습니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>locate ollama
</span></span></code></pre></div><hr>
<h2 id="4-홈-디렉토리-또는-사용자별-설치-확인"><strong>4. 홈 디렉토리 또는 사용자별 설치 확인</strong><a hidden class="anchor" aria-hidden="true" href="#4-홈-디렉토리-또는-사용자별-설치-확인">#</a></h2>
<p>일부 경우, <code>ollama</code>가 사용자 홈 디렉토리 아래에 설치될 수 있습니다. 다음 경로를 확인하세요:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -l ~/local/bin/ollama
</span></span><span style="display:flex;"><span>ls -l ~/.ollama
</span></span></code></pre></div><hr>
<h2 id="5-ollama의-설정-파일-확인"><strong>5. Ollama의 설정 파일 확인</strong><a hidden class="anchor" aria-hidden="true" href="#5-ollama의-설정-파일-확인">#</a></h2>
<p><code>ollama</code>가 설치된 위치를 설정 파일로 확인할 수도 있습니다. 설정 파일은 일반적으로 <code>~/.ollama</code> 디렉토리에 위치합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls ~/.ollama
</span></span></code></pre></div><hr>
<h2 id="6-패키지-관리자-확인"><strong>6. 패키지 관리자 확인</strong><a hidden class="anchor" aria-hidden="true" href="#6-패키지-관리자-확인">#</a></h2>
<ol>
<li>
<p><strong><code>brew</code>(macOS)</strong>:</p>
<ul>
<li>만약 <code>brew</code>로 설치되었다면 설치된 경로를 확인합니다:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>brew list ollama
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong><code>apt</code>(Ubuntu)</strong>:</p>
<ul>
<li>Ubuntu에서 <code>ollama</code>가 패키지로 설치되었다면:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dpkg -L ollama
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong><code>snap</code></strong>:</p>
<ul>
<li><code>snap</code>을 사용했다면 설치된 경로 확인:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>snap list ollama
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
<hr>
<h2 id="요약-7"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-7">#</a></h2>
<ul>
<li><strong>일반 경로 확인</strong>: <code>which ollama</code></li>
<li><strong>실제 경로 확인</strong>: <code>ls -l $(which ollama)</code></li>
<li><strong>전체 시스템 검색</strong>: <code>find / -name ollama</code></li>
</ul>
<p>위 단계를 통해 설치된 폴더를 확인할 수 있습니다. 추가적으로 궁금한 점이 있다면 알려주세요! 😊</p>
<hr>
<h1 id="ollama에서-다운로드한-모델이-저장되는-기본-폴더">ollama에서 다운로드한 모델이 저장되는 기본 폴더<a hidden class="anchor" aria-hidden="true" href="#ollama에서-다운로드한-모델이-저장되는-기본-폴더">#</a></h1>
<p><code>ollama</code>에서 다운로드한 모델이 저장되는 기본 폴더는 일반적으로 <strong>사용자의 홈 디렉토리 아래 특정 경로</strong>에 위치합니다. 정확한 경로를 확인하려면 다음 단계를 따라 진행하세요:</p>
<hr>
<h2 id="1-기본-모델-저장-폴더"><strong>1. 기본 모델 저장 폴더</strong><a hidden class="anchor" aria-hidden="true" href="#1-기본-모델-저장-폴더">#</a></h2>
<ul>
<li>
<p>일반적으로, <code>ollama</code>는 모델을 다음 경로에 저장합니다:</p>
<pre tabindex="0"><code>~/.ollama/models
</code></pre></li>
<li>
<p>이를 확인하려면 다음 명령어를 실행합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -l ~/.ollama/models
</span></span></code></pre></div></li>
<li>
<p>출력 예시:</p>
<pre tabindex="0"><code>total 123456
-rw-r--r-- 1 user user  12345678 Jan 23 10:00 llama-2-7b.q4_0.bin
-rw-r--r-- 1 user user  12345678 Jan 23 10:05 llama-2-13b.q4_0.bin
</code></pre></li>
</ul>
<hr>
<h2 id="2-설정-파일-확인"><strong>2. 설정 파일 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-설정-파일-확인">#</a></h2>
<p><code>ollama</code>의 모델 저장 경로는 설정 파일에서 변경할 수 있으므로 설정 파일을 확인합니다.</p>
<ol>
<li>
<p><strong>설정 파일 열기</strong>:
설정 파일은 일반적으로 다음 경로에 위치합니다:</p>
<pre tabindex="0"><code>~/.ollama/config.json
</code></pre></li>
<li>
<p><strong>설정 파일 내용 확인</strong>:
파일을 열어 <code>modelDir</code> 항목을 확인합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat ~/.ollama/config.json
</span></span></code></pre></div><p>출력 예시:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;modelDir&#34;</span>: <span style="color:#e6db74">&#34;/custom/path/to/models&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;cacheSize&#34;</span>: <span style="color:#ae81ff">1024</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>modelDir</code> 항목이 모델 저장 경로를 나타냅니다.</li>
<li>만약 <code>modelDir</code> 항목이 없으면 기본값(<code>~/.ollama/models</code>)이 사용됩니다.</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-모델-저장-경로-확인-명령"><strong>3. 모델 저장 경로 확인 명령</strong><a hidden class="anchor" aria-hidden="true" href="#3-모델-저장-경로-확인-명령">#</a></h2>
<p><code>ollama</code> CLI 명령으로 현재 모델 경로를 확인할 수 있습니다.</p>
<ol>
<li>
<p><strong>명령어 실행</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama config
</span></span></code></pre></div></li>
<li>
<p><strong>출력 예시</strong>:</p>
<pre tabindex="0"><code>Model directory: /home/user/.ollama/models
Cache size: 1024 MB
</code></pre></li>
</ol>
<hr>
<h2 id="4-시스템-전체-검색-모델-파일-이름으로-검색"><strong>4. 시스템 전체 검색 (모델 파일 이름으로 검색)</strong><a hidden class="anchor" aria-hidden="true" href="#4-시스템-전체-검색-모델-파일-이름으로-검색">#</a></h2>
<p>모델 파일이 특정 경로에 저장되어 있다면 아래 명령어로 시스템에서 검색할 수 있습니다.</p>
<ol>
<li>
<p><strong>모델 파일 이름 검색</strong>:
모델 파일은 일반적으로 <code>.bin</code> 확장자를 가집니다. 다음 명령어를 실행:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo find / -name <span style="color:#e6db74">&#34;*.bin&#34;</span> 2&gt;/dev/null
</span></span></code></pre></div></li>
<li>
<p><strong>출력 예시</strong>:</p>
<pre tabindex="0"><code>/home/user/.ollama/models/llama-2-7b.q4_0.bin
/custom/path/to/models/llama-2-13b.q4_0.bin
</code></pre></li>
</ol>
<hr>
<h2 id="5-모델-경로-변경-선택-사항"><strong>5. 모델 경로 변경 (선택 사항)</strong><a hidden class="anchor" aria-hidden="true" href="#5-모델-경로-변경-선택-사항">#</a></h2>
<p>모델을 저장하는 경로를 변경하려면 다음을 따르세요:</p>
<ol>
<li>
<p><strong><code>config.json</code> 파일 수정</strong>:
설정 파일(<code>~/.ollama/config.json</code>)에서 <code>modelDir</code> 값을 원하는 경로로 변경:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;modelDir&#34;</span>: <span style="color:#e6db74">&#34;/new/path/to/models&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;cacheSize&#34;</span>: <span style="color:#ae81ff">1024</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>ollama 재시작</strong>:
설정 변경 후 <code>ollama</code>를 다시 실행하거나 관련 서비스를 재시작합니다.</p>
</li>
</ol>
<hr>
<h2 id="요약-8"><strong>요약</strong><a hidden class="anchor" aria-hidden="true" href="#요약-8">#</a></h2>
<ol>
<li>
<p>기본 모델 저장 경로:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>~/.ollama/models
</span></span></code></pre></div></li>
<li>
<p>설정 파일에서 경로 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat ~/.ollama/config.json
</span></span></code></pre></div></li>
<li>
<p>CLI로 경로 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama config
</span></span></code></pre></div></li>
<li>
<p>필요 시 모델 경로 변경:
설정 파일에서 <code>modelDir</code> 값을 수정.</p>
</li>
</ol>
<h2 id="위-단계를-통해-다운로드된-모델-파일-경로를-확인할-수-있습니다-추가적으로-궁금한-점이-있다면-언제든-말씀해주세요-">위 단계를 통해 다운로드된 모델 파일 경로를 확인할 수 있습니다. 추가적으로 궁금한 점이 있다면 언제든 말씀해주세요! 😊<a hidden class="anchor" aria-hidden="true" href="#위-단계를-통해-다운로드된-모델-파일-경로를-확인할-수-있습니다-추가적으로-궁금한-점이-있다면-언제든-말씀해주세요-">#</a></h2>
<h1 id="change-the-location-where-ollama-stores-its-model-files-in-ubuntu">change the location where Ollama stores its model files in Ubuntu<a hidden class="anchor" aria-hidden="true" href="#change-the-location-where-ollama-stores-its-model-files-in-ubuntu">#</a></h1>
<p>To change the location where <strong>Ollama</strong> stores its model files in Ubuntu, you can modify the <code>modelDir</code> configuration in the Ollama settings. Here&rsquo;s how to do it:</p>
<hr>
<h3 id="1-locate-the-ollama-configuration-file"><strong>1. Locate the Ollama Configuration File</strong><a hidden class="anchor" aria-hidden="true" href="#1-locate-the-ollama-configuration-file">#</a></h3>
<p>The Ollama configuration file is usually located in:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>~/.ollama/config.json
</span></span></code></pre></div><h3 id="2-modify-the-configuration-file"><strong>2. Modify the Configuration File</strong><a hidden class="anchor" aria-hidden="true" href="#2-modify-the-configuration-file">#</a></h3>
<ol>
<li>
<p>Open the configuration file in a text editor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nano ~/.ollama/config.json
</span></span></code></pre></div></li>
<li>
<p>Look for the <code>modelDir</code> property. If it doesn&rsquo;t exist, add it.</p>
</li>
<li>
<p>Update the <code>modelDir</code> property to the desired directory. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;modelDir&#34;</span>: <span style="color:#e6db74">&#34;/path/to/your/custom/models&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;cacheSize&#34;</span>: <span style="color:#ae81ff">1024</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>Save the file (<code>Ctrl+O</code>, then <code>Enter</code>) and exit the editor (<code>Ctrl+X</code>).</p>
</li>
</ol>
<hr>
<h3 id="3-move-existing-models-to-the-new-location"><strong>3. Move Existing Models to the New Location</strong><a hidden class="anchor" aria-hidden="true" href="#3-move-existing-models-to-the-new-location">#</a></h3>
<p>If you already have downloaded models in the default location (<code>~/.ollama/models</code>), move them to the new directory to avoid re-downloading.</p>
<ol>
<li>
<p>Create the new directory if it doesn&rsquo;t exist:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p /path/to/your/custom/models
</span></span></code></pre></div></li>
<li>
<p>Move existing models:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mv ~/.ollama/models/* /path/to/your/custom/models/
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="4-verify-the-change"><strong>4. Verify the Change</strong><a hidden class="anchor" aria-hidden="true" href="#4-verify-the-change">#</a></h3>
<ol>
<li>
<p>Run the following command to check the current configuration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama config
</span></span></code></pre></div><p>The output should show the updated <code>modelDir</code>:</p>
<pre tabindex="0"><code>Model directory: /path/to/your/custom/models
Cache size: 1024 MB
</code></pre></li>
<li>
<p>If no models are found or downloaded incorrectly, ensure that the new path has the correct permissions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>chmod -R <span style="color:#ae81ff">755</span> /path/to/your/custom/models
</span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="5-test-ollama"><strong>5. Test Ollama</strong><a hidden class="anchor" aria-hidden="true" href="#5-test-ollama">#</a></h3>
<p>Run a model command to ensure Ollama recognizes the new model location:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama list
</span></span></code></pre></div><p>This will list all available models in the new directory. If models are missing, you might need to re-download them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama pull &lt;model-name&gt;
</span></span></code></pre></div><hr>
<h3 id="optional-use-a-symlink"><strong>Optional: Use a Symlink</strong><a hidden class="anchor" aria-hidden="true" href="#optional-use-a-symlink">#</a></h3>
<p>If you don&rsquo;t want to modify the configuration file, you can create a symbolic link from the default directory to the new location:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ln -s /path/to/your/custom/models ~/.ollama/models
</span></span></code></pre></div><hr>
<h3 id="summary"><strong>Summary</strong><a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h3>
<ol>
<li>Modify <code>~/.ollama/config.json</code> to set <code>modelDir</code> to your desired location.</li>
<li>Move existing models to the new directory.</li>
<li>Verify the configuration using <code>ollama config</code>.</li>
<li>Test Ollama to ensure it uses the new location.</li>
</ol>
<h2 id="if-you-encounter-any-issues-or-need-further-assistance-let-me-know-">If you encounter any issues or need further assistance, let me know! 😊<a hidden class="anchor" aria-hidden="true" href="#if-you-encounter-any-issues-or-need-further-assistance-let-me-know-">#</a></h2>
<h1 id="to-modify-the-ollamaservice">To modify the ollama.service<a hidden class="anchor" aria-hidden="true" href="#to-modify-the-ollamaservice">#</a></h1>
<p>To modify the <code>ollama.service</code> file in Ubuntu, follow these steps:</p>
<ol>
<li>
<p><strong>Open the <code>ollama.service</code> file for editing</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/systemd/system/ollama.service
</span></span></code></pre></div></li>
<li>
<p><strong>Make the necessary changes</strong>:</p>
<p>For example, to set environment variables, add the following lines under the <code>[Service]</code> section:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#66d9ef">[Service]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;OLLAMA_HOST=0.0.0.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;OLLAMA_PORT=11434&#34;</span>
</span></span></code></pre></div><p>This configuration allows Ollama to listen on all network interfaces and sets the port to <code>11434</code>. citeturn0search5</p>
</li>
<li>
<p><strong>Save and exit the editor</strong>:</p>
<ul>
<li>Press <code>Ctrl + O</code> to save the changes.</li>
<li>Press <code>Enter</code> to confirm.</li>
<li>Press <code>Ctrl + X</code> to exit the editor.</li>
</ul>
</li>
<li>
<p><strong>Reload the systemd daemon to apply the changes</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl daemon-reload
</span></span></code></pre></div></li>
<li>
<p><strong>Restart the Ollama service</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart ollama
</span></span></code></pre></div></li>
<li>
<p><strong>Verify the status of the Ollama service</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status ollama
</span></span></code></pre></div><p>This command will display the current status and confirm whether the service is running with the new configuration.</p>
</li>
</ol>
<p><strong>Note</strong>: If you encounter issues where modifications to the <code>ollama.service</code> file do not take effect, ensure that the file path is correct and that there are no syntax errors in the service file. Additionally, verify that the <code>ollama</code> executable exists at the specified path. citeturn0search11</p>
<p>By following these steps, you can successfully modify the <code>ollama.service</code> file and apply the desired configurations to the Ollama service in Ubuntu.</p>
<hr>
<h1 id="to-change-the-download-path-or-directory-for-ollama-using-the-ollamaservice">To change the download path or directory for ollama using the ollama.service<a hidden class="anchor" aria-hidden="true" href="#to-change-the-download-path-or-directory-for-ollama-using-the-ollamaservice">#</a></h1>
<p>To change the download path or directory for <code>ollama</code> using the <code>ollama.service</code> file, you need to modify the environment variable or options used in the service configuration. Here&rsquo;s how you can do this:</p>
<hr>
<h2 id="steps-to-modify-the-download-path-in-ollamaservice"><strong>Steps to Modify the Download Path in <code>ollama.service</code></strong><a hidden class="anchor" aria-hidden="true" href="#steps-to-modify-the-download-path-in-ollamaservice">#</a></h2>
<ol>
<li>
<p><strong>Open the Service File</strong>:
Open the <code>ollama.service</code> file in a text editor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/systemd/system/ollama.service
</span></span></code></pre></div></li>
<li>
<p><strong>Modify the Service Configuration</strong>:</p>
<ul>
<li>
<p>Look for the <code>[Service]</code> section.</p>
</li>
<li>
<p>Add or modify the environment variable or command-line argument to specify the desired download directory.</p>
</li>
<li>
<p>If the <code>OLLAMA_MODEL_DIR</code> environment variable is supported, you can specify it here. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#66d9ef">[Service]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Environment</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;OLLAMA_MODEL_DIR=/path/to/custom/model/directory&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ExecStart</span><span style="color:#f92672">=</span><span style="color:#e6db74">/usr/bin/ollama --model-dir=/path/to/custom/model/directory</span>
</span></span></code></pre></div></li>
<li>
<p>Alternatively, if the <code>--model-dir</code> argument is directly supported in the <code>ollama</code> binary, ensure it is part of the <code>ExecStart</code> line.</p>
</li>
</ul>
</li>
<li>
<p><strong>Save and Exit</strong>:</p>
<ul>
<li>Press <code>Ctrl+O</code> to save the file.</li>
<li>Press <code>Enter</code> to confirm.</li>
<li>Press <code>Ctrl+X</code> to exit the editor.</li>
</ul>
</li>
<li>
<p><strong>Reload the Systemd Daemon</strong>:
After modifying the service file, reload the systemd manager configuration to apply the changes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl daemon-reload
</span></span></code></pre></div></li>
<li>
<p><strong>Restart the Ollama Service</strong>:
Restart the service to apply the new configuration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl restart ollama
</span></span></code></pre></div></li>
<li>
<p><strong>Verify the Service Status</strong>:
Check if the service is running with the new configuration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status ollama
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="steps-to-ensure-the-custom-directory-exists"><strong>Steps to Ensure the Custom Directory Exists</strong><a hidden class="anchor" aria-hidden="true" href="#steps-to-ensure-the-custom-directory-exists">#</a></h2>
<p>Before restarting the service, ensure the custom directory exists and has the correct permissions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo mkdir -p /path/to/custom/model/directory
</span></span><span style="display:flex;"><span>sudo chown -R <span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span>:<span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span> /path/to/custom/model/directory
</span></span></code></pre></div><hr>
<h2 id="testing-the-new-path"><strong>Testing the New Path</strong><a hidden class="anchor" aria-hidden="true" href="#testing-the-new-path">#</a></h2>
<ol>
<li>
<p>Use <code>ollama list</code> to ensure that models are being downloaded or recognized in the new directory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama list
</span></span></code></pre></div></li>
<li>
<p>If models are not in the new directory, try pulling a new model to verify:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ollama pull llama-2-7b
</span></span></code></pre></div></li>
</ol>
<hr>
<h2 id="summary-1"><strong>Summary</strong><a hidden class="anchor" aria-hidden="true" href="#summary-1">#</a></h2>
<ul>
<li>Modify the <code>OLLAMA_MODEL_DIR</code> or <code>--model-dir</code> option in the <code>/etc/systemd/system/ollama.service</code> file.</li>
<li>Reload the systemd daemon and restart the service.</li>
<li>Ensure the custom directory exists and has appropriate permissions.</li>
</ul>
<h2 id="let-me-know-if-you-need-additional-guidance-or-troubleshooting-help-">Let me know if you need additional guidance or troubleshooting help! 😊<a hidden class="anchor" aria-hidden="true" href="#let-me-know-if-you-need-additional-guidance-or-troubleshooting-help-">#</a></h2>
<h1 id="apt--connection-timed-out">apt : connection timed out<a hidden class="anchor" aria-hidden="true" href="#apt--connection-timed-out">#</a></h1>
<h3 id="-sudo-apt-install-libssh2-1-dev-오류-해결-방법"><strong>🔍 <code>sudo apt install libssh2-1-dev</code> 오류 해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#-sudo-apt-install-libssh2-1-dev-오류-해결-방법">#</a></h3>
<p>오류 메시지:</p>
<pre tabindex="0"><code>Err:1 http://archive.ubuntu.com:80/ubuntu jammy/universe amd64 libssh2-1-dev amd64 1.10.0-3
  Could not connect to 10.4.241.231:3142 (10.4.241.231), connection timed out
</code></pre><ul>
<li><strong>원인</strong>:
<ul>
<li><code>apt</code>가 <strong>패키지를 다운로드할 수 없는 상태</strong> (네트워크 문제, 프록시 문제, 저장소가 사용 불가능한 상태)</li>
<li><code>10.4.241.231:3142</code> IP로 연결을 시도하고 있음 → <strong>내부 프록시 문제 가능성</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="-해결-방법"><strong>✅ 해결 방법</strong><a hidden class="anchor" aria-hidden="true" href="#-해결-방법">#</a></h2>
<h3 id="1-apt-update-실행-후-다시-시도"><strong>1️⃣ <code>apt update</code> 실행 후 다시 시도</strong><a hidden class="anchor" aria-hidden="true" href="#1-apt-update-실행-후-다시-시도">#</a></h3>
<p>패키지 목록이 오래되었을 가능성이 있으므로 먼저 <strong>업데이트</strong> 후 다시 설치해 봅니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt update --fix-missing
</span></span><span style="display:flex;"><span>sudo apt install libssh2-1-dev
</span></span></code></pre></div><hr>
<h3 id="2-네트워크-상태-확인"><strong>2️⃣ 네트워크 상태 확인</strong><a hidden class="anchor" aria-hidden="true" href="#2-네트워크-상태-확인">#</a></h3>
<p>인터넷이 정상적으로 연결되어 있는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ping -c <span style="color:#ae81ff">4</span> archive.ubuntu.com
</span></span></code></pre></div><p>✅ 정상적인 경우:</p>
<pre tabindex="0"><code>PING archive.ubuntu.com (91.189.91.39) 56(84) bytes of data.
64 bytes from 91.189.91.39: icmp_seq=1 ttl=53 time=30 ms
</code></pre><p>🚨 <strong>연결이 실패하면 인터넷 연결을 확인해야 함</strong></p>
<ul>
<li>프록시 사용 중인지 확인 (<code>echo $http_proxy</code>, <code>echo $https_proxy</code>)</li>
<li>VPN이 활성화되어 있다면 비활성화 후 다시 시도</li>
</ul>
<hr>
<h3 id="3-프록시-설정-확인-및-해제"><strong>3️⃣ 프록시 설정 확인 및 해제</strong><a hidden class="anchor" aria-hidden="true" href="#3-프록시-설정-확인-및-해제">#</a></h3>
<p>현재 <code>10.4.241.231:3142</code> 주소로 연결을 시도하는 것으로 보아, <strong>APT 프록시가 설정되어 있을 가능성이 높음</strong>.<br>
📌 프록시가 설정되어 있는지 확인:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo $http_proxy
</span></span><span style="display:flex;"><span>echo $https_proxy
</span></span><span style="display:flex;"><span>cat /etc/apt/apt.conf | grep Proxy
</span></span></code></pre></div><p>🚨 <strong>프록시 설정이 있다면 제거 후 다시 시도</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo rm -rf /etc/apt/apt.conf.d/00aptproxy
</span></span><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install libssh2-1-dev
</span></span></code></pre></div><hr>
<h3 id="4-다른-미러-서버로-변경"><strong>4️⃣ 다른 미러 서버로 변경</strong><a hidden class="anchor" aria-hidden="true" href="#4-다른-미러-서버로-변경">#</a></h3>
<p>기본 저장소 서버(<code>archive.ubuntu.com</code>)가 응답하지 않는 경우, 다른 미러로 변경할 수 있음.</p>
<p>📌 <strong>Ubuntu 저장소 미러 변경 (<code>/etc/apt/sources.list</code> 수정)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo nano /etc/apt/sources.list
</span></span></code></pre></div><p>기존의 <code>http://archive.ubuntu.com/ubuntu</code>를 아래와 같이 변경:</p>
<pre tabindex="0"><code>deb http://mirror.kakao.com/ubuntu jammy main restricted universe multiverse
deb http://mirror.kakao.com/ubuntu jammy-updates main restricted universe multiverse
deb http://mirror.kakao.com/ubuntu jammy-security main restricted universe multiverse
</code></pre><p>📌 <strong>저장 후, 패키지 업데이트 및 재설치</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install libssh2-1-dev
</span></span></code></pre></div><hr>
<h3 id="5-직접-libssh2-패키지-다운로드-및-설치"><strong>5️⃣ 직접 <code>libssh2</code> 패키지 다운로드 및 설치</strong><a hidden class="anchor" aria-hidden="true" href="#5-직접-libssh2-패키지-다운로드-및-설치">#</a></h3>
<p>만약 위 방법들이 모두 실패하면, <strong>패키지를 수동으로 다운로드하여 설치</strong>할 수 있습니다.</p>
<p>📌 <strong>수동 다운로드</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>wget http://archive.ubuntu.com/ubuntu/pool/universe/libs/libssh2/libssh2-1-dev_1.10.0-3_amd64.deb
</span></span></code></pre></div><p>📌 <strong>수동 설치</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo dpkg -i libssh2-1-dev_1.10.0-3_amd64.deb
</span></span></code></pre></div><p>📌 <strong>의존성 오류가 발생하면 자동 해결</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo apt --fix-broken install
</span></span></code></pre></div><hr>
<h2 id="-최종-해결-방법-요약"><strong>🚀 최종 해결 방법 요약</strong><a hidden class="anchor" aria-hidden="true" href="#-최종-해결-방법-요약">#</a></h2>
<p>1️⃣ <code>sudo apt update --fix-missing &amp;&amp; sudo apt install libssh2-1-dev</code><br>
2️⃣ <code>ping archive.ubuntu.com</code> 확인하여 네트워크 상태 점검<br>
3️⃣ 프록시 설정 확인 및 제거 (<code>sudo rm -rf /etc/apt/apt.conf.d/00aptproxy</code>)<br>
4️⃣ <code>/etc/apt/sources.list</code>에서 미러 서버 변경 (<code>mirror.kakao.com</code> 등)<br>
5️⃣ 직접 <code>wget</code>으로 패키지 다운로드 후 <code>dpkg -i</code>로 수동 설치</p>
<h2 id="-이제-다시-sudo-apt-install-libssh2-1-dev을-실행하여-패키지가-정상적으로-설치되는지-확인하세요">🚀 <strong>이제 다시 <code>sudo apt install libssh2-1-dev</code>을 실행하여 패키지가 정상적으로 설치되는지 확인하세요!</strong><a hidden class="anchor" aria-hidden="true" href="#-이제-다시-sudo-apt-install-libssh2-1-dev을-실행하여-패키지가-정상적으로-설치되는지-확인하세요">#</a></h2>
<h1 id="ec2-ubuntu-에-xface4-설치하고-xrdp-연결하는-방법">Ec2 ubuntu 에 xface4 설치하고 xrdp 연결하는 방법<a hidden class="anchor" aria-hidden="true" href="#ec2-ubuntu-에-xface4-설치하고-xrdp-연결하는-방법">#</a></h1>
<p>EC2 Ubuntu 인스턴스에 XFCE4를 설치하고, XRDP를 통해 원격 데스크톱 연결을 설정하는 과정은 다음과 같습니다. 단계별로 설명드리겠습니다.</p>
<h3 id="1-ec2-인스턴스-설정">1. EC2 인스턴스 설정<a hidden class="anchor" aria-hidden="true" href="#1-ec2-인스턴스-설정">#</a></h3>
<p>먼저, EC2 인스턴스를 생성하고 SSH로 연결합니다. 이미 연결이 되어 있다면, 다음 단계로 넘어가시면 됩니다.</p>
<h3 id="2-xfce4-설치">2. XFCE4 설치<a hidden class="anchor" aria-hidden="true" href="#2-xfce4-설치">#</a></h3>
<p>SSH로 인스턴스에 접속한 후, XFCE4 데스크탑 환경을 설치합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span>sudo apt install xfce4 xfce4-goodies -y
</span></span></code></pre></div><p>이 명령은 XFCE4 데스크톱 환경과 추가 패키지들을 설치합니다.</p>
<h3 id="3-xrdp-설치">3. XRDP 설치<a hidden class="anchor" aria-hidden="true" href="#3-xrdp-설치">#</a></h3>
<p>XRDP는 원격 데스크톱 연결을 가능하게 해주는 서비스입니다. 이를 설치하고 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install xrdp -y
</span></span></code></pre></div><p>설치 후, XRDP 서비스를 시작하고 부팅 시 자동으로 시작되도록 설정합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl enable xrdp
</span></span><span style="display:flex;"><span>sudo systemctl start xrdp
</span></span></code></pre></div><h3 id="4-xfce4를-xrdp의-기본-세션으로-설정">4. XFCE4를 XRDP의 기본 세션으로 설정<a hidden class="anchor" aria-hidden="true" href="#4-xfce4를-xrdp의-기본-세션으로-설정">#</a></h3>
<p>XRDP가 XFCE4를 기본 데스크톱 환경으로 사용하도록 설정해야 합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo xfce4-session &gt; ~/.xsession
</span></span></code></pre></div><p>XRDP 사용자 그룹에 현재 사용자를 추가합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo adduser $USER ssl-cert
</span></span></code></pre></div><h3 id="5-방화벽-설정-필요-시">5. 방화벽 설정 (필요 시)<a hidden class="anchor" aria-hidden="true" href="#5-방화벽-설정-필요-시">#</a></h3>
<p>EC2 보안 그룹에서 인바운드 규칙을 수정하여, TCP 포트 3389(RDP 포트)를 열어야 합니다. 이를 통해 원격 데스크톱 연결이 가능합니다.</p>
<ol>
<li>AWS 관리 콘솔에서 EC2 대시보드로 이동합니다.</li>
<li>인스턴스의 보안 그룹을 선택합니다.</li>
<li>인바운드 규칙을 편집하여, 새 규칙을 추가하고 다음을 입력합니다:
<ul>
<li><strong>유형</strong>: RDP</li>
<li><strong>프로토콜</strong>: TCP</li>
<li><strong>포트 범위</strong>: 3389</li>
<li><strong>소스</strong>: 내 IP 또는 모든 IP (0.0.0.0/0)로 설정합니다.</li>
</ul>
</li>
</ol>
<h3 id="6-원격-데스크톱-연결">6. 원격 데스크톱 연결<a hidden class="anchor" aria-hidden="true" href="#6-원격-데스크톱-연결">#</a></h3>
<p>이제 EC2 인스턴스의 공인 IP를 사용하여 원격 데스크톱 클라이언트에서 연결할 수 있습니다.</p>
<ul>
<li>윈도우의 <strong>원격 데스크톱 연결</strong> 프로그램을 실행하고, EC2 인스턴스의 공인 IP 주소를 입력합니다.</li>
<li>사용자명과 비밀번호를 입력하여 로그인합니다. 이는 Ubuntu 인스턴스의 사용자명과 비밀번호입니다.</li>
</ul>
<h3 id="문제-해결">문제 해결<a hidden class="anchor" aria-hidden="true" href="#문제-해결">#</a></h3>
<ol>
<li><strong>로그인 화면에서 검은 화면이 나오는 경우</strong>:
<ul>
<li>XFCE4 세션이 올바르게 설정되지 않은 경우가 있습니다. <code>.xsession</code> 파일에 <code>xfce4-session</code>이 제대로 작성되었는지 확인하세요.</li>
<li>만약 여전히 문제가 발생하면, XRDP 로그(<code>/var/log/xrdp-sesman.log</code>)를 확인하여 더 자세한 오류 메시지를 확인할 수 있습니다.</li>
</ul>
</li>
</ol>
<h2 id="이-과정을-완료하면-ec2-ubuntu-인스턴스에-xrdp를-통해-xfce4-데스크탑-환경에-접근할-수-있습니다">이 과정을 완료하면, EC2 Ubuntu 인스턴스에 XRDP를 통해 XFCE4 데스크탑 환경에 접근할 수 있습니다.<a hidden class="anchor" aria-hidden="true" href="#이-과정을-완료하면-ec2-ubuntu-인스턴스에-xrdp를-통해-xfce4-데스크탑-환경에-접근할-수-있습니다">#</a></h2>
<h1 id="ubuntu에서-cli를-통해-google-chrome을-설치하는-방법">Ubuntu에서 CLI를 통해 Google Chrome을 설치하는 방법<a hidden class="anchor" aria-hidden="true" href="#ubuntu에서-cli를-통해-google-chrome을-설치하는-방법">#</a></h1>
<p>Ubuntu에서 CLI를 통해 Google Chrome을 설치하는 방법을 단계별로 설명드리겠습니다.</p>
<h3 id="1-시스템-패키지-업데이트">1. 시스템 패키지 업데이트<a hidden class="anchor" aria-hidden="true" href="#1-시스템-패키지-업데이트">#</a></h3>
<p>먼저 패키지 목록을 업데이트합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span></code></pre></div><h3 id="2-필수-패키지-설치">2. 필수 패키지 설치<a hidden class="anchor" aria-hidden="true" href="#2-필수-패키지-설치">#</a></h3>
<p>Chrome 설치에 필요한 패키지를 설치합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install -y wget gnupg
</span></span></code></pre></div><h3 id="3-google-chrome의-gpg-키-추가">3. Google Chrome의 GPG 키 추가<a hidden class="anchor" aria-hidden="true" href="#3-google-chrome의-gpg-키-추가">#</a></h3>
<p>Chrome 패키지를 신뢰할 수 있도록 GPG 키를 추가합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
</span></span></code></pre></div><h3 id="4-chrome-저장소-추가">4. Chrome 저장소 추가<a hidden class="anchor" aria-hidden="true" href="#4-chrome-저장소-추가">#</a></h3>
<p>Chrome 패키지를 다운로드할 수 있도록 APT 저장소에 Chrome을 추가합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sh -c <span style="color:#e6db74">&#39;echo &#34;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&#34; &gt;&gt; /etc/apt/sources.list.d/google-chrome.list&#39;</span>
</span></span></code></pre></div><h3 id="5-패키지-목록-업데이트">5. 패키지 목록 업데이트<a hidden class="anchor" aria-hidden="true" href="#5-패키지-목록-업데이트">#</a></h3>
<p>새로운 저장소를 추가했으므로 패키지 목록을 다시 업데이트합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span></code></pre></div><h3 id="6-google-chrome-설치">6. Google Chrome 설치<a hidden class="anchor" aria-hidden="true" href="#6-google-chrome-설치">#</a></h3>
<p>다음 명령으로 Google Chrome을 설치합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install -y google-chrome-stable
</span></span></code></pre></div><h3 id="7-설치-확인">7. 설치 확인<a hidden class="anchor" aria-hidden="true" href="#7-설치-확인">#</a></h3>
<p>Chrome이 제대로 설치되었는지 확인하려면 다음 명령을 사용하여 버전을 확인할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>google-chrome --version
</span></span></code></pre></div><p>위 단계를 완료하면, Ubuntu에서 CLI를 통해 Google Chrome을 성공적으로 설치한 것입니다. 필요할 때 <code>google-chrome</code> 명령을 사용하여 Chrome을 실행할 수 있습니다.</p>
<hr>
<h1 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h1>
<hr>
<h1 id="heading-1"><a hidden class="anchor" aria-hidden="true" href="#heading-1">#</a></h1>
<hr>
<h1 id="heading-2"><a hidden class="anchor" aria-hidden="true" href="#heading-2">#</a></h1>
<hr>
<h1 id="heading-3"><a hidden class="anchor" aria-hidden="true" href="#heading-3">#</a></h1>
<hr>
<h1 id="heading-4"><a hidden class="anchor" aria-hidden="true" href="#heading-4">#</a></h1>
<hr>
<h1 id="heading-5"><a hidden class="anchor" aria-hidden="true" href="#heading-5">#</a></h1>
<hr>
<h1 id="heading-6"><a hidden class="anchor" aria-hidden="true" href="#heading-6">#</a></h1>
<hr>
<h1 id="heading-7"><a hidden class="anchor" aria-hidden="true" href="#heading-7">#</a></h1>
<hr>
<h1 id="heading-8"><a hidden class="anchor" aria-hidden="true" href="#heading-8">#</a></h1>
<hr>
<h1 id="heading-9"><a hidden class="anchor" aria-hidden="true" href="#heading-9">#</a></h1>
<hr>
<h1 id="heading-10"><a hidden class="anchor" aria-hidden="true" href="#heading-10">#</a></h1>
<hr>
<h1 id="heading-11"><a hidden class="anchor" aria-hidden="true" href="#heading-11">#</a></h1>
<hr>
<h1 id="heading-12"><a hidden class="anchor" aria-hidden="true" href="#heading-12">#</a></h1>
<hr>
<h1 id="heading-13"><a hidden class="anchor" aria-hidden="true" href="#heading-13">#</a></h1>
<hr>
<h1 id="heading-14"><a hidden class="anchor" aria-hidden="true" href="#heading-14">#</a></h1>
<hr>
<h1 id="heading-15"><a hidden class="anchor" aria-hidden="true" href="#heading-15">#</a></h1>
<hr>
<h1 id="heading-16"><a hidden class="anchor" aria-hidden="true" href="#heading-16">#</a></h1>
<hr>
<h1 id="heading-17"><a hidden class="anchor" aria-hidden="true" href="#heading-17">#</a></h1>
<hr>
<h1 id="heading-18"><a hidden class="anchor" aria-hidden="true" href="#heading-18">#</a></h1>
<hr>
<h1 id="heading-19"><a hidden class="anchor" aria-hidden="true" href="#heading-19">#</a></h1>
<hr>
<h1 id="heading-20"><a hidden class="anchor" aria-hidden="true" href="#heading-20">#</a></h1>
<hr>
<h1 id="heading-21"><a hidden class="anchor" aria-hidden="true" href="#heading-21">#</a></h1>
<hr>
<h1 id="heading-22"><a hidden class="anchor" aria-hidden="true" href="#heading-22">#</a></h1>
<hr>
<h1 id="heading-23"><a hidden class="anchor" aria-hidden="true" href="#heading-23">#</a></h1>
<hr>
<h1 id="heading-24"><a hidden class="anchor" aria-hidden="true" href="#heading-24">#</a></h1>
<hr>
<h1 id="heading-25"><a hidden class="anchor" aria-hidden="true" href="#heading-25">#</a></h1>
<hr>
<h1 id="heading-26"><a hidden class="anchor" aria-hidden="true" href="#heading-26">#</a></h1>
<hr>
<h1 id="heading-27"><a hidden class="anchor" aria-hidden="true" href="#heading-27">#</a></h1>
<hr>
<h1 id="heading-28"><a hidden class="anchor" aria-hidden="true" href="#heading-28">#</a></h1>
<hr>
<h1 id="heading-29"><a hidden class="anchor" aria-hidden="true" href="#heading-29">#</a></h1>
<hr>
<h1 id="heading-30"><a hidden class="anchor" aria-hidden="true" href="#heading-30">#</a></h1>
<hr>
<h1 id="heading-31"><a hidden class="anchor" aria-hidden="true" href="#heading-31">#</a></h1>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/portfolio/">RyanLabs</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
