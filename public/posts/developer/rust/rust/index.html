<!DOCTYPE html>
<html lang="ko" dir="auto">

<head><script src="/portfolio/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=portfolio/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>RyanLabs</title>
<meta name="keywords" content="">
<meta name="description" content="
Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 타입과 사용 방식에 따라 결정됩니다.
스택(Stack)


특징:

고정된 크기의 데이터를 저장합니다.
함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다.
메모리 할당과 해제가 빠릅니다.



저장되는 데이터:

정수형(i32, u64 등), 부동소수점형(f32, f64), 불리언(bool), 문자(char) 등 크기가 컴파일 시에 결정되는 기본 타입.
배열([T; N]), 튜플((T1, T2, ...)) 등 고정 크기의 컬렉션 타입.



예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/portfolio/posts/developer/rust/rust/">
<link crossorigin="anonymous" href="/portfolio/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css" integrity="sha256-bammPSWpYIvKL3&#43;QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/portfolio/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/portfolio/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/portfolio/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/portfolio/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/portfolio/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="ko" href="http://localhost:1313/portfolio/posts/developer/rust/rust/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/portfolio/" accesskey="h" title="RyanLabs (Alt + H)">RyanLabs</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/portfolio/search/" title="검색">
                    <span>검색</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/categories/" title="카테고리">
                    <span>카테고리</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/tags/" title="태그">
                    <span>태그</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/archives/" title="연도">
                    <span>연도</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/lectures/" title="강의">
                    <span>강의</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/portfolio/about/" title="어바웃미">
                    <span>어바웃미</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h1>
<p>Rust에서 변수의 메모리 저장 위치는 **스택(stack)**과 **힙(heap)**으로 나뉩니다. 각 변수의 저장 위치는 그 <strong>타입</strong>과 <strong>사용 방식</strong>에 따라 결정됩니다.</p>
<h3 id="스택stack">스택(Stack)<a hidden class="anchor" aria-hidden="true" href="#스택stack">#</a></h3>
<ul>
<li>
<p><strong>특징</strong>:</p>
<ul>
<li>고정된 크기의 데이터를 저장합니다.</li>
<li>함수 호출 시 할당되고, 함수 종료 시 자동으로 해제됩니다.</li>
<li>메모리 할당과 해제가 빠릅니다.</li>
</ul>
</li>
<li>
<p><strong>저장되는 데이터</strong>:</p>
<ul>
<li>정수형(<code>i32</code>, <code>u64</code> 등), 부동소수점형(<code>f32</code>, <code>f64</code>), 불리언(<code>bool</code>), 문자(<code>char</code>) 등 <strong>크기가 컴파일 시에 결정되는 기본 타입</strong>.</li>
<li>배열(<code>[T; N]</code>), 튜플(<code>(T1, T2, ...)</code>) 등 <strong>고정 크기의 컬렉션 타입</strong>.</li>
</ul>
</li>
</ul>
<p>예를 들어, 다음과 같은 코드는 스택에 데이터를 저장합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> x: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> y: (<span style="color:#66d9ef">f64</span>, <span style="color:#66d9ef">char</span>) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3.14</span>, <span style="color:#e6db74">&#39;A&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> arr: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위의 <code>x</code>, <code>y</code>, <code>arr</code> 변수들은 모두 스택에 저장됩니다.</p>
<h3 id="힙heap">힙(Heap)<a hidden class="anchor" aria-hidden="true" href="#힙heap">#</a></h3>
<ul>
<li>
<p><strong>특징</strong>:</p>
<ul>
<li>크기가 동적으로 결정되는 데이터를 저장합니다.</li>
<li>명시적으로 할당하며, 소유권 시스템을 통해 자동으로 해제됩니다.</li>
<li>메모리 할당과 해제가 스택보다 느립니다.</li>
</ul>
</li>
<li>
<p><strong>저장되는 데이터</strong>:</p>
<ul>
<li><code>String</code>, <code>Vec&lt;T&gt;</code> 등 <strong>크기가 동적인 컬렉션 타입</strong>.</li>
<li><code>Box&lt;T&gt;</code>를 통한 <strong>힙 할당된 데이터</strong>.</li>
</ul>
</li>
</ul>
<p>예를 들어, 다음과 같은 코드는 힙에 데이터를 저장합니다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s: String <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, Rust!&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b: Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">3.14</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위의 <code>s</code>, <code>v</code>, <code>b</code> 변수들은 힙에 데이터를 저장하고, 스택에는 해당 데이터에 대한 포인터와 메타데이터를 저장합니다.</p>
<h3 id="소유권과-메모리-관리">소유권과 메모리 관리<a hidden class="anchor" aria-hidden="true" href="#소유권과-메모리-관리">#</a></h3>
<p>Rust는 <strong>소유권(Ownership)</strong> 시스템을 통해 메모리를 관리합니다. 각 값은 하나의 소유자만 가질 수 있으며, 소유자가 스코프를 벗어나면 메모리가 자동으로 해제됩니다. 이러한 시스템 덕분에 개발자는 명시적으로 메모리를 해제하지 않아도 메모리 누수 없이 안전한 코드를 작성할 수 있습니다.</p>
<p>자세한 내용은 <a href="https://google.github.io/comprehensive-rust/ko/memory-management/approaches.html">Comprehensive Rust의 메모리 관리</a>에서 확인할 수 있습니다.</p>
<h3 id="요약">요약<a hidden class="anchor" aria-hidden="true" href="#요약">#</a></h3>
<ul>
<li><strong>스택</strong>: 고정 크기의 기본 타입과 컬렉션이 저장되며, 빠른 메모리 할당과 해제를 제공합니다.</li>
<li><strong>힙</strong>: 크기가 동적인 데이터가 저장되며, 소유권 시스템을 통해 자동으로 메모리가 관리됩니다.</li>
</ul>
<p>Rust의 이러한 메모리 관리 방식은 성능과 안전성을 동시에 추구하는 데 큰 장점을 제공합니다.</p>
<h1 id="heading-1"><a hidden class="anchor" aria-hidden="true" href="#heading-1">#</a></h1>
<p>Rust에서 **힙(heap)**과 **스택(stack)**에 저장되는 자료형을 자세히 구분하여 설명하겠습니다. 자료형의 특성에 따라 메모리 할당 방식이 다르며, 이는 주로 <strong>크기</strong>가 <strong>컴파일 타임에 결정되는지</strong> 아니면 <strong>런타임에 결정되는지</strong>에 따라 달라집니다.</p>
<h3 id="스택stack-1"><strong>스택(Stack)</strong><a hidden class="anchor" aria-hidden="true" href="#스택stack-1">#</a></h3>
<p>스택은 <strong>고정 크기</strong>의 데이터가 저장되는 영역입니다. 이 영역에 저장되는 자료형은 컴파일 시 크기가 결정되어야 하며, 함수가 끝나면 자동으로 메모리가 해제됩니다. 주로 기본 타입과 크기가 고정된 자료형들이 여기에 저장됩니다.</p>
<h4 id="스택에-저장되는-자료형"><strong>스택에 저장되는 자료형</strong><a hidden class="anchor" aria-hidden="true" href="#스택에-저장되는-자료형">#</a></h4>
<ol>
<li>
<p><strong>정수형 (Integer Types)</strong></p>
<ul>
<li>예: <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u8</code>, <code>i8</code>, <code>i16</code>, <code>u16</code></li>
<li>정수형은 고정된 크기를 가지므로 스택에 저장됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> x: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span></code></pre></div></li>
<li>
<p><strong>부동소수점형 (Floating Point Types)</strong></p>
<ul>
<li>예: <code>f32</code>, <code>f64</code></li>
<li>부동소수점형 역시 크기가 고정되어 스택에 저장됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> y: <span style="color:#66d9ef">f64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span></code></pre></div></li>
<li>
<p><strong>불리언형 (Boolean Type)</strong></p>
<ul>
<li><code>bool</code> 타입은 <code>true</code> 또는 <code>false</code> 값을 가지며, 크기가 고정되어 스택에 저장됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> is_active: <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span></code></pre></div></li>
<li>
<p><strong>문자형 (Character Type)</strong></p>
<ul>
<li><code>char</code> 타입은 하나의 유니코드 문자로 4바이트 크기를 가지며, 스택에 저장됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> c: <span style="color:#66d9ef">char</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>;
</span></span></code></pre></div></li>
<li>
<p><strong>고정 크기의 배열 (Fixed-size Arrays)</strong></p>
<ul>
<li>예: <code>[i32; 5]</code>, <code>[char; 3]</code></li>
<li>배열의 크기가 컴파일 타임에 결정되면 스택에 저장됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arr: [<span style="color:#66d9ef">i32</span>; <span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span></code></pre></div></li>
<li>
<p><strong>고정 크기의 튜플 (Fixed-size Tuples)</strong></p>
<ul>
<li>예: <code>(i32, f64, bool)</code></li>
<li>튜플도 고정 크기의 데이터이므로 스택에 저장됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> tup: (<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">f64</span>, <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">3.14</span>, <span style="color:#66d9ef">true</span>);
</span></span></code></pre></div></li>
</ol>
<h3 id="힙heap-1"><strong>힙(Heap)</strong><a hidden class="anchor" aria-hidden="true" href="#힙heap-1">#</a></h3>
<p>힙은 <strong>동적 크기</strong>의 데이터가 저장되는 영역입니다. 런타임에 크기가 결정되는 자료형이 대부분이며, <strong>소유권 시스템</strong>에 따라 메모리가 자동으로 할당 및 해제됩니다. 힙에 저장되는 자료형은 일반적으로 <strong>크기가 변할 수 있거나 런타임에 크기를 알 수 없는</strong> 자료형입니다.</p>
<h4 id="힙에-저장되는-자료형"><strong>힙에 저장되는 자료형</strong><a hidden class="anchor" aria-hidden="true" href="#힙에-저장되는-자료형">#</a></h4>
<ol>
<li>
<p><strong><code>String</code></strong></p>
<ul>
<li><code>String</code>은 길이가 동적으로 변할 수 있는 문자열을 저장합니다. Rust에서 <code>String</code>은 힙에 저장됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> s: String <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, Rust!&#34;</span>);
</span></span></code></pre></div></li>
<li>
<p><strong><code>Vec&lt;T&gt;</code> (벡터)</strong></p>
<ul>
<li><code>Vec&lt;T&gt;</code>는 크기가 동적으로 변할 수 있는 배열입니다. 힙에 데이터를 저장하며, 벡터의 크기는 런타임에 결정됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> v: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span></code></pre></div></li>
<li>
<p><strong><code>Box&lt;T&gt;</code></strong></p>
<ul>
<li><code>Box&lt;T&gt;</code>는 힙에 데이터를 저장하는 스마트 포인터입니다. 값을 힙에 할당하고, 해당 값을 소유합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b: Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">10</span>);
</span></span></code></pre></div></li>
<li>
<p><strong><code>HashMap&lt;K, V&gt;</code></strong></p>
<ul>
<li><code>HashMap</code>은 키-값 쌍을 저장하는 컬렉션으로, 데이터는 힙에 저장됩니다. <code>HashMap</code>의 크기와 내용은 런타임에 결정됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::collections::HashMap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> map <span style="color:#f92672">=</span> HashMap::new();
</span></span><span style="display:flex;"><span>map.insert(<span style="color:#e6db74">&#34;key1&#34;</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>map.insert(<span style="color:#e6db74">&#34;key2&#34;</span>, <span style="color:#ae81ff">20</span>);
</span></span></code></pre></div></li>
<li>
<p><strong><code>Rc&lt;T&gt;</code> (Reference Counted)</strong></p>
<ul>
<li><code>Rc&lt;T&gt;</code>는 참조 카운트를 사용하여 힙에서 값을 공유하는 스마트 포인터입니다. 여러 소유자가 값을 공유할 수 있도록 지원합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::rc::Rc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> value <span style="color:#f92672">=</span> Rc::new(<span style="color:#ae81ff">10</span>);
</span></span></code></pre></div></li>
<li>
<p><strong><code>Arc&lt;T&gt;</code> (Atomic Reference Counted)</strong></p>
<ul>
<li><code>Arc&lt;T&gt;</code>는 <code>Rc&lt;T&gt;</code>와 비슷하지만, 멀티스레딩 환경에서 안전하게 사용할 수 있는 스마트 포인터입니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::sync::Arc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> arc_value <span style="color:#f92672">=</span> Arc::new(<span style="color:#ae81ff">20</span>);
</span></span></code></pre></div></li>
</ol>
<h3 id="스택과-힙-간의-차이점"><strong>스택과 힙 간의 차이점</strong><a hidden class="anchor" aria-hidden="true" href="#스택과-힙-간의-차이점">#</a></h3>
<ul>
<li><strong>스택</strong>은 <strong>고정 크기</strong>의 데이터에 적합하고, 빠르게 할당과 해제됩니다. 함수 호출이 끝나면 스택에 저장된 변수들이 자동으로 제거됩니다.</li>
<li><strong>힙</strong>은 <strong>동적 크기</strong>의 데이터에 적합하며, 메모리 할당과 해제가 <strong>느리지만</strong>, 런타임에 크기가 결정되는 데이터나 크기가 변할 수 있는 데이터에 유용합니다.</li>
</ul>
<h3 id="스택과-힙의-예시-요약"><strong>스택과 힙의 예시 요약</strong><a hidden class="anchor" aria-hidden="true" href="#스택과-힙의-예시-요약">#</a></h3>
<table>
  <thead>
      <tr>
          <th>자료형</th>
          <th>메모리 위치</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>i32</code></td>
          <td>스택</td>
          <td>고정된 크기의 정수 타입</td>
      </tr>
      <tr>
          <td><code>f64</code></td>
          <td>스택</td>
          <td>고정된 크기의 부동소수점 타입</td>
      </tr>
      <tr>
          <td><code>bool</code></td>
          <td>스택</td>
          <td>고정된 크기의 불리언 타입</td>
      </tr>
      <tr>
          <td><code>char</code></td>
          <td>스택</td>
          <td>고정된 크기의 문자 타입</td>
      </tr>
      <tr>
          <td><code>[i32; 3]</code></td>
          <td>스택</td>
          <td>고정 크기의 배열</td>
      </tr>
      <tr>
          <td><code>(i32, f64)</code></td>
          <td>스택</td>
          <td>고정 크기의 튜플</td>
      </tr>
      <tr>
          <td><code>String</code></td>
          <td>힙</td>
          <td>동적 크기의 문자열 (힙에 할당)</td>
      </tr>
      <tr>
          <td><code>Vec&lt;i32&gt;</code></td>
          <td>힙</td>
          <td>동적 크기의 벡터 (힙에 할당)</td>
      </tr>
      <tr>
          <td><code>Box&lt;i32&gt;</code></td>
          <td>힙</td>
          <td>힙에 할당된 값</td>
      </tr>
      <tr>
          <td><code>HashMap</code></td>
          <td>힙</td>
          <td>동적 크기의 키-값 쌍을 저장하는 컬렉션</td>
      </tr>
      <tr>
          <td><code>Rc&lt;T&gt;</code></td>
          <td>힙</td>
          <td>참조 카운트가 있는 스마트 포인터</td>
      </tr>
      <tr>
          <td><code>Arc&lt;T&gt;</code></td>
          <td>힙</td>
          <td>멀티스레드 환경에서 안전한 참조 카운트 스마트 포인터</td>
      </tr>
  </tbody>
</table>
<h3 id="결론">결론<a hidden class="anchor" aria-hidden="true" href="#결론">#</a></h3>
<ul>
<li><strong>스택</strong>은 고정된 크기의 데이터를 빠르게 처리하고, <strong>힙</strong>은 크기가 동적이거나 런타임에 할당되는 데이터를 처리합니다.</li>
<li>Rust에서는 <strong>소유권 시스템</strong>을 통해 메모리 관리가 자동으로 이루어지며, 이를 통해 안전하고 효율적인 메모리 관리가 가능합니다.</li>
</ul>
<h1 id="heading-2"><a hidden class="anchor" aria-hidden="true" href="#heading-2">#</a></h1>
<p>Rust에서 <code>String</code>, <code>str</code>, 그리고 <strong>string literal</strong>은 메모리 상에서 다르게 취급됩니다. 각자의 메모리 할당 방식과 특성에 대해 자세히 설명드리겠습니다. 또한, 각 자료형들이 어떻게 **참조(Reference)**를 처리하는지도 다루겠습니다.</p>
<h3 id="1-string">1. <strong><code>String</code></strong><a hidden class="anchor" aria-hidden="true" href="#1-string">#</a></h3>
<ul>
<li>**<code>String</code>**은 **힙(heap)**에 동적으로 할당되는 문자열 타입입니다. <code>String</code>은 크기가 동적으로 변할 수 있기 때문에, 데이터가 힙에 저장됩니다. <code>String</code>은 <strong>소유권</strong>을 가지며, 그 값에 대한 소유권을 이동시키거나 참조할 수 있습니다.</li>
</ul>
<h4 id="특성">특성:<a hidden class="anchor" aria-hidden="true" href="#특성">#</a></h4>
<ul>
<li><strong>동적 크기</strong>: 문자열의 크기가 런타임에 결정되며, 문자열 길이에 따라 메모리가 할당됩니다.</li>
<li><strong>소유권</strong>: <code>String</code>은 해당 값을 소유하므로, 값이 더 이상 필요하지 않으면 자동으로 메모리가 해제됩니다.</li>
</ul>
<h4 id="예시">예시:<a hidden class="anchor" aria-hidden="true" href="#예시">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s: String <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, Rust!&#34;</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s);  <span style="color:#75715e">// `s`는 소유권을 가짐
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li><strong>참조</strong>: <code>String</code>에 대한 참조는 <code>&amp;String</code>으로 받을 수 있습니다. 참조는 데이터를 <strong>읽기 전용</strong>으로 다룰 수 있으며, 소유권을 이전하지 않고 접근할 수 있습니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_string</span>(s: <span style="color:#66d9ef">&amp;</span>String) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s); <span style="color:#75715e">// s는 참조형 변수
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s: String <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, Rust!&#34;</span>);
</span></span><span style="display:flex;"><span>    print_string(<span style="color:#f92672">&amp;</span>s); <span style="color:#75715e">// s의 참조를 전달
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="2-str">2. <strong><code>str</code></strong><a hidden class="anchor" aria-hidden="true" href="#2-str">#</a></h3>
<ul>
<li>**<code>str</code>**은 <strong>슬라이스(slice)</strong> 타입으로, 문자열의 일부를 참조하는 형태입니다. <code>str</code>은 <strong>고정된 크기</strong>가 아니기 때문에, 일반적으로 문자열 리터럴이나 <code>String</code>의 일부로 사용됩니다. <code>str</code> 자체는 직접적으로 생성되지 않으며, <strong><code>&amp;str</code></strong> 형태로만 존재합니다.</li>
</ul>
<h4 id="특성-1">특성:<a hidden class="anchor" aria-hidden="true" href="#특성-1">#</a></h4>
<ul>
<li><strong>불변</strong>: <code>str</code>은 <strong>불변(immutable)</strong> 데이터입니다.</li>
<li><strong>슬라이스</strong>: <code>str</code>은 문자열에 대한 슬라이스로, 실제 데이터를 소유하지 않으며 다른 문자열에 대한 참조를 가리킵니다.</li>
<li><strong>주로 사용</strong>: 주로 <code>String</code>에서 슬라이스를 얻거나, 문자열 리터럴로 사용됩니다.</li>
</ul>
<h4 id="예시-1">예시:<a hidden class="anchor" aria-hidden="true" href="#예시-1">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> hello: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, Rust!&#34;</span>;  <span style="color:#75715e">// 문자열 리터럴은 &amp;str 타입
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, hello);  <span style="color:#75715e">// &amp;str은 참조 타입
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li><strong>참조</strong>: <code>&amp;str</code>은 <code>String</code>에서 얻은 <strong>불변 참조</strong>이며, <code>&amp;String</code>에서 슬라이스를 만들어서 사용하거나 문자열 리터럴 자체로 사용됩니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_str</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s);  <span style="color:#75715e">// s는 &amp;str 타입, 문자열의 참조
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s: String <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, Rust!&#34;</span>);
</span></span><span style="display:flex;"><span>    print_str(<span style="color:#f92672">&amp;</span>s);  <span style="color:#75715e">// String에서 &amp;str 참조를 가져와서 전달
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="3-string-literal">3. <strong>String Literal</strong><a hidden class="anchor" aria-hidden="true" href="#3-string-literal">#</a></h3>
<ul>
<li><strong>문자열 리터럴</strong>(String literal)은 <strong><code>&amp;'static str</code></strong> 타입입니다. 이는 Rust에서 코드에 하드코딩된 <strong>불변 문자열</strong>입니다. 문자열 리터럴은 <strong>정적으로</strong> 메모리에 저장되며, 프로그램이 실행되는 동안 변경되지 않습니다. 문자열 리터럴은 주로 <code>&amp;str</code> 타입으로 다뤄집니다.</li>
</ul>
<h4 id="특성-2">특성:<a hidden class="anchor" aria-hidden="true" href="#특성-2">#</a></h4>
<ul>
<li><strong>불변</strong>: 문자열 리터럴은 변경할 수 없습니다.</li>
<li><strong>정적 메모리</strong>: 컴파일 타임에 메모리에 할당되며, 프로그램이 종료될 때까지 메모리에 유지됩니다.</li>
<li><strong>불변 참조</strong>: 문자열 리터럴은 <code>&amp;'static str</code> 타입이며, 프로그램 전반에 걸쳐 참조될 수 있습니다.</li>
</ul>
<h4 id="예시-2">예시:<a hidden class="anchor" aria-hidden="true" href="#예시-2">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> greeting: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, world!&#34;</span>;  <span style="color:#75715e">// 문자열 리터럴
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, greeting);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>참조</strong>: 문자열 리터럴은 이미 메모리에 고정되어 있기 때문에, 기본적으로 <code>&amp;str</code> 타입의 참조로 사용됩니다.</li>
</ul>
<hr>
<h3 id="메모리-저장-위치-비교"><strong>메모리 저장 위치 비교</strong><a hidden class="anchor" aria-hidden="true" href="#메모리-저장-위치-비교">#</a></h3>
<table>
  <thead>
      <tr>
          <th>자료형</th>
          <th>메모리 위치</th>
          <th>설명</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>String</code></td>
          <td>힙 (Heap)</td>
          <td>동적으로 크기가 결정되는 문자열. <code>String</code>은 힙에 할당됩니다.</td>
      </tr>
      <tr>
          <td><code>&amp;str</code></td>
          <td>스택 (Stack)</td>
          <td>문자열 리터럴이나 <code>String</code>의 슬라이스로, 불변 참조로 사용됩니다.</td>
      </tr>
      <tr>
          <td>문자열 리터럴 (<code>&quot;Hello&quot;</code>)</td>
          <td>데이터 세그먼트 (Text Segment)</td>
          <td>프로그램 실행 시 정적으로 메모리에 저장되며, <code>'static</code> 수명이 부여됩니다.</td>
      </tr>
  </tbody>
</table>
<h3 id="참조-시스템"><strong>참조 시스템</strong><a hidden class="anchor" aria-hidden="true" href="#참조-시스템">#</a></h3>
<ul>
<li><strong><code>&amp;String</code></strong>: <code>String</code>에 대한 <strong>불변 참조</strong>입니다. 소유권을 이동시키지 않고 데이터를 참조할 수 있습니다.</li>
<li><strong><code>&amp;str</code></strong>: 문자열의 <strong>불변 참조</strong>이며, 일반적으로 <code>String</code>에서 얻거나 문자열 리터럴에서 사용됩니다.</li>
</ul>
<h4 id="예시-string-vs-str">예시: <code>&amp;String</code> vs <code>&amp;str</code><a hidden class="anchor" aria-hidden="true" href="#예시-string-vs-str">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_string</span>(s: <span style="color:#66d9ef">&amp;</span>String) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_str</span>(s: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> my_string <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello, Rust!&#34;</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// &amp;String 참조를 전달
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    print_string(<span style="color:#f92672">&amp;</span>my_string);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// &amp;str 참조를 전달
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    print_str(<span style="color:#f92672">&amp;</span>my_string); <span style="color:#75715e">// String에서 &amp;str 참조를 얻음
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    print_str(<span style="color:#e6db74">&#34;Hello, world!&#34;</span>); <span style="color:#75715e">// 문자열 리터럴은 자동으로 &amp;str 타입
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>
<h3 id="정리"><strong>정리</strong><a hidden class="anchor" aria-hidden="true" href="#정리">#</a></h3>
<ul>
<li><strong><code>String</code></strong>: 힙에 저장되고, 크기가 동적으로 변할 수 있는 문자열 타입. 값에 대한 소유권을 가집니다.</li>
<li><strong><code>str</code></strong>: 슬라이스로, 고정된 크기의 불변 문자열을 참조하는 타입. <code>&amp;str</code>은 대부분 문자열 리터럴이나 <code>String</code>의 슬라이스에서 사용됩니다.</li>
<li><strong>문자열 리터럴</strong>: <code>&amp;'static str</code> 타입으로, 컴파일 시 메모리에 정적으로 할당된 불변 문자열입니다.</li>
</ul>
<p>이들을 적절하게 사용하면 메모리 효율성을 높이고, 성능 최적화에 도움이 될 수 있습니다.</p>
<h1 id="heading-3"><a hidden class="anchor" aria-hidden="true" href="#heading-3">#</a></h1>
<p>텍스트로 설명한 내용을 도표와 그림 형식으로 표현할 수 있습니다. 아래는 각 자료형(<code>String</code>, <code>str</code>, 문자열 리터럴 등)들이 메모리 상에서 어떻게 저장되는지에 대한 구조를 보여주는 간단한 다이어그램입니다.</p>
<h3 id="메모리-구조-도표"><strong>메모리 구조 도표</strong><a hidden class="anchor" aria-hidden="true" href="#메모리-구조-도표">#</a></h3>
<pre tabindex="0"><code>+-----------------------------------------------------------+
|                프로그램 메모리 (프로세스 메모리)                 |
+-----------------------------------------------------------+
|               데이터 세그먼트 (Text Segment)                  |
|  +--------------------------------------------------------+  |
|  |                문자열 리터럴 &#34;Hello, world!&#34;              |  |
|  |                (정적 메모리)                              |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
|                힙 (Heap)                                      |
|  +--------------------------------------------------------+  |
|  |                        String                            |  |
|  |    &#34;Hello, Rust!&#34; -&gt; (힙에 저장되는 동적 메모리)             |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
|                스택 (Stack)                                   |
|  +--------------------------------------------------------+  |
|  |    &amp;String -&gt; 스택에 저장된 `String`의 참조               |  |
|  |    &amp;str -&gt; &#34;Hello, world!&#34; (문자열 리터럴에 대한 참조)      |  |
|  |    &amp;str -&gt; &#34;Hello, Rust!&#34; (String에서 얻은 슬라이스)       |  |
|  +--------------------------------------------------------+  |
+-----------------------------------------------------------+
</code></pre><h3 id="메모리-구조의-상세-설명"><strong>메모리 구조의 상세 설명</strong><a hidden class="anchor" aria-hidden="true" href="#메모리-구조의-상세-설명">#</a></h3>
<ol>
<li>
<p><strong>데이터 세그먼트 (Text Segment)</strong></p>
<ul>
<li>프로그램 실행 시 <strong>문자열 리터럴</strong>은 데이터 세그먼트에 <strong>정적으로</strong> 저장됩니다.</li>
<li>예시: <code>&quot;Hello, world!&quot;</code>와 같은 문자열 리터럴은 프로그램이 시작될 때 메모리에 할당되어, 실행 중에 변경되지 않는 데이터로 저장됩니다. 이 영역은 <strong>불변</strong>입니다.</li>
</ul>
</li>
<li>
<p><strong>힙 (Heap)</strong></p>
<ul>
<li>**<code>String</code>**은 동적으로 메모리 할당을 받습니다. 즉, 프로그램 실행 중에 문자열의 크기가 변할 수 있기 때문에 **힙(Heap)**에 저장됩니다.</li>
<li>예시: <code>String::from(&quot;Hello, Rust!&quot;)</code>로 생성된 문자열은 힙에 저장됩니다. 크기와 내용이 런타임에 결정되므로, 힙에 할당되어 관리됩니다.</li>
</ul>
</li>
<li>
<p><strong>스택 (Stack)</strong></p>
<ul>
<li>**<code>&amp;String</code>**과 **<code>&amp;str</code>**은 <strong>참조</strong>를 나타냅니다. <code>&amp;String</code>은 <code>String</code>의 참조이고, <code>&amp;str</code>은 <strong>슬라이스</strong>로서 문자열에 대한 불변 참조를 가리킵니다.</li>
<li>예시:
<ul>
<li><code>&amp;String</code>은 스택에 저장된 <code>String</code>의 <strong>참조</strong>를 가리킵니다.</li>
<li><code>&quot;Hello, world!&quot;</code>는 리터럴이므로 **<code>&amp;str</code>**은 스택에 있는 <strong><code>&amp;'static str</code></strong> 참조입니다.</li>
<li><code>String</code>에서 <code>.as_str()</code> 메서드를 호출하면 얻은 **<code>&amp;str</code>**은 <code>String</code>의 힙 메모리 데이터를 참조합니다.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="다이어그램-상세화"><strong>다이어그램 상세화</strong><a hidden class="anchor" aria-hidden="true" href="#다이어그램-상세화">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>--------------------------------------------------------
</span></span><span style="display:flex;"><span>|                프로그램 메모리 (프로세스 메모리)         |
</span></span><span style="display:flex;"><span>--------------------------------------------------------
</span></span><span style="display:flex;"><span>| 데이터 세그먼트 (Text Segment)                         |
</span></span><span style="display:flex;"><span>|------------------------------------------------------|
</span></span><span style="display:flex;"><span>|   &#34;Hello, world!&#34; -&gt;  메모리 주소: 0x1234             |
</span></span><span style="display:flex;"><span>|   (문자열 리터럴, 정적으로 할당된 메모리)               |
</span></span><span style="display:flex;"><span>|------------------------------------------------------|
</span></span><span style="display:flex;"><span>| 힙 (Heap)                                              |
</span></span><span style="display:flex;"><span>|------------------------------------------------------|
</span></span><span style="display:flex;"><span>|   String -&gt; 0x5678 -&gt; &#34;Hello, Rust!&#34; (힙 메모리)       |
</span></span><span style="display:flex;"><span>|------------------------------------------------------|
</span></span><span style="display:flex;"><span>| 스택 (Stack)                                           |
</span></span><span style="display:flex;"><span>|------------------------------------------------------|
</span></span><span style="display:flex;"><span>|   &amp;String -&gt; 0x5678 (참조, 스택에 위치)                |
</span></span><span style="display:flex;"><span>|   &amp;str -&gt; &#34;Hello, world!&#34; (문자열 리터럴에 대한 참조)   |
</span></span><span style="display:flex;"><span>|   &amp;str -&gt; &#34;Hello, Rust!&#34; (String에서 얻은 슬라이스)     |
</span></span><span style="display:flex;"><span>--------------------------------------------------------
</span></span></code></pre></div><h3 id="참고-사항"><strong>참고 사항</strong><a hidden class="anchor" aria-hidden="true" href="#참고-사항">#</a></h3>
<ul>
<li><strong>문자열 리터럴</strong>은 프로그램이 시작될 때 메모리에 고정적으로 배치됩니다. <code>&quot;Hello, world!&quot;</code>와 같은 리터럴은 <strong>데이터 세그먼트</strong>에 저장되며, 불변 참조로서 스택에서 사용할 수 있습니다.</li>
<li>**<code>String</code>**은 동적으로 메모리가 할당되며, 해당 값이 힙에 저장됩니다. 크기가 동적으로 변할 수 있기 때문에 런타임에 메모리가 할당되고 해제됩니다.</li>
<li>**<code>&amp;String</code>**과 **<code>&amp;str</code>**은 모두 <strong>참조 타입</strong>입니다. 이들은 스택에 저장되며, 각각 <code>String</code>과 문자열 리터럴 또는 <code>String</code>의 슬라이스를 참조합니다.</li>
</ul>
<hr>
<p>이 그림은 각 자료형이 어떻게 메모리에서 다루어지는지, 그리고 그들 간의 관계를 직관적으로 이해하는 데 도움이 될 것입니다.</p>
<h1 id="heading-4"><a hidden class="anchor" aria-hidden="true" href="#heading-4">#</a></h1>
<p>Rust의 <strong>소유권(Ownership)</strong> 시스템은 메모리 안전성을 보장하는 핵심 개념 중 하나입니다. 소유권 시스템은 **힙(Heap)**과 **스택(Stack)**을 어떻게 다루는지에 따라 중요한 특징을 갖습니다. 이 두 메모리 영역에서 <strong>소유권</strong>과 **대상(값)**이 어떻게 이동하거나 참조되는지 설명하겠습니다.</p>
<h3 id="1-스택stack과-힙heap">1. <strong>스택(Stack)과 힙(Heap)</strong><a hidden class="anchor" aria-hidden="true" href="#1-스택stack과-힙heap">#</a></h3>
<ul>
<li><strong>스택(Stack)</strong>: 데이터를 빠르게 할당하고 해제하는 <strong>LIFO(Last-In-First-Out)</strong> 방식의 메모리 영역입니다. <strong>값의 크기가 고정된 타입</strong>(예: 정수, 부동 소수점, 고정 크기의 배열 등)을 주로 저장합니다.</li>
<li><strong>힙(Heap)</strong>: 크기가 동적으로 결정되는 데이터를 저장하는 <strong>비순차적</strong> 메모리 영역입니다. **<code>Box</code>, <code>Vec</code>, <code>String</code>**과 같은 동적 크기의 타입들은 힙에 저장됩니다.</li>
</ul>
<h3 id="2-소유권-시스템">2. <strong>소유권 시스템</strong><a hidden class="anchor" aria-hidden="true" href="#2-소유권-시스템">#</a></h3>
<p>Rust에서 소유권 시스템은 <strong>값에 대한 소유권</strong>을 추적하여 <strong>메모리 안전성</strong>을 보장하고, <strong>스택</strong>과 <strong>힙</strong>에 저장되는 값들이 어떻게 관리되는지 결정합니다. 이 시스템은 <strong>스택에 저장된 변수</strong>의 <strong>소유권</strong>이 어떻게 <strong>힙에 저장된 값</strong>에 영향을 미치는지에 대한 규칙을 정의합니다.</p>
<h4 id="기본-규칙">기본 규칙:<a hidden class="anchor" aria-hidden="true" href="#기본-규칙">#</a></h4>
<ol>
<li>
<p><strong>소유권 이동 (Ownership Transfer)</strong>:</p>
<ul>
<li>변수는 소유권을 가지며, 그 변수의 소유권이 다른 변수로 이동하면 <strong>이전 변수는 더 이상 유효하지 않</strong>습니다.</li>
<li>값이 <strong>스택</strong>에 저장되면 <strong>소유권 이동</strong>은 스택에 있는 변수에서 다른 변수로 이동합니다. 하지만 <strong>힙에 저장된 데이터</strong>의 경우, 데이터는 힙에 저장되고 해당 메모리 주소만 스택에 복사됩니다.</li>
</ul>
</li>
<li>
<p><strong>소유권 복사 (Copy)</strong>:</p>
<ul>
<li><strong><code>Copy</code> 트레이트</strong>가 구현된 타입들은 <strong>소유권 이동 없이</strong> 데이터를 복사할 수 있습니다. 예를 들어, 정수형 타입(<code>i32</code>, <code>f64</code>)이나 배열과 같은 크기가 고정된 타입들은 소유권을 이동하지 않고 복사할 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>불변 참조와 가변 참조 (Immutable and Mutable References)</strong>:</p>
<ul>
<li><strong>불변 참조</strong>(예: <code>&amp;T</code>)는 데이터를 읽기 전용으로 참조할 수 있고, <strong>가변 참조</strong>(예: <code>&amp;mut T</code>)는 데이터를 수정할 수 있습니다.</li>
<li><strong>가변 참조</strong>는 한 번에 <strong>하나만 존재할 수 있습니다</strong>. 따라서 하나의 값에 대해 가변 참조와 불변 참조가 동시에 존재할 수 없습니다.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-스택에서의-소유권">3. <strong>스택에서의 소유권</strong><a hidden class="anchor" aria-hidden="true" href="#3-스택에서의-소유권">#</a></h3>
<p>스택에 저장된 값은 <strong>스코프가 끝날 때 자동으로 해제</strong>됩니다. 스택에 있는 변수는 <strong>고정 크기</strong>여서 메모리에서 쉽게 관리할 수 있습니다. 스택에 저장된 값은 <strong>소유권이 함수나 변수 간에 이동</strong>할 때, 해당 변수가 끝날 때 자동으로 메모리에서 제거됩니다.</p>
<h4 id="예시-1-정수형-타입-copy">예시 1: <strong>정수형 타입 (Copy)</strong><a hidden class="anchor" aria-hidden="true" href="#예시-1-정수형-타입-copy">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// x는 스택에 저장되고 소유권을 가짐
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> x;   <span style="color:#75715e">// x의 값을 y로 복사(이 경우는 Copy가 가능)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;x: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, y: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, x, y);  <span style="color:#75715e">// x와 y는 각각 독립된 값
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>이 예제에서 <code>x</code>는 정수 <code>10</code>을 스택에 저장합니다. <code>y = x</code>에서 <code>x</code>의 값은 복사됩니다. 따라서 <code>x</code>와 <code>y</code>는 서로 독립적인 값을 가집니다.</li>
</ul>
<h4 id="예시-2-구조체-타입-move">예시 2: <strong>구조체 타입 (Move)</strong><a hidden class="anchor" aria-hidden="true" href="#예시-2-구조체-타입-move">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyStruct</span> {
</span></span><span style="display:flex;"><span>    value: <span style="color:#66d9ef">i32</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> MyStruct { value: <span style="color:#ae81ff">10</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a;  <span style="color:#75715e">// a의 소유권이 b로 이동
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// println!(&#34;{}&#34;, a.value);  // 오류: a는 더 이상 유효하지 않음
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>이 예제에서 <code>a</code>는 <code>MyStruct</code>를 소유합니다. <code>b = a</code>에서 <code>a</code>의 소유권이 <code>b</code>로 이동합니다. <code>a</code>는 더 이상 유효하지 않으며, <code>a</code>를 참조하려고 하면 오류가 발생합니다.</li>
</ul>
<hr>
<h3 id="4-힙에서의-소유권">4. <strong>힙에서의 소유권</strong><a hidden class="anchor" aria-hidden="true" href="#4-힙에서의-소유권">#</a></h3>
<p>힙에 저장된 값은 <strong>동적 메모리 할당</strong>을 통해 관리되며, <strong>스택에 저장된 포인터만</strong>이 힙에 저장된 데이터를 가리킵니다. 데이터 자체는 힙에 저장되며, 소유권이 이동하면 힙의 메모리 역시 관리됩니다.</p>
<h4 id="예시-3-string-힙-메모리-할당">예시 3: <strong>String (힙 메모리 할당)</strong><a hidden class="anchor" aria-hidden="true" href="#예시-3-string-힙-메모리-할당">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello&#34;</span>);  <span style="color:#75715e">// String은 힙에 저장
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> s1;  <span style="color:#75715e">// s1의 소유권이 s2로 이동
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// println!(&#34;{}&#34;, s1);  // 오류: s1은 더 이상 유효하지 않음
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>이 예제에서 <code>String</code>은 <strong>힙</strong>에 저장됩니다. <code>s1</code>의 소유권이 <code>s2</code>로 이동하면, 더 이상 <code>s1</code>을 사용할 수 없습니다. <strong>힙에 할당된 메모리</strong>는 <code>s2</code>가 끝날 때 자동으로 해제됩니다.</li>
</ul>
<h4 id="예시-4-vec-동적-배열">예시 4: <strong><code>Vec</code> (동적 배열)</strong><a hidden class="anchor" aria-hidden="true" href="#예시-4-vec-동적-배열">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];  <span style="color:#75715e">// v1은 힙에 저장된 동적 배열
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> v2 <span style="color:#f92672">=</span> v1;  <span style="color:#75715e">// v1의 소유권이 v2로 이동
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// println!(&#34;{:?}&#34;, v1);  // 오류: v1은 더 이상 유효하지 않음
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li><code>Vec</code>은 힙에 저장된 데이터입니다. <code>v1</code>의 소유권이 <code>v2</code>로 이동하면 <code>v1</code>은 더 이상 유효하지 않으며, 힙에 있는 메모리는 <code>v2</code>가 끝날 때 자동으로 해제됩니다.</li>
</ul>
<hr>
<h3 id="5-소유권과-참조의-관계">5. <strong>소유권과 참조의 관계</strong><a hidden class="anchor" aria-hidden="true" href="#5-소유권과-참조의-관계">#</a></h3>
<ul>
<li><strong>불변 참조 (<code>&amp;T</code>)</strong>: 스택에 <strong>참조를 저장</strong>합니다. 힙에 있는 값을 가리킬 수 있으며, 참조된 값은 <strong>변경할 수 없습니다</strong>.</li>
<li><strong>가변 참조 (<code>&amp;mut T</code>)</strong>: 하나의 값에 대해 <strong>하나의 가변 참조만</strong> 존재할 수 있습니다. 가변 참조는 값의 소유권을 변경하지 않지만, <strong>값을 변경</strong>할 수 있습니다.</li>
</ul>
<h4 id="예시-5-참조를-사용한-예">예시 5: <strong>참조를 사용한 예</strong><a hidden class="anchor" aria-hidden="true" href="#예시-5-참조를-사용한-예">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> s2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>s1;  <span style="color:#75715e">// 불변 참조
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, s2);  <span style="color:#75715e">// s2는 s1의 불변 참조
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// s1의 소유권은 여전히 s1에게 있음
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>이 예제에서 <code>s2</code>는 <code>s1</code>의 <strong>불변 참조</strong>입니다. <code>s2</code>는 <code>s1</code>의 값을 변경할 수 없으며, <code>s1</code>의 소유권은 여전히 <code>s1</code>이 가지고 있습니다.</li>
</ul>
<hr>
<h3 id="정리-1"><strong>정리</strong><a hidden class="anchor" aria-hidden="true" href="#정리-1">#</a></h3>
<ul>
<li><strong>스택</strong>에 저장되는 값들은 고정 크기의 타입(예: <code>i32</code>, <code>bool</code>, <code>char</code>)이나 참조 타입이며, 함수나 변수의 스코프를 벗어나면 자동으로 해제됩니다.</li>
<li><strong>힙</strong>에 저장되는 값들은 동적 크기(예: <code>String</code>, <code>Vec</code>, <code>Box</code>)를 가지며, 값은 힙에 저장되지만, 그 값을 가리키는 <strong>스택 포인터</strong>가 존재합니다.</li>
<li><strong>소유권</strong>은 데이터가 <strong>힙에 있을 때</strong>, 스택에서의 변수 간에 <strong>이동</strong>하는 형태로 다루어지며, <strong>참조</strong>를 통해 값에 접근하거나, 값을 <strong>이동</strong>시킬 수 있습니다.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/portfolio/">RyanLabs</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
